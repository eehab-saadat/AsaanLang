import {
  require_react
} from "./chunk-YZZKIYU7.js";
import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// node_modules/ace-builds/src-noconflict/ace.js
var require_ace = __commonJS({
  "node_modules/ace-builds/src-noconflict/ace.js"(exports, module) {
    (function() {
      var ACE_NAMESPACE = "ace";
      var global2 = /* @__PURE__ */ function() {
        return this;
      }();
      if (!global2 && typeof window != "undefined")
        global2 = window;
      if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
        return;
      var define2 = function(module2, deps, payload) {
        if (typeof module2 !== "string") {
          if (define2.original)
            define2.original.apply(this, arguments);
          else {
            console.error("dropping module because define wasn't a string.");
            console.trace();
          }
          return;
        }
        if (arguments.length == 2)
          payload = deps;
        if (!define2.modules[module2]) {
          define2.payloads[module2] = payload;
          define2.modules[module2] = null;
        }
      };
      define2.modules = {};
      define2.payloads = {};
      var _require = function(parentId, module2, callback) {
        if (typeof module2 === "string") {
          var payload = lookup(parentId, module2);
          if (payload != void 0) {
            callback && callback();
            return payload;
          }
        } else if (Object.prototype.toString.call(module2) === "[object Array]") {
          var params = [];
          for (var i = 0, l = module2.length; i < l; ++i) {
            var dep = lookup(parentId, module2[i]);
            if (dep == void 0 && require2.original)
              return;
            params.push(dep);
          }
          return callback && callback.apply(null, params) || true;
        }
      };
      var require2 = function(module2, callback) {
        var packagedModule = _require("", module2, callback);
        if (packagedModule == void 0 && require2.original)
          return require2.original.apply(this, arguments);
        return packagedModule;
      };
      var normalizeModule = function(parentId, moduleName) {
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };
      var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module2 = define2.modules[moduleName];
        if (!module2) {
          module2 = define2.payloads[moduleName];
          if (typeof module2 === "function") {
            var exports2 = {};
            var mod = {
              id: moduleName,
              uri: "",
              exports: exports2,
              packaged: true
            };
            var req = function(module3, callback) {
              return _require(moduleName, module3, callback);
            };
            var returnValue = module2(req, exports2, mod);
            exports2 = returnValue || mod.exports;
            define2.modules[moduleName] = exports2;
            delete define2.payloads[moduleName];
          }
          module2 = define2.modules[moduleName] = exports2 || module2;
        }
        return module2;
      };
      function exportAce(ns) {
        var root = global2;
        if (ns) {
          if (!global2[ns])
            global2[ns] = {};
          root = global2[ns];
        }
        if (!root.define || !root.define.packaged) {
          define2.original = root.define;
          root.define = define2;
          root.define.packaged = true;
        }
        if (!root.require || !root.require.packaged) {
          require2.original = root.require;
          root.require = require2;
          root.require.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(require2, exports2, module2) {
      function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
          value: val,
          enumerable: false,
          writable: true,
          configurable: true
        });
      }
      if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position) {
          position = position || 0;
          return this.lastIndexOf(searchString, position) === position;
        });
      }
      if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position) {
          var subjectString = this;
          if (position === void 0 || position > subjectString.length) {
            position = subjectString.length;
          }
          position -= searchString.length;
          var lastIndex = subjectString.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        });
      }
      if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
          var result = "";
          var string = this;
          while (count > 0) {
            if (count & 1)
              result += string;
            if (count >>= 1)
              string += string;
          }
          return result;
        });
      }
      if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position) {
          return this.indexOf(str, position) != -1;
        });
      }
      if (!Object.assign) {
        Object.assign = function(target) {
          if (target === void 0 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== void 0 && source !== null) {
              Object.keys(source).forEach(function(key) {
                output[key] = source[key];
              });
            }
          }
          return output;
        };
      }
      if (!Object.values) {
        Object.values = function(o) {
          return Object.keys(o).map(function(k) {
            return o[k];
          });
        };
      }
      if (!Array.prototype.find) {
        defineProp(Array.prototype, "find", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k = 0; k < len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
              return kValue;
            }
          }
        });
      }
      if (!Array.prototype.findIndex) {
        defineProp(Array.prototype, "findIndex", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k = 0; k < len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
              return k;
            }
          }
        });
      }
      if (!Array.prototype.includes) {
        defineProp(Array.prototype, "includes", function(item, position) {
          return this.indexOf(item, position) != -1;
        });
      }
      if (!Array.prototype.fill) {
        defineProp(Array.prototype, "fill", function(value) {
          var O = this;
          var len = O.length >>> 0;
          var start = arguments[1];
          var relativeStart = start >> 0;
          var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
          var end = arguments[2];
          var relativeEnd = end === void 0 ? len : end >> 0;
          var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
          while (k < final) {
            O[k] = value;
            k++;
          }
          return O;
        });
      }
      if (!Array.of) {
        defineProp(Array, "of", function() {
          return Array.prototype.slice.call(arguments);
        });
      }
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(require2, exports2, module2) {
      "use strict";
      require2("./es6-shim");
    });
    ace.define("ace/lib/deep_copy", ["require", "exports", "module"], function(require2, exports2, module2) {
      exports2.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
          return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]")
          return obj;
        copy = {};
        for (var key in obj)
          copy[key] = deepCopy(obj[key]);
        return copy;
      };
    });
    ace.define("ace/lib/lang", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports2, module2) {
      "use strict";
      exports2.last = function(a) {
        return a[a.length - 1];
      };
      exports2.stringReverse = function(string) {
        return string.split("").reverse().join("");
      };
      exports2.stringRepeat = function(string, count) {
        var result = "";
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports2.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, "");
      };
      exports2.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, "");
      };
      exports2.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports2.copyArray = function(array) {
        var copy = [];
        for (var i = 0, l = array.length; i < l; i++) {
          if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
          else
            copy[i] = array[i];
        }
        return copy;
      };
      exports2.deepCopy = require2("./deep_copy").deepCopy;
      exports2.arrayToMap = function(arr) {
        var map = {};
        for (var i = 0; i < arr.length; i++) {
          map[arr[i]] = 1;
        }
        return map;
      };
      exports2.createMap = function(props) {
        var map = /* @__PURE__ */ Object.create(null);
        for (var i in props) {
          map[i] = props[i];
        }
        return map;
      };
      exports2.arrayRemove = function(array, value) {
        for (var i = 0; i <= array.length; i++) {
          if (value === array[i]) {
            array.splice(i, 1);
          }
        }
      };
      exports2.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
      };
      exports2.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports2.getMatchOffsets = function(string, regExp) {
        var matches = [];
        string.replace(regExp, function(str) {
          matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches;
      };
      exports2.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var deferred = function(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function() {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function() {
          return timer;
        };
        return deferred;
      };
      exports2.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var _self = function(timeout) {
          if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
          this.cancel();
          fcn();
        };
        _self.cancel = function() {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function() {
          return timer;
        };
        return _self;
      };
      exports2.supportsLookbehind = function() {
        try {
          new RegExp("(?<=.)");
        } catch (e) {
          return false;
        }
        return true;
      };
      exports2.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
        return supportsUnicodeFlag && line.codePointAt(last) > 65535 ? 2 : 1;
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      exports2.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports2.getOS = function() {
        if (exports2.isMac) {
          return exports2.OS.MAC;
        } else if (exports2.isLinux) {
          return exports2.OS.LINUX;
        } else {
          return exports2.OS.WINDOWS;
        }
      };
      var _navigator = typeof navigator == "object" ? navigator : {};
      var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
      var ua = _navigator.userAgent || "";
      var appName = _navigator.appName || "";
      exports2.isWin = os == "win";
      exports2.isMac = os == "mac";
      exports2.isLinux = os == "linux";
      exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
      exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
      exports2.isGecko = exports2.isMozilla = ua.match(/ Gecko\/\d+/);
      exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
      exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
      exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
      exports2.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports2.isChrome || void 0;
      exports2.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
      exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports2.isAndroid = ua.indexOf("Android") >= 0;
      exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
      exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
      if (exports2.isIOS)
        exports2.isMac = true;
      exports2.isMobile = exports2.isIOS || exports2.isAndroid;
    });
    ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var useragent = require2("./useragent");
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports2.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
          var txt = document.createTextNode(arr);
          if (parent)
            parent.appendChild(txt);
          return txt;
        }
        if (!Array.isArray(arr)) {
          if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
          return arr;
        }
        if (typeof arr[0] != "string" || !arr[0]) {
          var els = [];
          for (var i = 0; i < arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch && els.push(ch);
          }
          return els;
        }
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options))
          childIndex = 2;
        for (var i = childIndex; i < arr.length; i++)
          buildDom(arr[i], el, refs);
        if (childIndex == 2) {
          Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
              el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
              el[n] = val;
            } else if (n === "ref") {
              if (refs)
                refs[val] = el;
            } else if (n === "style") {
              if (typeof val == "string")
                el.style.cssText = val;
            } else if (val != null) {
              el.setAttribute(n, val);
            }
          });
        }
        if (parent)
          parent.appendChild(el);
        return el;
      };
      exports2.getDocumentHead = function(doc) {
        if (!doc)
          doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports2.createElement = function(tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
      };
      exports2.removeChildren = function(element) {
        element.innerHTML = "";
      };
      exports2.createTextNode = function(textContent, element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createTextNode(textContent);
      };
      exports2.createFragment = function(element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createDocumentFragment();
      };
      exports2.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports2.addCssClass = function(el, name) {
        if (!exports2.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports2.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports2.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add)
          classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports2.setCssClass = function(node, className, include) {
        if (include) {
          exports2.addCssClass(node, className);
        } else {
          exports2.removeCssClass(node, className);
        }
      };
      exports2.hasCssString = function(id, doc) {
        var index = 0, sheets;
        doc = doc || document;
        if (sheets = doc.querySelectorAll("style")) {
          while (index < sheets.length) {
            if (sheets[index++].id === id) {
              return true;
            }
          }
        }
      };
      exports2.removeElementById = function(id, doc) {
        doc = doc || document;
        if (doc.getElementById(id)) {
          doc.getElementById(id).remove();
        }
      };
      var strictCSP;
      var cssCache = [];
      exports2.useStrictCSP = function(value) {
        strictCSP = value;
        if (value == false)
          insertPendingStyles();
        else if (!cssCache)
          cssCache = [];
      };
      function insertPendingStyles() {
        var cache = cssCache;
        cssCache = null;
        cache && cache.forEach(function(item) {
          importCssString(item[0], item[1]);
        });
      }
      function importCssString(cssText, id, target) {
        if (typeof document == "undefined")
          return;
        if (cssCache) {
          if (target) {
            insertPendingStyles();
          } else if (target === false) {
            return cssCache.push([cssText, id]);
          }
        }
        if (strictCSP)
          return;
        var container = target;
        if (!target || !target.getRootNode) {
          container = document;
        } else {
          container = target.getRootNode();
          if (!container || container == target)
            container = document;
        }
        var doc = container.ownerDocument || container;
        if (id && exports2.hasCssString(id, container))
          return null;
        if (id)
          cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        var style = exports2.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
          style.id = id;
        if (container == doc)
          container = exports2.getDocumentHead(doc);
        container.insertBefore(style, container.firstChild);
      }
      exports2.importCssString = importCssString;
      exports2.importCssStylsheet = function(uri, doc) {
        exports2.buildDom(["link", { rel: "stylesheet", href: uri }], exports2.getDocumentHead(doc));
      };
      exports2.scrollbarWidth = function(doc) {
        var inner = exports2.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports2.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = doc && doc.documentElement || document && document.documentElement;
        if (!body)
          return 0;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar === withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      exports2.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
      };
      exports2.setStyle = function(styles, property, value) {
        if (styles[property] !== value) {
          styles[property] = value;
        }
      };
      exports2.HAS_CSS_ANIMATION = false;
      exports2.HAS_CSS_TRANSFORMS = false;
      exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
      if (useragent.isChromeOS)
        exports2.HI_DPI = false;
      if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports2.HI_DPI && div.style.transform !== void 0)
          exports2.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
          exports2.HAS_CSS_ANIMATION = true;
        div = null;
      }
      if (exports2.HAS_CSS_TRANSFORMS) {
        exports2.translate = function(element, tx, ty) {
          element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
        };
      } else {
        exports2.translate = function(element, tx, ty) {
          element.style.top = Math.round(ty) + "px";
          element.style.left = Math.round(tx) + "px";
        };
      }
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("./dom");
      exports2.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports2.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement("script");
        s.src = path;
        head.appendChild(s);
        s.onload = s.onreadystatechange = function(_, isAbort) {
          if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
              callback();
          }
        };
      };
      exports2.qualifyURL = function(url) {
        var a = document.createElement("a");
        a.href = url;
        return a.href;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      exports2.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
      exports2.mixin = function(obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports2.implement = function(proto, mixin) {
        exports2.mixin(proto, mixin);
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var EventEmitter = {};
      var stopPropagation = function() {
        this.propagationStopped = true;
      };
      var preventDefault = function() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return;
        if (typeof e != "object" || !e)
          e = {};
        if (!e.type)
          e.type = eventName;
        if (!e.stopPropagation)
          e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
          e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](e, this);
          if (e.propagationStopped)
            break;
        }
        if (defaultHandler && !e.defaultPrevented)
          return defaultHandler(e, this);
      };
      EventEmitter._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
          return;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++)
          listeners[i](e, this);
      };
      EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.on(eventName, function newCallback() {
          _self.off(eventName, newCallback);
          callback.apply(null, arguments);
        });
        if (!callback) {
          return new Promise(function(resolve) {
            callback = resolve;
          });
        }
      };
      EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          handlers = this._defaultHandlers = { _disabled_: {} };
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
          listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;
        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function(eventName) {
        if (!eventName)
          this._eventRegistry = this._defaultHandlers = void 0;
        if (this._eventRegistry)
          this._eventRegistry[eventName] = void 0;
        if (this._defaultHandlers)
          this._defaultHandlers[eventName] = void 0;
      };
      exports2.EventEmitter = EventEmitter;
    });
    ace.define("ace/lib/report_error", ["require", "exports", "module"], function(require2, exports2, module2) {
      exports2.reportError = function reportError(msg, data) {
        var e = new Error(msg);
        e.data = data;
        if (typeof console == "object" && console.error)
          console.error(e);
        setTimeout(function() {
          throw e;
        });
      };
    });
    ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/report_error"], function(require2, exports2, module2) {
      "no use strict";
      var oop = require2("./oop");
      var EventEmitter = require2("./event_emitter").EventEmitter;
      var reportError = require2("./report_error").reportError;
      var optionsProvider = {
        setOptions: function(optList) {
          Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function(optionNames) {
          var result = {};
          if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
              return !options[key].hidden;
            });
          } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
          }
          optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function(name, value) {
          if (this["$" + name] === value)
            return;
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet)
            this["$" + name] = value;
          if (opt && opt.set)
            opt.set.call(this, value);
        },
        getOption: function(name) {
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      function warn(message) {
        if (typeof console != "undefined" && console.warn)
          console.warn.apply(console, arguments);
      }
      var messages;
      var AppConfig = (
        /** @class */
        function() {
          function AppConfig2() {
            this.$defaultOptions = {};
          }
          AppConfig2.prototype.defineOptions = function(obj, path, options) {
            if (!obj.$options)
              this.$defaultOptions[path] = obj.$options = {};
            Object.keys(options).forEach(function(key) {
              var opt = options[key];
              if (typeof opt == "string")
                opt = { forwardTo: opt };
              opt.name || (opt.name = key);
              obj.$options[opt.name] = opt;
              if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);
            return this;
          };
          AppConfig2.prototype.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
              var opt = obj.$options[key];
              if ("value" in opt)
                obj.setOption(key, opt.value);
            });
          };
          AppConfig2.prototype.setDefaultValue = function(path, name, value) {
            if (!path) {
              for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                  break;
              if (!this.$defaultOptions[path][name])
                return false;
            }
            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
            if (opts[name]) {
              if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
              else
                opts[name].value = value;
            }
          };
          AppConfig2.prototype.setDefaultValues = function(path, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
              this.setDefaultValue(path, key, optionHash[key]);
            }, this);
          };
          AppConfig2.prototype.setMessages = function(value) {
            messages = value;
          };
          AppConfig2.prototype.nls = function(string, params) {
            if (messages && !messages[string]) {
              warn("No message found for '" + string + "' in the provided messages, falling back to default English message.");
            }
            var translated = messages && messages[string] || string;
            if (params) {
              translated = translated.replace(/\$(\$|[\d]+)/g, function(_, name) {
                if (name == "$")
                  return "$";
                return params[name];
              });
            }
            return translated;
          };
          return AppConfig2;
        }()
      );
      AppConfig.prototype.warn = warn;
      AppConfig.prototype.reportError = reportError;
      oop.implement(AppConfig.prototype, EventEmitter);
      exports2.AppConfig = AppConfig;
    });
    ace.define("ace/theme/textmate-css", ["require", "exports", "module"], function(require2, exports2, module2) {
      module2.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate-css", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      exports2.isDark = false;
      exports2.cssClass = "ace-tm";
      exports2.cssText = require2("./textmate-css");
      exports2.$id = "ace/theme/textmate";
      var dom = require2("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config", "ace/theme/textmate"], function(require2, exports2, module2) {
      "no use strict";
      var lang = require2("./lib/lang");
      var net = require2("./lib/net");
      var dom = require2("./lib/dom");
      var AppConfig = require2("./lib/app_config").AppConfig;
      module2.exports = exports2 = new AppConfig();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false,
        useStrictCSP: null
      };
      exports2.get = function(key) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports2.set = function(key, value) {
        if (options.hasOwnProperty(key))
          options[key] = value;
        else if (this.setDefaultValue("", key, value) == false)
          throw new Error("Unknown config key: " + key);
        if (key == "useStrictCSP")
          dom.useStrictCSP(value);
      };
      exports2.all = function() {
        return lang.copyObject(options);
      };
      exports2.$modes = {};
      exports2.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
          return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re, "");
        }
        if ((!base || base == component) && parts.length > 1)
          base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
          path = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path && path.slice(-1) != "/")
          path += "/";
        return path + component + sep + base + this.get("suffix");
      };
      exports2.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      var loader = function(moduleName, cb) {
        if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
          return cb(null, require2("./theme/textmate"));
        if (customLoader)
          return customLoader(moduleName, cb);
        console.error("loader is not configured");
      };
      var customLoader;
      exports2.setLoader = function(cb) {
        customLoader = cb;
      };
      exports2.dynamicModules = /* @__PURE__ */ Object.create(null);
      exports2.$loading = {};
      exports2.$loaded = {};
      exports2.loadModule = function(moduleName, onLoad) {
        var loadedModule, moduleType;
        if (Array.isArray(moduleName)) {
          moduleType = moduleName[0];
          moduleName = moduleName[1];
        }
        var load = function(module3) {
          if (module3 && !exports2.$loading[moduleName])
            return onLoad && onLoad(module3);
          if (!exports2.$loading[moduleName])
            exports2.$loading[moduleName] = [];
          exports2.$loading[moduleName].push(onLoad);
          if (exports2.$loading[moduleName].length > 1)
            return;
          var afterLoad = function() {
            loader(moduleName, function(err, module4) {
              if (module4)
                exports2.$loaded[moduleName] = module4;
              exports2._emit("load.module", { name: moduleName, module: module4 });
              var listeners = exports2.$loading[moduleName];
              exports2.$loading[moduleName] = null;
              listeners.forEach(function(onLoad2) {
                onLoad2 && onLoad2(module4);
              });
            });
          };
          if (!exports2.get("packaged"))
            return afterLoad();
          net.loadScript(exports2.moduleUrl(moduleName, moduleType), afterLoad);
          reportErrorIfPathIsNotConfigured();
        };
        if (exports2.dynamicModules[moduleName]) {
          exports2.dynamicModules[moduleName]().then(function(module3) {
            if (module3.default) {
              load(module3.default);
            } else {
              load(module3);
            }
          });
        } else {
          try {
            loadedModule = this.$require(moduleName);
          } catch (e) {
          }
          load(loadedModule || exports2.$loaded[moduleName]);
        }
      };
      exports2.$require = function(moduleName) {
        if (typeof module2.require == "function") {
          var req = "require";
          return module2[req](moduleName);
        }
      };
      exports2.setModuleLoader = function(moduleName, onLoad) {
        exports2.dynamicModules[moduleName] = onLoad;
      };
      var reportErrorIfPathIsNotConfigured = function() {
        if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
          console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
          reportErrorIfPathIsNotConfigured = function() {
          };
        }
      };
      exports2.version = "1.32.0";
    });
    ace.define("ace/loader_build", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      require2("./lib/fixoldbrowsers");
      var config = require2("./config");
      config.setLoader(function(moduleName, cb) {
        require2([moduleName], function(module3) {
          cb(null, module3);
        });
      });
      var global2 = /* @__PURE__ */ function() {
        return this || typeof window != "undefined" && window;
      }();
      module2.exports = function(ace2) {
        config.init = init;
        config.$require = require2;
        ace2.require = require2;
        if (typeof define === "function")
          ace2.define = define;
      };
      init(true);
      function init(packaged) {
        if (!global2 || !global2.document)
          return;
        config.set("packaged", packaged || require2.packaged || module2.packaged || global2.define && define.packaged);
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = document.currentScript || document._currentScript;
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        if (currentScript && currentScript.src) {
          scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
        }
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
          var script = scripts[i];
          var src = script.src || script.getAttribute("src");
          if (!src)
            continue;
          var attributes = script.attributes;
          for (var j = 0, l = attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
          if (m)
            scriptUrl = m[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions)
          if (typeof scriptOptions[key] !== "undefined")
            config.set(key, scriptOptions[key]);
      }
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) {
          return m1.toUpperCase();
        });
      }
    });
    ace.define("ace/range", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      var Range = (
        /** @class */
        function() {
          function Range2(startRow, startColumn, endRow, endColumn) {
            this.start = {
              row: startRow,
              column: startColumn
            };
            this.end = {
              row: endRow,
              column: endColumn
            };
          }
          Range2.prototype.isEqual = function(range) {
            return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
          };
          Range2.prototype.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
          };
          Range2.prototype.contains = function(row, column) {
            return this.compare(row, column) == 0;
          };
          Range2.prototype.compareRange = function(range) {
            var cmp, end = range.end, start = range.start;
            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
              cmp = this.compare(start.row, start.column);
              if (cmp == 1) {
                return 2;
              } else if (cmp == 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (cmp == -1) {
              return -2;
            } else {
              cmp = this.compare(start.row, start.column);
              if (cmp == -1) {
                return -1;
              } else if (cmp == 1) {
                return 42;
              } else {
                return 0;
              }
            }
          };
          Range2.prototype.comparePoint = function(p) {
            return this.compare(p.row, p.column);
          };
          Range2.prototype.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
          };
          Range2.prototype.intersects = function(range) {
            var cmp = this.compareRange(range);
            return cmp == -1 || cmp == 0 || cmp == 1;
          };
          Range2.prototype.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
          };
          Range2.prototype.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
          };
          Range2.prototype.setStart = function(row, column) {
            if (typeof row == "object") {
              this.start.column = row.column;
              this.start.row = row.row;
            } else {
              this.start.row = row;
              this.start.column = column;
            }
          };
          Range2.prototype.setEnd = function(row, column) {
            if (typeof row == "object") {
              this.end.column = row.column;
              this.end.row = row.row;
            } else {
              this.end.row = row;
              this.end.column = column;
            }
          };
          Range2.prototype.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.compare = function(row, column) {
            if (!this.isMultiLine()) {
              if (row === this.start.row) {
                return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
              }
            }
            if (row < this.start.row)
              return -1;
            if (row > this.end.row)
              return 1;
            if (this.start.row === row)
              return column >= this.start.column ? 0 : -1;
            if (this.end.row === row)
              return column <= this.end.column ? 0 : 1;
            return 0;
          };
          Range2.prototype.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
              var end = { row: lastRow + 1, column: 0 };
            else if (this.end.row < firstRow)
              var end = { row: firstRow, column: 0 };
            if (this.start.row > lastRow)
              var start = { row: lastRow + 1, column: 0 };
            else if (this.start.row < firstRow)
              var start = { row: firstRow, column: 0 };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.extend = function(row, column) {
            var cmp = this.compare(row, column);
            if (cmp == 0)
              return this;
            else if (cmp == -1)
              var start = { row, column };
            else
              var end = { row, column };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
          };
          Range2.prototype.isMultiLine = function() {
            return this.start.row !== this.end.row;
          };
          Range2.prototype.clone = function() {
            return Range2.fromPoints(this.start, this.end);
          };
          Range2.prototype.collapseRows = function() {
            if (this.end.column == 0)
              return new Range2(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
            else
              return new Range2(this.start.row, 0, this.end.row, 0);
          };
          Range2.prototype.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);
            return new Range2(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
          };
          Range2.prototype.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
          };
          return Range2;
        }()
      );
      Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = comparePoints;
      Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports2.Range = Range;
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./oop");
      var Keys = function() {
        var ret = {
          MODIFIER_KEYS: {
            16: "Shift",
            17: "Ctrl",
            18: "Alt",
            224: "Meta",
            91: "MetaLeft",
            92: "MetaRight",
            93: "ContextMenu"
          },
          KEY_MODS: {
            "ctrl": 1,
            "alt": 2,
            "option": 2,
            "shift": 4,
            "super": 8,
            "meta": 8,
            "command": 8,
            "cmd": 8,
            "control": 1
          },
          FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            96: "Numpad0",
            97: "Numpad1",
            98: "Numpad2",
            99: "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            "-13": "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
          },
          PRINTABLE_KEYS: {
            32: " ",
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            59: ";",
            61: "=",
            65: "a",
            66: "b",
            67: "c",
            68: "d",
            69: "e",
            70: "f",
            71: "g",
            72: "h",
            73: "i",
            74: "j",
            75: "k",
            76: "l",
            77: "m",
            78: "n",
            79: "o",
            80: "p",
            81: "q",
            82: "r",
            83: "s",
            84: "t",
            85: "u",
            86: "v",
            87: "w",
            88: "x",
            89: "y",
            90: "z",
            107: "+",
            109: "-",
            110: ".",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            111: "/",
            106: "*"
          }
        };
        ret.PRINTABLE_KEYS[173] = "-";
        var name, i;
        for (i in ret.FUNCTION_KEYS) {
          name = ret.FUNCTION_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        for (i in ret.PRINTABLE_KEYS) {
          name = ret.PRINTABLE_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        oop.mixin(ret, ret.MODIFIER_KEYS);
        oop.mixin(ret, ret.PRINTABLE_KEYS);
        oop.mixin(ret, ret.FUNCTION_KEYS);
        ret.enter = ret["return"];
        ret.escape = ret.esc;
        ret.del = ret["delete"];
        (function() {
          var mods = ["cmd", "ctrl", "alt", "shift"];
          for (var i2 = Math.pow(2, mods.length); i2--; ) {
            ret.KEY_MODS[i2] = mods.filter(function(x) {
              return i2 & ret.KEY_MODS[x];
            }).join("-") + "-";
          }
        })();
        ret.KEY_MODS[0] = "";
        ret.KEY_MODS[-1] = "input-";
        return ret;
      }();
      oop.mixin(exports2, Keys);
      exports2.default = exports2;
      exports2.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
          keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var keys = require2("./keys");
      var useragent = require2("./useragent");
      var pressedKeys = null;
      var ts = 0;
      var activeListenerOptions;
      function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
          document.createComment("").addEventListener("test", function() {
          }, {
            get passive() {
              activeListenerOptions = { passive: false };
            }
          });
        } catch (e) {
        }
      }
      function getListenerOptions() {
        if (activeListenerOptions == void 0)
          detectListenerOptionsSupport();
        return activeListenerOptions;
      }
      function EventListener(elem, type, callback) {
        this.elem = elem;
        this.type = type;
        this.callback = callback;
      }
      EventListener.prototype.destroy = function() {
        removeListener(this.elem, this.type, this.callback);
        this.elem = this.type = this.callback = void 0;
      };
      var addListener = exports2.addListener = function(elem, type, callback, destroyer) {
        elem.addEventListener(type, callback, getListenerOptions());
        if (destroyer)
          destroyer.$toDestroy.push(new EventListener(elem, type, callback));
      };
      var removeListener = exports2.removeListener = function(elem, type, callback) {
        elem.removeEventListener(type, callback, getListenerOptions());
      };
      exports2.stopEvent = function(e) {
        exports2.stopPropagation(e);
        exports2.preventDefault(e);
        return false;
      };
      exports2.stopPropagation = function(e) {
        if (e.stopPropagation)
          e.stopPropagation();
      };
      exports2.preventDefault = function(e) {
        if (e.preventDefault)
          e.preventDefault();
      };
      exports2.getButton = function(e) {
        if (e.type == "dblclick")
          return 0;
        if (e.type == "contextmenu" || useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey))
          return 2;
        return e.button;
      };
      exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
        var ownerDocument = el && el.ownerDocument || document;
        function onMouseUp(e) {
          eventHandler && eventHandler(e);
          releaseCaptureHandler && releaseCaptureHandler(e);
          removeListener(ownerDocument, "mousemove", eventHandler);
          removeListener(ownerDocument, "mouseup", onMouseUp);
          removeListener(ownerDocument, "dragstart", onMouseUp);
        }
        addListener(ownerDocument, "mousemove", eventHandler);
        addListener(ownerDocument, "mouseup", onMouseUp);
        addListener(ownerDocument, "dragstart", onMouseUp);
        return onMouseUp;
      };
      exports2.addMouseWheelListener = function(el, callback, destroyer) {
        addListener(el, "wheel", function(e) {
          var factor = 0.15;
          var deltaX = e.deltaX || 0;
          var deltaY = e.deltaY || 0;
          switch (e.deltaMode) {
            case e.DOM_DELTA_PIXEL:
              e.wheelX = deltaX * factor;
              e.wheelY = deltaY * factor;
              break;
            case e.DOM_DELTA_LINE:
              var linePixels = 15;
              e.wheelX = deltaX * linePixels;
              e.wheelY = deltaY * linePixels;
              break;
            case e.DOM_DELTA_PAGE:
              var pagePixels = 150;
              e.wheelX = deltaX * pagePixels;
              e.wheelY = deltaY * pagePixels;
              break;
          }
          callback(e);
        }, destroyer);
      };
      exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        function onMousedown(e) {
          if (exports2.getButton(e) !== 0) {
            clicks = 0;
          } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
              clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
              clicks = 1;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e.clientX;
              startY = e.clientY;
            }
          }
          e._clicks = clicks;
          eventHandler[callbackName]("mousedown", e);
          if (clicks > 4)
            clicks = 0;
          else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
        }
        if (!Array.isArray(elements))
          elements = [elements];
        elements.forEach(function(el) {
          addListener(el, "mousedown", onMousedown, destroyer);
        });
      };
      var getModifierHash = function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
      };
      exports2.getModifierString = function(e) {
        return keys.KEY_MODS[getModifierHash(e)];
      };
      function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);
        if (!useragent.isMac && pressedKeys) {
          if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
              pressedKeys.altGr = 0;
            else
              return;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
              if (pressedKeys[keyCode] == 1)
                ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
              var dt = e.timeStamp - ts;
              if (dt < 50)
                pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          var location = "location" in e ? e.location : e.keyLocation;
          if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
              return;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e, hashId, keyCode);
          if (e.defaultPrevented)
            return;
          else
            hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e, hashId, keyCode);
      }
      exports2.addCommandKeyListener = function(el, callback, destroyer) {
        if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
          var lastKeyDownKeyCode = null;
          addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
          }, destroyer);
          addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
          }, destroyer);
        } else {
          var lastDefaultPrevented = null;
          addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
          }, destroyer);
          addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
              exports2.stopEvent(e);
              lastDefaultPrevented = null;
            }
          }, destroyer);
          addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
          }, destroyer);
          if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
          }
        }
      };
      function resetPressedKeys() {
        pressedKeys = /* @__PURE__ */ Object.create(null);
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports2.nextTick = function(callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId++;
          var listener = function(e) {
            if (e.data == messageName) {
              exports2.stopPropagation(e);
              removeListener(win, "message", listener);
              callback();
            }
          };
          addListener(win, "message", listener);
          win.postMessage(messageName, "*");
        };
      }
      exports2.$idleBlocked = false;
      exports2.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
          if (!exports2.$idleBlocked) {
            cb();
          } else {
            setTimeout(handler, 100);
          }
        }, timeout);
      };
      exports2.$idleBlockId = null;
      exports2.blockIdle = function(delay) {
        if (exports2.$idleBlockId)
          clearTimeout(exports2.$idleBlockId);
        exports2.$idleBlocked = true;
        exports2.$idleBlockId = setTimeout(function() {
          exports2.$idleBlocked = false;
        }, delay || 100);
      };
      exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
      if (exports2.nextFrame)
        exports2.nextFrame = exports2.nextFrame.bind(window);
      else
        exports2.nextFrame = function(callback) {
          setTimeout(callback, 17);
        };
    });
    ace.define("ace/clipboard", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var $cancelT;
      module2.exports = {
        lineMode: false,
        pasteCancelled: function() {
          if ($cancelT && $cancelT > Date.now() - 50)
            return true;
          return $cancelT = false;
        },
        cancel: function() {
          $cancelT = Date.now();
        }
      };
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/config", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("../lib/event");
      var nls = require2("../config").nls;
      var useragent = require2("../lib/useragent");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var clipboard = require2("../clipboard");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var HAS_FOCUS_ARGS = useragent.isChrome > 63;
      var MAX_LINE_LENGTH = 400;
      var KEYS = require2("../lib/keys");
      var MODS = KEYS.KEY_MODS;
      var isIOS = useragent.isIOS;
      var valueResetRegex = isIOS ? /\s/ : /\n/;
      var isMobile = useragent.isMobile;
      var TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", false);
        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var sendingText = false;
        var tempStyle = "";
        if (!isMobile)
          text.style.fontSize = "1px";
        var commandMode = false;
        var ignoreFocusEvents = false;
        var lastValue = "";
        var lastSelectionStart = 0;
        var lastSelectionEnd = 0;
        var lastRestoreEnd = 0;
        var rowStart = Number.MAX_SAFE_INTEGER;
        var rowEnd = Number.MIN_SAFE_INTEGER;
        var numberOfExtraLines = 0;
        try {
          var isFocused = document.activeElement === text;
        } catch (e) {
        }
        this.setNumberOfExtraLines = function(number) {
          rowStart = Number.MAX_SAFE_INTEGER;
          rowEnd = Number.MIN_SAFE_INTEGER;
          if (number < 0) {
            numberOfExtraLines = 0;
            return;
          }
          numberOfExtraLines = number;
        };
        this.setAriaOptions = function(options) {
          if (options.activeDescendant) {
            text.setAttribute("aria-haspopup", "true");
            text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
            text.setAttribute("aria-activedescendant", options.activeDescendant);
          } else {
            text.setAttribute("aria-haspopup", "false");
            text.setAttribute("aria-autocomplete", "both");
            text.removeAttribute("aria-activedescendant");
          }
          if (options.role) {
            text.setAttribute("role", options.role);
          }
          if (options.setLabel) {
            text.setAttribute("aria-roledescription", nls("editor"));
            if (host.session) {
              var row = host.session.selection.cursor.row;
              text.setAttribute("aria-label", nls("Cursor at row $0", [row + 1]));
            }
          }
        };
        this.setAriaOptions({ role: "textbox" });
        event.addListener(text, "blur", function(e) {
          if (ignoreFocusEvents)
            return;
          host.onBlur(e);
          isFocused = false;
        }, host);
        event.addListener(text, "focus", function(e) {
          if (ignoreFocusEvents)
            return;
          isFocused = true;
          if (useragent.isEdge) {
            try {
              if (!document.hasFocus())
                return;
            } catch (e2) {
            }
          }
          host.onFocus(e);
          if (useragent.isEdge)
            setTimeout(resetSelection);
          else
            resetSelection();
        }, host);
        this.$focusScroll = false;
        this.focus = function() {
          this.setAriaOptions({
            setLabel: host.renderer.enableKeyboardAccessibility
          });
          if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return text.focus({ preventScroll: true });
          var top = text.style.top;
          text.style.position = "fixed";
          text.style.top = "0px";
          try {
            var isTransformed = text.getBoundingClientRect().top != 0;
          } catch (e) {
            return;
          }
          var ancestors = [];
          if (isTransformed) {
            var t = text.parentElement;
            while (t && t.nodeType == 1) {
              ancestors.push(t);
              t.setAttribute("ace_nocontext", true);
              if (!t.parentElement && t.getRootNode)
                t = t.getRootNode().host;
              else
                t = t.parentElement;
            }
          }
          text.focus({ preventScroll: true });
          if (isTransformed) {
            ancestors.forEach(function(p) {
              p.removeAttribute("ace_nocontext");
            });
          }
          setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
              text.style.top = top;
          }, 0);
        };
        this.blur = function() {
          text.blur();
        };
        this.isFocused = function() {
          return isFocused;
        };
        host.on("beforeEndOperation", function() {
          var curOp = host.curOp;
          var commandName = curOp && curOp.command && curOp.command.name;
          if (commandName == "insertstring")
            return;
          var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
          if (inComposition && isUserAction) {
            lastValue = text.value = "";
            onCompositionEnd();
          }
          resetSelection();
        });
        var positionToSelection = function(row, column) {
          var selection = column;
          for (var i = 1; i <= row - rowStart && i < 2 * numberOfExtraLines + 1; i++) {
            selection += host.session.getLine(row - i).length + 1;
          }
          return selection;
        };
        var resetSelection = isIOS ? function(value) {
          if (!isFocused || copied && !value || sendingText)
            return;
          if (!value)
            value = "";
          var newValue = "\n ab" + value + "cde fg\n";
          if (newValue != text.value)
            text.value = lastValue = newValue;
          var selectionStart = 4;
          var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
          if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
            text.setSelectionRange(selectionStart, selectionEnd);
          }
          lastSelectionStart = selectionStart;
          lastSelectionEnd = selectionEnd;
        } : function() {
          if (inComposition || sendingText)
            return;
          if (!isFocused && !afterContextMenu)
            return;
          inComposition = true;
          var selectionStart = 0;
          var selectionEnd = 0;
          var line = "";
          if (host.session) {
            var selection = host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;
            if (row === rowEnd + 1) {
              rowStart = rowEnd + 1;
              rowEnd = rowStart + 2 * numberOfExtraLines;
            } else if (row === rowStart - 1) {
              rowEnd = rowStart - 1;
              rowStart = rowEnd - 2 * numberOfExtraLines;
            } else if (row < rowStart - 1 || row > rowEnd + 1) {
              rowStart = row > numberOfExtraLines ? row - numberOfExtraLines : 0;
              rowEnd = row > numberOfExtraLines ? row + numberOfExtraLines : 2 * numberOfExtraLines;
            }
            var lines = [];
            for (var i = rowStart; i <= rowEnd; i++) {
              lines.push(host.session.getLine(i));
            }
            line = lines.join("\n");
            selectionStart = positionToSelection(range.start.row, range.start.column);
            selectionEnd = positionToSelection(range.end.row, range.end.column);
            if (range.start.row < rowStart) {
              var prevLine = host.session.getLine(rowStart - 1);
              selectionStart = range.start.row < rowStart - 1 ? 0 : selectionStart;
              selectionEnd += prevLine.length + 1;
              line = prevLine + "\n" + line;
            } else if (range.end.row > rowEnd) {
              var nextLine = host.session.getLine(rowEnd + 1);
              selectionEnd = range.end.row > rowEnd + 1 ? nextLine.length : range.end.column;
              selectionEnd += line.length + 1;
              line = line + "\n" + nextLine;
            } else if (isMobile && row > 0) {
              line = "\n" + line;
              selectionEnd += 1;
              selectionStart += 1;
            }
            if (line.length > MAX_LINE_LENGTH) {
              if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                line = line.slice(0, MAX_LINE_LENGTH);
              } else {
                line = "\n";
                if (selectionStart == selectionEnd) {
                  selectionStart = selectionEnd = 0;
                } else {
                  selectionStart = 0;
                  selectionEnd = 1;
                }
              }
            }
            var newValue = line + "\n\n";
            if (newValue != lastValue) {
              text.value = lastValue = newValue;
              lastSelectionStart = lastSelectionEnd = newValue.length;
            }
          }
          if (afterContextMenu) {
            lastSelectionStart = text.selectionStart;
            lastSelectionEnd = text.selectionEnd;
          }
          if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
            try {
              text.setSelectionRange(selectionStart, selectionEnd);
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
            } catch (e) {
            }
          }
          inComposition = false;
        };
        this.resetSelection = resetSelection;
        if (isFocused)
          host.onFocus();
        var isAllSelected = function(text2) {
          return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
        };
        var onSelect = function(e) {
          if (inComposition)
            return;
          if (copied) {
            copied = false;
          } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (isMobile && text.selectionStart != lastSelectionStart) {
            resetSelection();
          }
        };
        var inputHandler = null;
        this.setInputHandler = function(cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function() {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function(value, fromInput) {
          if (afterContextMenu)
            afterContextMenu = false;
          if (pasted) {
            resetSelection();
            if (value)
              host.onPaste(value);
            pasted = false;
            return "";
          } else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
            var i = 0;
            while (extendLeft > 0 && lastValue[i] == value[i]) {
              i++;
              extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {
              i++;
              extendRight--;
            }
            restoreStart -= i - 1;
            restoreEnd -= i - 1;
            var endIndex = inserted.length - i + 1;
            if (endIndex < 0) {
              extendLeft = -endIndex;
              endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
              return "";
            sendingText = true;
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
              inserted = "  ";
              shouldReset = true;
            }
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
              host.onTextInput(inserted);
            } else {
              host.onTextInput(inserted, {
                extendLeft,
                extendRight,
                restoreStart,
                restoreEnd
              });
            }
            sendingText = false;
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
          }
        };
        var onInput = function(e) {
          if (inComposition)
            return onCompositionUpdate();
          if (e && e.inputType) {
            if (e.inputType == "historyUndo")
              return host.execCommand("undo");
            if (e.inputType == "historyRedo")
              return host.execCommand("redo");
          }
          var data = text.value;
          var inserted = sendText(data, true);
          if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
            resetSelection();
          }
        };
        var handleClipboardData = function(e, data, forceIEMime) {
          var clipboardData = e.clipboardData || window.clipboardData;
          if (!clipboardData || BROKEN_SETDATA)
            return;
          var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
          try {
            if (data) {
              return clipboardData.setData(mime, data) !== false;
            } else {
              return clipboardData.getData(mime);
            }
          } catch (e2) {
            if (!forceIEMime)
              return handleClipboardData(e2, data, true);
          }
        };
        var doCopy = function(e, isCut) {
          var data = host.getCopyText();
          if (!data)
            return event.preventDefault(e);
          if (handleClipboardData(e, data)) {
            if (isIOS) {
              resetSelection(data);
              copied = data;
              setTimeout(function() {
                copied = false;
              }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function() {
              copied = false;
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function(e) {
          doCopy(e, true);
        };
        var onCopy = function(e) {
          doCopy(e, false);
        };
        var onPaste = function(e) {
          var data = handleClipboardData(e);
          if (clipboard.pasteCancelled())
            return;
          if (typeof data == "string") {
            if (data)
              host.onPaste(data, e);
            if (useragent.isIE)
              setTimeout(resetSelection);
            event.preventDefault(e);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
        event.addListener(text, "select", onSelect, host);
        event.addListener(text, "input", onInput, host);
        event.addListener(text, "cut", onCut, host);
        event.addListener(text, "copy", onCopy, host);
        event.addListener(text, "paste", onPaste, host);
        if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
          event.addListener(parentNode, "keydown", function(e) {
            if (useragent.isMac && !e.metaKey || !e.ctrlKey)
              return;
            switch (e.keyCode) {
              case 67:
                onCopy(e);
                break;
              case 86:
                onPaste(e);
                break;
              case 88:
                onCut(e);
                break;
            }
          }, host);
        }
        var onCompositionStart = function(e) {
          if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
          inComposition = {};
          if (commandMode)
            return;
          if (e.data)
            inComposition.useTextareaForIME = false;
          setTimeout(onCompositionUpdate, 0);
          host._signal("compositionStart");
          host.on("mousedown", cancelComposition);
          var range = host.getSelectionRange();
          range.end.row = range.start.row;
          range.end.column = range.start.column;
          inComposition.markerRange = range;
          inComposition.selectionStart = lastSelectionStart;
          host.onCompositionStart(inComposition);
          if (inComposition.useTextareaForIME) {
            lastValue = text.value = "";
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
          } else {
            if (text.msGetInputContext)
              inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
              inComposition.context = text.getInputContext();
          }
        };
        var onCompositionUpdate = function() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
          if (commandMode)
            return cancelComposition();
          if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
          } else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
              if (inComposition.context) {
                inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
              }
              inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
          }
        };
        var onCompositionEnd = function(e) {
          if (!host.onCompositionEnd || host.$readOnly)
            return;
          inComposition = false;
          host.onCompositionEnd();
          host.off("mousedown", cancelComposition);
          if (e)
            onInput();
        };
        function cancelComposition() {
          ignoreFocusEvents = true;
          text.blur();
          text.focus();
          ignoreFocusEvents = false;
        }
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
        function onKeyup(e) {
          if (e.keyCode == 27 && text.value.length < text.selectionStart) {
            if (!inComposition)
              lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
          }
          syncComposition();
        }
        event.addListener(text, "compositionstart", onCompositionStart, host);
        event.addListener(text, "compositionupdate", onCompositionUpdate, host);
        event.addListener(text, "keyup", onKeyup, host);
        event.addListener(text, "keydown", syncComposition, host);
        event.addListener(text, "compositionend", onCompositionEnd, host);
        this.getElement = function() {
          return text;
        };
        this.setCommandMode = function(value) {
          commandMode = value;
          text.readOnly = false;
        };
        this.setReadOnly = function(readOnly) {
          if (!commandMode)
            text.readOnly = readOnly;
        };
        this.setCopyWithEmptySelection = function(value) {
        };
        this.onContextMenu = function(e) {
          afterContextMenu = true;
          resetSelection();
          host._emit("nativecontextmenu", { target: host, domEvent: e });
          this.moveToMouse(e, true);
        };
        this.moveToMouse = function(e, bringToFront) {
          if (!tempStyle)
            tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function(e2) {
            dom.translate(text, e2.clientX - left - 2, Math.min(e2.clientY - top - 2, maxTop));
          };
          move(e);
          if (e.type != "mousedown")
            return;
          host.renderer.$isMousePressed = true;
          clearTimeout(closeTimeout);
          if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function() {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = "";
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
              host.renderer.$moveTextAreaToCursor();
          }, 0);
        }
        var onContextMenu = function(e) {
          host.textInput.onContextMenu(e);
          onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu, host);
        event.addListener(text, "mousedown", function(e) {
          e.preventDefault();
          onContextMenuClose();
        }, host);
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
        event.addListener(text, "contextmenu", onContextMenu, host);
        if (isIOS)
          addIosSelectionHandler(parentNode, host, text);
        function addIosSelectionHandler(parentNode2, host2, text2) {
          var typingResetTimeout = null;
          var typing = false;
          text2.addEventListener("keydown", function(e) {
            if (typingResetTimeout)
              clearTimeout(typingResetTimeout);
            typing = true;
          }, true);
          text2.addEventListener("keyup", function(e) {
            typingResetTimeout = setTimeout(function() {
              typing = false;
            }, 100);
          }, true);
          var detectArrowKeys = function(e) {
            if (document.activeElement !== text2)
              return;
            if (typing || inComposition || host2.$mouseHandler.isMousePressed)
              return;
            if (copied) {
              return;
            }
            var selectionStart = text2.selectionStart;
            var selectionEnd = text2.selectionEnd;
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
              key = KEYS.up;
            } else if (selectionStart == 1) {
              key = KEYS.home;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
              key = KEYS.end;
            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
              key = KEYS.left;
              modifier = MODS.option;
            } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.left;
            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
              key = KEYS.down;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
              key = KEYS.right;
              modifier = MODS.option;
            } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.right;
            }
            if (selectionStart !== selectionEnd)
              modifier |= MODS.shift;
            if (key) {
              var result = host2.onCommandKey({}, modifier, key);
              if (!result && host2.commands) {
                key = KEYS.keyCodeToString(key);
                var command = host2.commands.findKeyCommand(modifier, key);
                if (command)
                  host2.execCommand(command);
              }
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
              resetSelection("");
            }
          };
          document.addEventListener("selectionchange", detectArrowKeys);
          host2.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
          });
        }
        this.destroy = function() {
          if (text.parentElement)
            text.parentElement.removeChild(text);
        };
      };
      exports2.TextInput = TextInput;
      exports2.$setUserAgentForTests = function(_isMobile, _isIOS) {
        isMobile = _isMobile;
        isIOS = _isIOS;
      };
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var useragent = require2("../lib/useragent");
      var DRAG_OFFSET = 0;
      var SCROLL_COOLDOWN_T = 550;
      var DefaultHandlers = (
        /** @class */
        function() {
          function DefaultHandlers2(mouseHandler) {
            mouseHandler.$clickSelection = null;
            var editor = mouseHandler.editor;
            editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
            editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
            editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
            editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
            editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
            var exports3 = [
              "select",
              "startSelect",
              "selectEnd",
              "selectAllEnd",
              "selectByWordsEnd",
              "selectByLinesEnd",
              "dragWait",
              "dragWaitEnd",
              "focusWait"
            ];
            exports3.forEach(function(x) {
              mouseHandler[x] = this[x];
            }, this);
            mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
            mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
          }
          DefaultHandlers2.prototype.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;
            var button = ev.getButton();
            if (button !== 0) {
              var selectionRange = editor.getSelectionRange();
              var selectionEmpty = selectionRange.isEmpty();
              if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
              if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                  ev.preventDefault();
              }
              return;
            }
            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
              editor.focus();
              if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
              }
            }
            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
          };
          DefaultHandlers2.prototype.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            if (!this.mousedownEvent)
              return;
            if (this.mousedownEvent.getShiftKey())
              editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
              editor.selection.moveToPosition(pos);
            if (!waitForClickSelection)
              this.select();
            editor.setStyle("ace_selecting");
            this.setState("select");
          };
          DefaultHandlers2.prototype.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
              var cmp = this.$clickSelection.comparePoint(cursor);
              if (cmp == -1) {
                anchor = this.$clickSelection.end;
              } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
              var cmpStart = this.$clickSelection.comparePoint(range.start);
              var cmpEnd = this.$clickSelection.comparePoint(range.end);
              if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                  cursor = range.start;
              } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                  cursor = range.end;
              } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
          };
          DefaultHandlers2.prototype.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();
            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
              this.startSelect(this.mousedownEvent.getDocumentPosition());
          };
          DefaultHandlers2.prototype.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;
            var range = session.getBracketRange(pos);
            if (range) {
              if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
              }
              this.setState("select");
            } else {
              range = editor.selection.getWordRange(pos.row, pos.column);
              this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
          };
          DefaultHandlers2.prototype.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
              this.$clickSelection = editor.selection.getLineRange(range.start.row);
              this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
              this.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            this.select();
          };
          DefaultHandlers2.prototype.onQuadClick = function(ev) {
            var editor = this.editor;
            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
          };
          DefaultHandlers2.prototype.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
              return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
              ev.wheelX = ev.wheelY;
              ev.wheelY = 0;
            }
            var editor = this.editor;
            if (!this.$lastScroll)
              this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            var prevScroll = this.$lastScroll;
            var t = ev.domEvent.timeStamp;
            var dt = t - prevScroll.t;
            var vx = dt ? ev.wheelX / dt : prevScroll.vx;
            var vy = dt ? ev.wheelY / dt : prevScroll.vy;
            if (dt < SCROLL_COOLDOWN_T) {
              vx = (vx + prevScroll.vx) / 2;
              vy = (vy + prevScroll.vy) / 2;
            }
            var direction = Math.abs(vx / vy);
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
              canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
              canScroll = true;
            if (canScroll) {
              prevScroll.allowed = t;
            } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
              var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
              if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
              } else {
                prevScroll.allowed = 0;
              }
            }
            prevScroll.t = t;
            prevScroll.vx = vx;
            prevScroll.vy = vy;
            if (canScroll) {
              editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
              return ev.stop();
            }
          };
          return DefaultHandlers2;
        }()
      );
      DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
      exports2.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
          var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
          var cmp = cursor.column - 4;
        else
          var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0)
          return { cursor: range.start, anchor: range.end };
        else
          return { cursor: range.end, anchor: range.start };
      }
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var Range = require2("./range").Range;
      var CLASSNAME = "ace_tooltip";
      var Tooltip = (
        /** @class */
        function() {
          function Tooltip2(parentNode) {
            this.isOpen = false;
            this.$element = null;
            this.$parentNode = parentNode;
          }
          Tooltip2.prototype.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = CLASSNAME;
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
          };
          Tooltip2.prototype.getElement = function() {
            return this.$element || this.$init();
          };
          Tooltip2.prototype.setText = function(text) {
            this.getElement().textContent = text;
          };
          Tooltip2.prototype.setHtml = function(html) {
            this.getElement().innerHTML = html;
          };
          Tooltip2.prototype.setPosition = function(x, y) {
            this.getElement().style.left = x + "px";
            this.getElement().style.top = y + "px";
          };
          Tooltip2.prototype.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
          };
          Tooltip2.prototype.setTheme = function(theme) {
            this.$element.className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
          };
          Tooltip2.prototype.show = function(text, x, y) {
            if (text != null)
              this.setText(text);
            if (x != null && y != null)
              this.setPosition(x, y);
            if (!this.isOpen) {
              this.getElement().style.display = "block";
              this.isOpen = true;
            }
          };
          Tooltip2.prototype.hide = function() {
            if (this.isOpen) {
              this.getElement().style.display = "none";
              this.getElement().className = CLASSNAME;
              this.isOpen = false;
            }
          };
          Tooltip2.prototype.getHeight = function() {
            return this.getElement().offsetHeight;
          };
          Tooltip2.prototype.getWidth = function() {
            return this.getElement().offsetWidth;
          };
          Tooltip2.prototype.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
              this.$element.parentNode.removeChild(this.$element);
            }
          };
          return Tooltip2;
        }()
      );
      var PopupManager = (
        /** @class */
        function() {
          function PopupManager2() {
            this.popups = [];
          }
          PopupManager2.prototype.addPopup = function(popup) {
            this.popups.push(popup);
            this.updatePopups();
          };
          PopupManager2.prototype.removePopup = function(popup) {
            var index = this.popups.indexOf(popup);
            if (index !== -1) {
              this.popups.splice(index, 1);
              this.updatePopups();
            }
          };
          PopupManager2.prototype.updatePopups = function() {
            var e_1, _a, e_2, _b;
            this.popups.sort(function(a, b) {
              return b.priority - a.priority;
            });
            var visiblepopups = [];
            try {
              for (var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()) {
                var popup = _d.value;
                var shouldDisplay = true;
                try {
                  for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {
                    var visiblePopup = visiblepopups_1_1.value;
                    if (this.doPopupsOverlap(visiblePopup, popup)) {
                      shouldDisplay = false;
                      break;
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return))
                      _b.call(visiblepopups_1);
                  } finally {
                    if (e_2)
                      throw e_2.error;
                  }
                }
                if (shouldDisplay) {
                  visiblepopups.push(popup);
                } else {
                  popup.hide();
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_d && !_d.done && (_a = _c.return))
                  _a.call(_c);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          };
          PopupManager2.prototype.doPopupsOverlap = function(popupA, popupB) {
            var rectA = popupA.getElement().getBoundingClientRect();
            var rectB = popupB.getElement().getBoundingClientRect();
            return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
          };
          return PopupManager2;
        }()
      );
      var popupManager = new PopupManager();
      exports2.popupManager = popupManager;
      exports2.Tooltip = Tooltip;
      var HoverTooltip = (
        /** @class */
        function(_super) {
          __extends(HoverTooltip2, _super);
          function HoverTooltip2(parentNode) {
            if (parentNode === void 0) {
              parentNode = document.body;
            }
            var _this = _super.call(this, parentNode) || this;
            _this.timeout = void 0;
            _this.lastT = 0;
            _this.idleTime = 350;
            _this.lastEvent = void 0;
            _this.onMouseOut = _this.onMouseOut.bind(_this);
            _this.onMouseMove = _this.onMouseMove.bind(_this);
            _this.waitForHover = _this.waitForHover.bind(_this);
            _this.hide = _this.hide.bind(_this);
            var el = _this.getElement();
            el.style.whiteSpace = "pre-wrap";
            el.style.pointerEvents = "auto";
            el.addEventListener("mouseout", _this.onMouseOut);
            el.tabIndex = -1;
            el.addEventListener("blur", (function() {
              if (!el.contains(document.activeElement))
                this.hide();
            }).bind(_this));
            el.addEventListener("wheel", event.stopPropagation);
            return _this;
          }
          HoverTooltip2.prototype.addToEditor = function(editor) {
            editor.on("mousemove", this.onMouseMove);
            editor.on("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
          };
          HoverTooltip2.prototype.removeFromEditor = function(editor) {
            editor.off("mousemove", this.onMouseMove);
            editor.off("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
          };
          HoverTooltip2.prototype.onMouseMove = function(e, editor) {
            this.lastEvent = e;
            this.lastT = Date.now();
            var isMousePressed = editor.$mouseHandler.isMousePressed;
            if (this.isOpen) {
              var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
              if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) {
                this.hide();
              }
            }
            if (this.timeout || isMousePressed)
              return;
            this.lastEvent = e;
            this.timeout = setTimeout(this.waitForHover, this.idleTime);
          };
          HoverTooltip2.prototype.waitForHover = function() {
            if (this.timeout)
              clearTimeout(this.timeout);
            var dt = Date.now() - this.lastT;
            if (this.idleTime - dt > 10) {
              this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
              return;
            }
            this.timeout = null;
            if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
              this.$gatherData(this.lastEvent, this.lastEvent.editor);
            }
          };
          HoverTooltip2.prototype.isOutsideOfText = function(e) {
            var editor = e.editor;
            var docPos = e.getDocumentPosition();
            var line = editor.session.getLine(docPos.row);
            if (docPos.column == line.length) {
              var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
              var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
              if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) {
                return true;
              }
            }
            return false;
          };
          HoverTooltip2.prototype.setDataProvider = function(value) {
            this.$gatherData = value;
          };
          HoverTooltip2.prototype.showForRange = function(editor, range, domNode, startingEvent) {
            var MARGIN = 10;
            if (startingEvent && startingEvent != this.lastEvent)
              return;
            if (this.isOpen && document.activeElement == this.getElement())
              return;
            var renderer = editor.renderer;
            if (!this.isOpen) {
              popupManager.addPopup(this);
              this.$registerCloseEvents();
              this.setTheme(renderer.theme);
            }
            this.isOpen = true;
            this.addMarker(range, editor.session);
            this.range = Range.fromPoints(range.start, range.end);
            var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
            var rect = renderer.scroller.getBoundingClientRect();
            if (position.pageX < rect.left)
              position.pageX = rect.left;
            var element = this.getElement();
            element.innerHTML = "";
            element.appendChild(domNode);
            element.style.maxHeight = "";
            element.style.display = "block";
            var labelHeight = element.clientHeight;
            var labelWidth = element.clientWidth;
            var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
            var isAbove = true;
            if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
              isAbove = false;
            }
            element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
            element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
            element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
            element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
          };
          HoverTooltip2.prototype.addMarker = function(range, session) {
            if (this.marker) {
              this.$markerSession.removeMarker(this.marker);
            }
            this.$markerSession = session;
            this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
          };
          HoverTooltip2.prototype.hide = function(e) {
            if (!e && document.activeElement == this.getElement())
              return;
            if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target))
              return;
            this.lastEvent = null;
            if (this.timeout)
              clearTimeout(this.timeout);
            this.timeout = null;
            this.addMarker(null);
            if (this.isOpen) {
              this.$removeCloseEvents();
              this.getElement().style.display = "none";
              this.isOpen = false;
              popupManager.removePopup(this);
            }
          };
          HoverTooltip2.prototype.$registerCloseEvents = function() {
            window.addEventListener("keydown", this.hide, true);
            window.addEventListener("wheel", this.hide, true);
            window.addEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.$removeCloseEvents = function() {
            window.removeEventListener("keydown", this.hide, true);
            window.removeEventListener("wheel", this.hide, true);
            window.removeEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.onMouseOut = function(e) {
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
            this.lastEvent = null;
            if (!this.isOpen)
              return;
            if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))
              return;
            if (e && e.currentTarget.contains(e.relatedTarget))
              return;
            if (!e.relatedTarget.classList.contains("ace_content"))
              this.hide();
          };
          return HoverTooltip2;
        }(Tooltip)
      );
      exports2.HoverTooltip = HoverTooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/tooltip", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var Tooltip = require2("../tooltip").Tooltip;
      var nls = require2("../config").nls;
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
          if (!editor.isFocused() || e.getButton() != 0)
            return;
          var gutterRegion = gutter.getRegion(e);
          if (gutterRegion == "foldWidgets")
            return;
          var row = e.getDocumentPosition().row;
          var selection = editor.session.selection;
          if (e.getShiftKey())
            selection.selectTo(row, 0);
          else {
            if (e.domEvent.detail == 2) {
              editor.selectAll();
              return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e);
          return e.preventDefault();
        });
        var tooltipTimeout, mouseEvent;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var maxRow = editor.session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
              return hideTooltip();
          }
          tooltip.showTooltip(row);
          if (!tooltip.isOpen)
            return;
          editor.on("mousewheel", hideTooltip);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterRow = mouseEvent.getGutterRow();
            var gutterCell = gutter.$lines.get(gutterRow);
            if (gutterCell) {
              var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
              var rect = gutterElement.getBoundingClientRect();
              var style = tooltip.getElement().style;
              style.left = rect.right + "px";
              style.top = rect.bottom + "px";
            } else {
              moveTooltip(mouseEvent);
            }
          }
        }
        function hideTooltip() {
          if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltip.isOpen) {
            tooltip.hideTooltip();
            editor.off("mousewheel", hideTooltip);
          }
        }
        function moveTooltip(e) {
          tooltip.setPosition(e.x, e.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
          var target = e.domEvent.target || e.domEvent.srcElement;
          if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();
          if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);
          mouseEvent = e;
          if (tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
            else
              hideTooltip();
          }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
          mouseEvent = null;
          if (!tooltip.isOpen || tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
          }, 50);
        }, editor);
        editor.on("changeSession", hideTooltip);
        editor.on("input", hideTooltip);
      }
      exports2.GutterHandler = GutterHandler;
      var GutterTooltip = (
        /** @class */
        function(_super) {
          __extends(GutterTooltip2, _super);
          function GutterTooltip2(editor) {
            var _this = _super.call(this, editor.container) || this;
            _this.editor = editor;
            return _this;
          }
          GutterTooltip2.prototype.setPosition = function(x, y) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x += 15;
            y += 15;
            if (x + width > windowWidth) {
              x -= x + width - windowWidth;
            }
            if (y + height > windowHeight) {
              y -= 20 + height;
            }
            Tooltip.prototype.setPosition.call(this, x, y);
          };
          Object.defineProperty(GutterTooltip2, "annotationLabels", {
            get: function() {
              return {
                error: { singular: nls("error"), plural: nls("errors") },
                warning: { singular: nls("warning"), plural: nls("warnings") },
                info: { singular: nls("information message"), plural: nls("information messages") }
              };
            },
            enumerable: false,
            configurable: true
          });
          GutterTooltip2.prototype.showTooltip = function(row) {
            var gutter = this.editor.renderer.$gutterLayer;
            var annotationsInRow = gutter.$annotations[row];
            var annotation;
            if (annotationsInRow)
              annotation = { text: Array.from(annotationsInRow.text), type: Array.from(annotationsInRow.type) };
            else
              annotation = { text: [], type: [] };
            var fold = gutter.session.getFoldLine(row);
            if (fold && gutter.$showFoldedAnnotations) {
              var annotationsInFold = { error: [], warning: [], info: [] };
              var mostSevereAnnotationInFoldType;
              for (var i = row + 1; i <= fold.end.row; i++) {
                if (!gutter.$annotations[i])
                  continue;
                for (var j = 0; j < gutter.$annotations[i].text.length; j++) {
                  var annotationType = gutter.$annotations[i].type[j];
                  annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);
                  if (annotationType === "error") {
                    mostSevereAnnotationInFoldType = "error_fold";
                    continue;
                  }
                  if (annotationType === "warning") {
                    mostSevereAnnotationInFoldType = "warning_fold";
                    continue;
                  }
                }
              }
              if (mostSevereAnnotationInFoldType === "error_fold" || mostSevereAnnotationInFoldType === "warning_fold") {
                var summaryFoldedAnnotations = "".concat(GutterTooltip2.annotationsToSummaryString(annotationsInFold), " in folded code.");
                annotation.text.push(summaryFoldedAnnotations);
                annotation.type.push(mostSevereAnnotationInFoldType);
              }
            }
            if (annotation.text.length === 0)
              return this.hide();
            var annotationMessages = { error: [], warning: [], info: [] };
            var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            for (var i = 0; i < annotation.text.length; i++) {
              var line = "<span class='ace_".concat(annotation.type[i], " ").concat(iconClassName, "' aria-label='").concat(GutterTooltip2.annotationLabels[annotation.type[i].replace("_fold", "")].singular, "' role=img> </span> ").concat(annotation.text[i]);
              annotationMessages[annotation.type[i].replace("_fold", "")].push(line);
            }
            var tooltipContent = [].concat(annotationMessages.error, annotationMessages.warning, annotationMessages.info).join("<br>");
            this.setHtml(tooltipContent);
            this.$element.setAttribute("aria-live", "polite");
            if (!this.isOpen) {
              this.setTheme(this.editor.renderer.theme);
              this.setClassName("ace_gutter-tooltip");
            }
            this.show();
            this.editor._signal("showGutterTooltip", this);
          };
          GutterTooltip2.prototype.hideTooltip = function() {
            this.$element.removeAttribute("aria-live");
            this.hide();
            this.editor._signal("hideGutterTooltip", this);
          };
          GutterTooltip2.annotationsToSummaryString = function(annotations) {
            var e_1, _a;
            var summary = [];
            var annotationTypes = ["error", "warning", "info"];
            try {
              for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {
                var annotationType = annotationTypes_1_1.value;
                if (!annotations[annotationType].length)
                  continue;
                var label = annotations[annotationType].length === 1 ? GutterTooltip2.annotationLabels[annotationType].singular : GutterTooltip2.annotationLabels[annotationType].plural;
                summary.push("".concat(annotations[annotationType].length, " ").concat(label));
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return))
                  _a.call(annotationTypes_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            return summary.join(", ");
          };
          return GutterTooltip2;
        }(Tooltip)
      );
      exports2.GutterTooltip = GutterTooltip;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var MouseEvent = (
        /** @class */
        function() {
          function MouseEvent2(domEvent, editor) {
            this.domEvent = domEvent;
            this.editor = editor;
            this.x = this.clientX = domEvent.clientX;
            this.y = this.clientY = domEvent.clientY;
            this.$pos = null;
            this.$inSelection = null;
            this.propagationStopped = false;
            this.defaultPrevented = false;
          }
          MouseEvent2.prototype.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
          };
          MouseEvent2.prototype.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
          };
          MouseEvent2.prototype.stop = function() {
            this.stopPropagation();
            this.preventDefault();
          };
          MouseEvent2.prototype.getDocumentPosition = function() {
            if (this.$pos)
              return this.$pos;
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
          };
          MouseEvent2.prototype.getGutterRow = function() {
            var documentRow = this.getDocumentPosition().row;
            var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
            var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
            return screenRow - screenTopRow;
          };
          MouseEvent2.prototype.inSelection = function() {
            if (this.$inSelection !== null)
              return this.$inSelection;
            var editor = this.editor;
            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
              this.$inSelection = false;
            else {
              var pos = this.getDocumentPosition();
              this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
            return this.$inSelection;
          };
          MouseEvent2.prototype.getButton = function() {
            return event.getButton(this.domEvent);
          };
          MouseEvent2.prototype.getShiftKey = function() {
            return this.domEvent.shiftKey;
          };
          MouseEvent2.prototype.getAccelKey = function() {
            return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
          };
          return MouseEvent2;
        }()
      );
      exports2.MouseEvent = MouseEvent;
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var dragImage = dom.createElement("div");
        dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
        dragImage.textContent = "";
        var exports3 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports3.forEach(function(x2) {
          mouseHandler[x2] = this[x2];
        }, this);
        editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker, x, y;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self2 = this;
            setTimeout(function() {
              self2.startSelect();
              self2.captureMouse(e);
            }, 0);
            return e.preventDefault();
          }
          range = editor.getSelectionRange();
          var dataTransfer = e.dataTransfer;
          dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
          editor.container.appendChild(dragImage);
          dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
          setTimeout(function() {
            editor.container.removeChild(dragImage);
          });
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function(e) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
              editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker)
            addDragMarker();
          counter++;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragOver = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragLeave = function(e) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
          }
        };
        this.onDrop = function(e) {
          if (!dragCursor)
            return;
          var dataTransfer = e.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData("Text");
            range = {
              start: dragCursor,
              end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = { x, y };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor.renderer.layerConfig.lineHeight;
          var characterWidth = editor.renderer.layerConfig.characterWidth;
          var editorRect = editor.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x - editorRect.left,
              right: editorRect.right - x
            },
            y: {
              top: y - editorRect.top,
              bottom: editorRect.bottom - y
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = { row: cursor.row, column: cursor.column };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || hScroll && !vMovement) {
            if (!autoScrollStartTime)
              autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
              editor.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor.renderer.screenToTextCoordinates(x, y);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor.selection.toOrientedRange();
          dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
          editor.clearSelection();
          if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor.selection.fromOrientedRange(range);
          if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
              if (onMouseMoveTimer != null && dragSelectionMarker)
                clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function(type) {
            return type == "text/plain" || type == "Text";
          });
        }
        function getDropEffect(e) {
          var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
          var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
          var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
          } catch (e2) {
          }
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
          else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          return dropEffect;
        }
      }
      (function() {
        this.dragWait = function() {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay())
            this.startDrag();
        };
        this.dragWaitEnd = function() {
          var target = this.editor.container;
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function(e) {
          this.editor.$resetCursorStyle();
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function() {
          this.cancelDrag = false;
          var editor = this.editor;
          var target = editor.container;
          target.draggable = true;
          editor.renderer.$cursorLayer.setBlinking(false);
          editor.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function(e) {
          var target = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
              target.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function(e) {
          if (!this.$dragEnabled)
            return;
          this.mousedownEvent = e;
          var editor = this.editor;
          var inSelection = e.inSelection();
          var button = e.getButton();
          var clickCount = e.domEvent.detail || 1;
          if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
              return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
              eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports2.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var MouseEvent = require2("./mouse_event").MouseEvent;
      var event = require2("../lib/event");
      var dom = require2("../lib/dom");
      exports2.addTouchListeners = function(el, editor) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        function createContextMenu() {
          var clipboard = window.navigator && window.navigator.clipboard;
          var isOpen = false;
          var updateMenu = function() {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(dom.buildDom(isOpen ? [
              "span",
              !selected && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
              selected && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
              selected && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
              clipboard && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
              hasUndo && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
              ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
              ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
            ] : ["span"]), contextMenu.firstChild);
          };
          var handleClick = function(e) {
            var action = e.target.getAttribute("action");
            if (action == "more" || !isOpen) {
              isOpen = !isOpen;
              return updateMenu();
            }
            if (action == "paste") {
              clipboard.readText().then(function(text) {
                editor.execCommand(action, text);
              });
            } else if (action) {
              if (action == "cut" || action == "copy") {
                if (clipboard)
                  clipboard.writeText(editor.getCopyText());
                else
                  document.execCommand("copy");
              }
              editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPalette")
              editor.focus();
          };
          contextMenu = dom.buildDom([
            "div",
            {
              class: "ace_mobile-menu",
              ontouchstart: function(e) {
                mode = "menu";
                e.stopPropagation();
                e.preventDefault();
                editor.textInput.focus();
              },
              ontouchend: function(e) {
                e.stopPropagation();
                e.preventDefault();
                handleClick(e);
              },
              onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
          ], editor.container);
        }
        function showContextMenu() {
          if (!contextMenu)
            createContextMenu();
          var cursor = editor.selection.cursor;
          var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
          var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
          var scrollLeft = editor.renderer.scrollLeft;
          var rect = editor.container.getBoundingClientRect();
          contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
          if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
          } else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
          }
          contextMenu.style.display = "";
          contextMenu.firstChild.style.display = "none";
          editor.on("input", hideContextMenu);
        }
        function hideContextMenu(e) {
          if (contextMenu)
            contextMenu.style.display = "none";
          editor.off("input", hideContextMenu);
        }
        function handleLongTap() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          var range = editor.selection.getRange();
          var inSelection = range.contains(pos.row, pos.column);
          if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
          }
          mode = "wait";
          showContextMenu();
        }
        function switchToSelectionMode() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          editor.selection.moveToPosition(pos);
          var range = clickCount >= 2 ? editor.selection.getLineRange(pos.row) : editor.session.getBracketRange(pos);
          if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
          } else {
            editor.selection.selectWord();
          }
          mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e) {
          if (!pressed)
            return;
          var textarea = editor.textInput.getElement();
          textarea.focus();
        }, editor);
        event.addListener(el, "touchstart", function(e) {
          var touches = e.touches;
          if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
          }
          pressed = editor.$mouseHandler.isMousePressed = true;
          var h = editor.renderer.layerConfig.lineHeight;
          var w = editor.renderer.layerConfig.lineHeight;
          var t = e.timeStamp;
          lastT = t;
          var touchObj = touches[0];
          var x = touchObj.clientX;
          var y = touchObj.clientY;
          if (Math.abs(startX - x) + Math.abs(startY - y) > h)
            touchStartT = -1;
          startX = e.clientX = x;
          startY = e.clientY = y;
          vX = vY = 0;
          var ev = new MouseEvent(e, editor);
          pos = ev.getDocumentPosition();
          if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e.preventDefault();
            e.button = 0;
            switchToSelectionMode();
          } else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function(x2, y2) {
              x2 = x2 / w;
              y2 = y2 / h - 0.75;
              return x2 * x2 + y2 * y2;
            };
            if (e.clientX < rect.left) {
              mode = "zoom";
              return;
            }
            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
            if (diff1 < 3.5 && diff2 < 3.5)
              mode = diff1 > diff2 ? "cursor" : "anchor";
            if (diff2 < 3.5)
              mode = "anchor";
            else if (diff1 < 3.5)
              mode = "cursor";
            else
              mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
          }
          touchStartT = t;
        }, editor);
        event.addListener(el, "touchend", function(e) {
          pressed = editor.$mouseHandler.isMousePressed = false;
          if (animationTimer)
            clearInterval(animationTimer);
          if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
          } else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
          } else if (mode == "scroll") {
            animate();
            hideContextMenu();
          } else {
            showContextMenu();
          }
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
        }, editor);
        event.addListener(el, "touchmove", function(e) {
          if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
          }
          var touches = e.touches;
          if (touches.length > 1 || mode == "zoom")
            return;
          var touchObj = touches[0];
          var wheelX = startX - touchObj.clientX;
          var wheelY = startY - touchObj.clientY;
          if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
              mode = "cursor";
            else
              return e.preventDefault();
          }
          startX = touchObj.clientX;
          startY = touchObj.clientY;
          e.clientX = touchObj.clientX;
          e.clientY = touchObj.clientY;
          var t = e.timeStamp;
          var dt = t - lastT;
          lastT = t;
          if (mode == "scroll") {
            var mouseEvent = new MouseEvent(e, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY))
              wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX))
              wheelY = 0;
            if (dt != 0) {
              vX = wheelX / dt;
              vY = wheelY / dt;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
              vX = vY = 0;
            }
          } else {
            var ev = new MouseEvent(e, editor);
            var pos2 = ev.getDocumentPosition();
            if (mode == "cursor")
              editor.selection.moveCursorToPosition(pos2);
            else if (mode == "anchor")
              editor.selection.setSelectionAnchor(pos2.row, pos2.column);
            editor.renderer.scrollCursorIntoView(pos2);
            e.preventDefault();
          }
        }, editor);
        function animate() {
          animationSteps += 60;
          animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
              clearInterval(animationTimer);
              animationTimer = null;
            }
            if (Math.abs(vX) < 0.01)
              vX = 0;
            if (Math.abs(vY) < 0.01)
              vY = 0;
            if (animationSteps < 20)
              vX = 0.9 * vX;
            if (animationSteps < 20)
              vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
              animationSteps = 0;
          }, 10);
        }
      };
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var DefaultHandlers = require2("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = require2("./default_gutter_handler").GutterHandler;
      var MouseEvent = require2("./mouse_event").MouseEvent;
      var DragdropHandler = require2("./dragdrop_handler").DragdropHandler;
      var addTouchListeners = require2("./touch_handler").addTouchListeners;
      var config = require2("../config");
      var MouseHandler = (
        /** @class */
        function() {
          function MouseHandler2(editor) {
            var _self = this;
            this.editor = editor;
            new DefaultHandlers(this);
            new DefaultGutterHandler(this);
            new DragdropHandler(this);
            var focusEditor = function(e) {
              var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
              if (windowBlurred)
                window.focus();
              editor.focus();
              setTimeout(function() {
                if (!editor.isFocused())
                  editor.focus();
              });
            };
            var mouseTarget = editor.renderer.getMouseEventTarget();
            event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
            event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
            event.addMultiMouseDownListener([
              mouseTarget,
              editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
              editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
              editor.textInput && editor.textInput.getElement()
            ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
            event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
            addTouchListeners(editor.container, editor);
            var gutterEl = editor.renderer.$gutter;
            event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
            event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
            event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
            event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
            event.addListener(mouseTarget, "mousedown", focusEditor, editor);
            event.addListener(gutterEl, "mousedown", focusEditor, editor);
            if (useragent.isIE && editor.renderer.scrollBarV) {
              event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
              event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
            }
            editor.on("mousemove", function(e) {
              if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                return;
              var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
              var range = editor.session.selection.getRange();
              var renderer = editor.renderer;
              if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                renderer.setCursorStyle("default");
              } else {
                renderer.setCursorStyle("");
              }
            }, editor);
          }
          MouseHandler2.prototype.onMouseEvent = function(name, e) {
            if (!this.editor.session)
              return;
            this.editor._emit(name, new MouseEvent(e, this.editor));
          };
          MouseHandler2.prototype.onMouseMove = function(name, e) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
              return;
            this.editor._emit(name, new MouseEvent(e, this.editor));
          };
          MouseHandler2.prototype.onMouseWheel = function(name, e) {
            var mouseEvent = new MouseEvent(e, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e.wheelX;
            mouseEvent.wheelY = e.wheelY;
            this.editor._emit(name, mouseEvent);
          };
          MouseHandler2.prototype.setState = function(state) {
            this.state = state;
          };
          MouseHandler2.prototype.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;
            this.isMousePressed = true;
            var editor = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;
            var self2 = this;
            var onMouseMove = function(e) {
              if (!e)
                return;
              if (useragent.isWebKit && !e.which && self2.releaseMouse)
                return self2.releaseMouse();
              self2.x = e.clientX;
              self2.y = e.clientY;
              mouseMoveHandler && mouseMoveHandler(e);
              self2.mouseEvent = new MouseEvent(e, self2.editor);
              self2.$mouseMoved = true;
            };
            var onCaptureEnd = function(e) {
              editor.off("beforeEndOperation", onOperationEnd);
              clearInterval(timerId);
              if (editor.session)
                onCaptureInterval();
              self2[self2.state + "End"] && self2[self2.state + "End"](e);
              self2.state = "";
              self2.isMousePressed = renderer.$isMousePressed = false;
              if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
              self2.$onCaptureMouseMove = self2.releaseMouse = null;
              e && self2.onMouseEvent("mouseup", e);
              editor.endOperation();
            };
            var onCaptureInterval = function() {
              self2[self2.state] && self2[self2.state]();
              self2.$mouseMoved = false;
            };
            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
              return setTimeout(function() {
                onCaptureEnd(ev);
              });
            }
            var onOperationEnd = function(e) {
              if (!self2.releaseMouse)
                return;
              if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self2[self2.state + "End"] && self2[self2.state + "End"]();
                self2.state = "";
                self2.releaseMouse();
              }
            };
            editor.on("beforeEndOperation", onOperationEnd);
            editor.startOperation({ command: { name: "mouse" } });
            self2.$onCaptureMouseMove = onMouseMove;
            self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            var timerId = setInterval(onCaptureInterval, 20);
          };
          MouseHandler2.prototype.cancelContextMenu = function() {
            var stop = (function(e) {
              if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
              this.editor.off("nativecontextmenu", stop);
              if (e && e.domEvent)
                event.stopEvent(e.domEvent);
            }).bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
          };
          MouseHandler2.prototype.destroy = function() {
            if (this.releaseMouse)
              this.releaseMouse();
          };
          return MouseHandler2;
        }()
      );
      MouseHandler.prototype.releaseMouse = null;
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: { initialValue: 2 },
        dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
        dragEnabled: { initialValue: true },
        focusTimeout: { initialValue: 0 },
        tooltipFollowsMouse: { initialValue: true }
      });
      exports2.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var FoldHandler = (
        /** @class */
        /* @__PURE__ */ function() {
          function FoldHandler2(editor) {
            editor.on("click", function(e) {
              var position = e.getDocumentPosition();
              var session = editor.session;
              var fold = session.getFoldAt(position.row, position.column, 1);
              if (fold) {
                if (e.getAccelKey())
                  session.removeFold(fold);
                else
                  session.expandFold(fold);
                e.stop();
              }
              var target = e.domEvent && e.domEvent.target;
              if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                  session.setOption("wrap", !session.getUseWrapMode());
                  editor.renderer.scrollCursorIntoView();
                }
              }
            });
            editor.on("gutterclick", function(e) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
              if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                  editor.session.onFoldWidgetClick(row, e);
                if (!editor.isFocused())
                  editor.focus();
                e.stop();
              }
            });
            editor.on("gutterdblclick", function(e) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
              if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;
                if (range) {
                  row = range.start.row;
                  var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                  if (fold) {
                    session.removeFold(fold);
                  } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                  }
                }
                e.stop();
              }
            });
          }
          return FoldHandler2;
        }()
      );
      exports2.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require2, exports2, module2) {
      "use strict";
      var keyUtil = require2("../lib/keys");
      var event = require2("../lib/event");
      var KeyBinding = (
        /** @class */
        function() {
          function KeyBinding2(editor) {
            this.$editor = editor;
            this.$data = { editor };
            this.$handlers = [];
            this.setDefaultHandler(editor.commands);
          }
          KeyBinding2.prototype.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
          };
          KeyBinding2.prototype.setKeyboardHandler = function(kb) {
            var h = this.$handlers;
            if (h[h.length - 1] == kb)
              return;
            while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
              this.removeKeyboardHandler(h[h.length - 1]);
            this.addKeyboardHandler(kb, 1);
          };
          KeyBinding2.prototype.addKeyboardHandler = function(kb, pos) {
            if (!kb)
              return;
            if (typeof kb == "function" && !kb.handleKeyboard)
              kb.handleKeyboard = kb;
            var i = this.$handlers.indexOf(kb);
            if (i != -1)
              this.$handlers.splice(i, 1);
            if (pos == void 0)
              this.$handlers.push(kb);
            else
              this.$handlers.splice(pos, 0, kb);
            if (i == -1 && kb.attach)
              kb.attach(this.$editor);
          };
          KeyBinding2.prototype.removeKeyboardHandler = function(kb) {
            var i = this.$handlers.indexOf(kb);
            if (i == -1)
              return false;
            this.$handlers.splice(i, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
          };
          KeyBinding2.prototype.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
          };
          KeyBinding2.prototype.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h) {
              return h.getStatusText && h.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
          };
          KeyBinding2.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;
            for (var i = this.$handlers.length; i--; ) {
              toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
              if (!toExecute || !toExecute.command)
                continue;
              if (toExecute.command == "null") {
                success = true;
              } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
              }
              if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                event.stopEvent(e);
              }
              if (success)
                break;
            }
            if (!success && hashId == -1) {
              toExecute = { command: "insertstring" };
              success = commands.exec("insertstring", this.$editor, keyString);
            }
            if (success && this.$editor._signal)
              this.$editor._signal("keyboardActivity", toExecute);
            return success;
          };
          KeyBinding2.prototype.onCommandKey = function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
          };
          KeyBinding2.prototype.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
          };
          return KeyBinding2;
        }()
      );
      exports2.KeyBinding = KeyBinding;
    });
    ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var ArabicAlefBetIntervalsBegine = ["", ""];
      var ArabicAlefBetIntervalsEnd = ["", ""];
      var dir = 0, hiLevel = 0;
      var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
      var impTab_LTR = [
        [0, 3, 0, 1, 0, 0, 0],
        [0, 3, 0, 1, 2, 2, 0],
        [0, 3, 0, 17, 2, 0, 1],
        [0, 3, 5, 5, 4, 1, 0],
        [0, 3, 21, 21, 4, 0, 1],
        [0, 3, 5, 5, 4, 2, 0]
      ];
      var impTab_RTL = [
        [2, 0, 1, 1, 0, 1, 0],
        [2, 0, 1, 1, 0, 2, 0],
        [2, 0, 2, 1, 3, 2, 0],
        [2, 0, 2, 33, 3, 1, 1]
      ];
      var LTR = 0, RTL = 1;
      var L = 0;
      var R = 1;
      var EN = 2;
      var AN = 3;
      var ON = 4;
      var B = 5;
      var S = 6;
      var AL = 7;
      var WS = 8;
      var CS = 9;
      var ES = 10;
      var ET = 11;
      var NSM = 12;
      var LRE = 13;
      var RLE = 14;
      var PDF = 15;
      var LRO = 16;
      var RLO = 17;
      var BN = 18;
      var UnicodeTBL00 = [
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        S,
        B,
        S,
        WS,
        B,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B,
        B,
        B,
        S,
        WS,
        ON,
        ON,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ES,
        CS,
        ES,
        CS,
        CS,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        ON,
        ON,
        ON,
        ON,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        CS,
        ON,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        L,
        ON,
        ON,
        BN,
        ON,
        ON,
        ET,
        ET,
        EN,
        EN,
        ON,
        L,
        ON,
        ON,
        ON,
        EN,
        L,
        ON,
        ON,
        ON,
        ON,
        ON
      ];
      var UnicodeTBL20 = [
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        BN,
        BN,
        BN,
        L,
        R,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS,
        B,
        LRE,
        RLE,
        PDF,
        LRO,
        RLO,
        CS,
        ET,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS
      ];
      function _computeLevels(chars, levels, len, charTypes) {
        var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
        if (!charTypes) {
          for (i = 0, charTypes = []; i < len; i++) {
            charTypes[i] = _getCharacterType(chars[i]);
          }
        }
        hiLevel = dir;
        lastArabic = false;
        hasUBAT_AL = false;
        hasUBAT_B = false;
        hasUBAT_S = false;
        for (ix = 0; ix < len; ix++) {
          prevState = newState;
          classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
          newState = impTab[prevState][newClass];
          action = newState & 240;
          newState &= 15;
          levels[ix] = newLevel = impTab[newState][5];
          if (action > 0) {
            if (action == 16) {
              for (i = condPos; i < ix; i++) {
                levels[i] = 1;
              }
              condPos = -1;
            } else {
              condPos = -1;
            }
          }
          cond = impTab[newState][6];
          if (cond) {
            if (condPos == -1) {
              condPos = ix;
            }
          } else {
            if (condPos > -1) {
              for (i = condPos; i < ix; i++) {
                levels[i] = newLevel;
              }
              condPos = -1;
            }
          }
          if (charTypes[ix] == B) {
            levels[ix] = 0;
          }
          hiLevel |= newLevel;
        }
        if (hasUBAT_S) {
          for (i = 0; i < len; i++) {
            if (charTypes[i] == S) {
              levels[i] = dir;
              for (var j = i - 1; j >= 0; j--) {
                if (charTypes[j] == WS) {
                  levels[j] = dir;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
      function _invertLevel(lev, levels, _array) {
        if (hiLevel < lev) {
          return;
        }
        if (lev == 1 && dir == RTL && !hasUBAT_B) {
          _array.reverse();
          return;
        }
        var len = _array.length, start = 0, end, lo, hi, tmp;
        while (start < len) {
          if (levels[start] >= lev) {
            end = start + 1;
            while (end < len && levels[end] >= lev) {
              end++;
            }
            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
              tmp = _array[lo];
              _array[lo] = _array[hi];
              _array[hi] = tmp;
            }
            start = end;
          }
          start++;
        }
      }
      function _getCharClass(chars, types, classes, ix) {
        var cType = types[ix], wType, nType, len, i;
        switch (cType) {
          case L:
          case R:
            lastArabic = false;
          case ON:
          case AN:
            return cType;
          case EN:
            return lastArabic ? AN : EN;
          case AL:
            lastArabic = true;
            hasUBAT_AL = true;
            return R;
          case WS:
            return ON;
          case CS:
            if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
              return ON;
            }
            if (lastArabic) {
              nType = AN;
            }
            return nType == wType ? nType : ON;
          case ES:
            wType = ix > 0 ? classes[ix - 1] : B;
            if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
              return EN;
            }
            return ON;
          case ET:
            if (ix > 0 && classes[ix - 1] == EN) {
              return EN;
            }
            if (lastArabic) {
              return ON;
            }
            i = ix + 1;
            len = types.length;
            while (i < len && types[i] == ET) {
              i++;
            }
            if (i < len && types[i] == EN) {
              return EN;
            }
            return ON;
          case NSM:
            len = types.length;
            i = ix + 1;
            while (i < len && types[i] == NSM) {
              i++;
            }
            if (i < len) {
              var c = chars[ix], rtlCandidate = c >= 1425 && c <= 2303 || c == 64286;
              wType = types[i];
              if (rtlCandidate && (wType == R || wType == AL)) {
                return R;
              }
            }
            if (ix < 1 || (wType = types[ix - 1]) == B) {
              return ON;
            }
            return classes[ix - 1];
          case B:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
          case S:
            hasUBAT_S = true;
            return ON;
          case LRE:
          case RLE:
          case LRO:
          case RLO:
          case PDF:
            lastArabic = false;
          case BN:
            return ON;
        }
      }
      function _getCharacterType(ch) {
        var uc = ch.charCodeAt(0), hi = uc >> 8;
        if (hi == 0) {
          return uc > 191 ? L : UnicodeTBL00[uc];
        } else if (hi == 5) {
          return /[\u0591-\u05f4]/.test(ch) ? R : L;
        } else if (hi == 6) {
          if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
            return NSM;
          else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
            return AN;
          else if (uc == 1642)
            return ET;
          else if (/[\u06f0-\u06f9]/.test(ch))
            return EN;
          else
            return AL;
        } else if (hi == 32 && uc <= 8287) {
          return UnicodeTBL20[uc & 255];
        } else if (hi == 254) {
          return uc >= 65136 ? AL : ON;
        }
        return ON;
      }
      function _isArabicDiacritics(ch) {
        return ch >= "" && ch <= "";
      }
      exports2.L = L;
      exports2.R = R;
      exports2.EN = EN;
      exports2.ON_R = 3;
      exports2.AN = 4;
      exports2.R_H = 5;
      exports2.B = 6;
      exports2.RLE = 7;
      exports2.DOT = "";
      exports2.doBidiReorder = function(text, textCharTypes, isRtl) {
        if (text.length < 2)
          return {};
        var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
        dir = isRtl ? RTL : LTR;
        _computeLevels(chars, levels, chars.length, textCharTypes);
        for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
          ;
        _invertLevel(2, levels, logicalFromVisual);
        _invertLevel(1, levels, logicalFromVisual);
        for (var i = 0; i < logicalFromVisual.length - 1; i++) {
          if (textCharTypes[i] === AN) {
            levels[i] = exports2.AN;
          } else if (levels[i] === R && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
            levels[i] = exports2.ON_R;
          } else if (i > 0 && chars[i - 1] === "" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
            levels[i - 1] = levels[i] = exports2.R_H;
            i++;
          }
        }
        if (chars[chars.length - 1] === exports2.DOT)
          levels[chars.length - 1] = exports2.B;
        if (chars[0] === "")
          levels[0] = exports2.RLE;
        for (var i = 0; i < logicalFromVisual.length; i++) {
          bidiLevels[i] = levels[logicalFromVisual[i]];
        }
        return { "logicalFromVisual": logicalFromVisual, "bidiLevels": bidiLevels };
      };
      exports2.hasBidiCharacters = function(text, textCharTypes) {
        var ret = false;
        for (var i = 0; i < text.length; i++) {
          textCharTypes[i] = _getCharacterType(text.charAt(i));
          if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
            ret = true;
        }
        return ret;
      };
      exports2.getVisualFromLogicalIdx = function(logIdx, rowMap) {
        for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
          if (rowMap.logicalFromVisual[i] == logIdx)
            return i;
        }
        return 0;
      };
    });
    ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(require2, exports2, module2) {
      "use strict";
      var bidiUtil = require2("./lib/bidiutil");
      var lang = require2("./lib/lang");
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
      var BidiHandler = (
        /** @class */
        function() {
          function BidiHandler2(session) {
            this.session = session;
            this.bidiMap = {};
            this.currentRow = null;
            this.bidiUtil = bidiUtil;
            this.charWidths = [];
            this.EOL = "";
            this.showInvisibles = true;
            this.isRtlDir = false;
            this.$isRtl = false;
            this.line = "";
            this.wrapIndent = 0;
            this.EOF = "";
            this.RLE = "";
            this.contentWidth = 0;
            this.fontMetrics = null;
            this.rtlLineOffset = 0;
            this.wrapOffset = 0;
            this.isMoveLeftOperation = false;
            this.seenBidi = bidiRE.test(session.getValue());
          }
          BidiHandler2.prototype.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
              return false;
            if (screenRow !== this.currentRow) {
              this.currentRow = screenRow;
              this.updateRowLine(docRow, splitIndex);
              this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
          };
          BidiHandler2.prototype.onChange = function(delta) {
            if (!this.seenBidi) {
              if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
              }
            } else {
              this.currentRow = null;
            }
          };
          BidiHandler2.prototype.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              if (index >= 0)
                docRow = this.session.$docRowCache[index];
            }
            return docRow;
          };
          BidiHandler2.prototype.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                  break;
                prevIndex = currentIndex;
                splitIndex++;
              }
            } else {
              splitIndex = this.currentRow;
            }
            return splitIndex;
          };
          BidiHandler2.prototype.updateRowLine = function(docRow, splitIndex) {
            if (docRow === void 0)
              docRow = this.getDocumentRow();
            var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
              var splits = this.session.$wrapData[docRow];
              if (splits) {
                if (splitIndex === void 0)
                  splitIndex = this.getSplitIndex();
                if (splitIndex > 0 && splits.length) {
                  this.wrapIndent = splits.indent;
                  this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                  this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
                } else {
                  this.line = this.line.substring(0, splits[splitIndex]);
                }
                if (splitIndex == splits.length) {
                  this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                }
              }
            } else {
              this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i) {
              if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                size = ch === "	" ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
              }
              return ch;
            });
            if (this.isRtlDir) {
              this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
              this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
          };
          BidiHandler2.prototype.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
              this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            } else {
              this.bidiMap = {};
            }
          };
          BidiHandler2.prototype.markAsDirty = function() {
            this.currentRow = null;
          };
          BidiHandler2.prototype.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width)
              return;
            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("");
            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setEolChar = function(eolChar) {
            this.EOL = eolChar;
          };
          BidiHandler2.prototype.setContentWidth = function(width) {
            this.contentWidth = width;
          };
          BidiHandler2.prototype.isRtlLine = function(row) {
            if (this.$isRtl)
              return true;
            if (row != void 0)
              return this.session.getLine(row).charAt(0) == this.RLE;
            else
              return this.isRtlDir;
          };
          BidiHandler2.prototype.setRtlDirection = function(editor, isRtlDir) {
            var cursor = editor.getCursorPosition();
            for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
              if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
              else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({ column: 0, row }, editor.session.$bidiHandler.RLE);
            }
          };
          BidiHandler2.prototype.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
            var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
              visualIdx++;
            for (var i = 0; i < visualIdx; i++) {
              left += this.charWidths[levels[i]];
            }
            if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0)
              left += this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            if (this.isRtlDir)
              left += this.rtlLineOffset;
            return left;
          };
          BidiHandler2.prototype.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
            if (this.wrapIndent)
              offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
              logIdx = map.logicalFromVisual[visIdx];
              level = levels[visIdx];
              isSelected = logIdx >= selColMin && logIdx < selColMax;
              if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
              } else if (!isSelected && isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
              }
              offset += this.charWidths[level];
              isSelectedPrev = isSelected;
            }
            if (isSelected && visIdx === levels.length) {
              selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            if (this.isRtlDir) {
              for (var i = 0; i < selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
              }
            }
            return selections;
          };
          BidiHandler2.prototype.offsetToCol = function(posX) {
            if (this.isRtlDir)
              posX -= this.rtlLineOffset;
            var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            while (posX > offset + charWidth / 2) {
              offset += charWidth;
              if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
              }
              charWidth = this.charWidths[levels[++visualIdx]];
            }
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
              if (posX < offset)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
            } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
              if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }
            if (logicalIdx === 0 && this.isRtlDir)
              logicalIdx++;
            return logicalIdx + this.wrapIndent;
          };
          return BidiHandler2;
        }()
      );
      exports2.BidiHandler = BidiHandler;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range = require2("./range").Range;
      var Selection = (
        /** @class */
        function() {
          function Selection2(session) {
            this.session = session;
            this.doc = session.getDocument();
            this.clearSelection();
            this.cursor = this.lead = this.doc.createAnchor(0, 0);
            this.anchor = this.doc.createAnchor(0, 0);
            this.$silent = false;
            var self2 = this;
            this.cursor.on("change", function(e) {
              self2.$cursorChanged = true;
              if (!self2.$silent)
                self2._emit("changeCursor");
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
              if (!self2.$keepDesiredColumnOnChange && e.old.column != e.value.column)
                self2.$desiredColumn = null;
            });
            this.anchor.on("change", function() {
              self2.$anchorChanged = true;
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
            });
          }
          Selection2.prototype.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
          };
          Selection2.prototype.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
          };
          Selection2.prototype.getCursor = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.setAnchor = function(row, column) {
            this.$isEmpty = false;
            this.anchor.setPosition(row, column);
          };
          Selection2.prototype.getAnchor = function() {
            if (this.$isEmpty)
              return this.getSelectionLead();
            return this.anchor.getPosition();
          };
          Selection2.prototype.getSelectionLead = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
          };
          Selection2.prototype.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            if (this.$isEmpty)
              return Range.fromPoints(lead, lead);
            return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
          };
          Selection2.prototype.clearSelection = function() {
            if (!this.$isEmpty) {
              this.$isEmpty = true;
              this._emit("changeSelection");
            }
          };
          Selection2.prototype.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
          };
          Selection2.prototype.setRange = function(range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
          };
          Selection2.prototype.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
            if (this.$silent)
              return;
            var wasEmpty = this.$isEmpty;
            var wasMultiselect = this.inMultiSelectMode;
            this.$silent = true;
            this.$cursorChanged = this.$anchorChanged = false;
            this.anchor.setPosition(anchorRow, anchorColumn);
            this.cursor.setPosition(cursorRow, cursorColumn);
            this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
            this.$silent = false;
            if (this.$cursorChanged)
              this._emit("changeCursor");
            if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
              this._emit("changeSelection");
          };
          Selection2.prototype.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty)
              this.setSelectionAnchor(lead.row, lead.column);
            mover.call(this);
          };
          Selection2.prototype.selectTo = function(row, column) {
            this.$moveSelection(function() {
              this.moveCursorTo(row, column);
            });
          };
          Selection2.prototype.selectToPosition = function(pos) {
            this.$moveSelection(function() {
              this.moveCursorToPosition(pos);
            });
          };
          Selection2.prototype.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
          };
          Selection2.prototype.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
          };
          Selection2.prototype.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
          };
          Selection2.prototype.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
          };
          Selection2.prototype.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
          };
          Selection2.prototype.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
          };
          Selection2.prototype.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
          };
          Selection2.prototype.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
          };
          Selection2.prototype.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
          };
          Selection2.prototype.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
          };
          Selection2.prototype.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
          };
          Selection2.prototype.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
              var cursor = row || this.lead;
              row = cursor.row;
              column = cursor.column;
            }
            return this.session.getWordRange(row, column);
          };
          Selection2.prototype.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
          };
          Selection2.prototype.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
          };
          Selection2.prototype.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;
            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
              rowStart = foldLine.start.row;
              rowEnd = foldLine.end.row;
            } else {
              rowEnd = rowStart;
            }
            if (excludeLastChar === true)
              return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else
              return new Range(rowStart, 0, rowEnd + 1, 0);
          };
          Selection2.prototype.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
          };
          Selection2.prototype.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
          };
          Selection2.prototype.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
          };
          Selection2.prototype.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;
            if (direction < 0) {
              start = cursor.column - tabSize;
              end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
          };
          Selection2.prototype.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
            } else if (cursor.column === 0) {
              if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
              }
            } else {
              var tabSize = this.session.getTabSize();
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
              } else {
                this.moveCursorBy(0, -1);
              }
            }
          };
          Selection2.prototype.moveCursorRight = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
              this.moveCursorTo(fold.end.row, fold.end.column);
            } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
              if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
              }
            } else {
              var tabSize = this.session.getTabSize();
              var cursor = this.lead;
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
              } else {
                this.moveCursorBy(0, 1);
              }
            }
          };
          Selection2.prototype.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
              firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
          };
          Selection2.prototype.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
              var line = this.session.getLine(lineEnd.row);
              if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                  lineEnd.column = textEnd;
              }
            }
            this.moveCursorTo(lineEnd.row, lineEnd.column);
          };
          Selection2.prototype.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
          };
          Selection2.prototype.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              this.moveCursorTo(fold.end.row, fold.end.column);
              return;
            }
            if (this.session.nonTokenRe.exec(rightOfCursor)) {
              column += this.session.nonTokenRe.lastIndex;
              this.session.nonTokenRe.lastIndex = 0;
              rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
              this.moveCursorTo(row, line.length);
              this.moveCursorRight();
              if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
              return;
            }
            if (this.session.tokenRe.exec(rightOfCursor)) {
              column += this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
              return;
            }
            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) {
              str = this.doc.getLine(row).substring(0, column);
            }
            var leftOfCursor = lang.stringReverse(str);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (this.session.nonTokenRe.exec(leftOfCursor)) {
              column -= this.session.nonTokenRe.lastIndex;
              leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
              this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
              this.moveCursorTo(row, 0);
              this.moveCursorLeft();
              if (row > 0)
                this.moveCursorWordLeft();
              return;
            }
            if (this.session.tokenRe.exec(leftOfCursor)) {
              column -= this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.$shortWordEndIndex = function(rightOfCursor) {
            var index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;
            tokenRe.lastIndex = 0;
            if (this.session.tokenRe.exec(rightOfCursor)) {
              index = this.session.tokenRe.lastIndex;
            } else {
              while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index++;
              if (index < 1) {
                tokenRe.lastIndex = 0;
                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                  tokenRe.lastIndex = 0;
                  index++;
                  if (whitespaceRe.test(ch)) {
                    if (index > 2) {
                      index--;
                      break;
                    } else {
                      while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                        index++;
                      if (index > 2)
                        break;
                    }
                  }
                }
              }
            }
            tokenRe.lastIndex = 0;
            return index;
          };
          Selection2.prototype.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold)
              return this.moveCursorTo(fold.end.row, fold.end.column);
            if (column == line.length) {
              var l = this.doc.getLength();
              do {
                row++;
                rightOfCursor = this.doc.getLine(row);
              } while (row < l && /^\s*$/.test(rightOfCursor));
              if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
              column = 0;
            }
            var index = this.$shortWordEndIndex(rightOfCursor);
            this.moveCursorTo(row, column + index);
          };
          Selection2.prototype.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1))
              return this.moveCursorTo(fold.start.row, fold.start.column);
            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
              do {
                row--;
                line = this.doc.getLine(row);
              } while (row > 0 && /^\s*$/.test(line));
              column = line.length;
              if (!/\s+$/.test(line))
                line = "";
            }
            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);
            return this.moveCursorTo(row, column - index);
          };
          Selection2.prototype.moveCursorWordRight = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordRight();
            else
              this.moveCursorShortWordRight();
          };
          Selection2.prototype.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordLeft();
            else
              this.moveCursorShortWordLeft();
          };
          Selection2.prototype.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
            var offsetX;
            if (chars === 0) {
              if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                  offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                  screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                  offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
              }
              if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
              else
                this.$desiredColumn = screenPos.column;
            }
            if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
              var widget = this.session.lineWidgets[this.lead.row];
              if (rows < 0)
                rows -= widget.rowsAbove || 0;
              else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
            }
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            }
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
          };
          Selection2.prototype.moveCursorToPosition = function(position) {
            this.moveCursorTo(position.row, position.column);
          };
          Selection2.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              row = fold.start.row;
              column = fold.start.column;
            }
            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
              if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
              else
                column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;
            if (!keepDesiredColumn)
              this.$desiredColumn = null;
          };
          Selection2.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
          };
          Selection2.prototype.detach = function() {
            this.lead.detach();
            this.anchor.detach();
          };
          Selection2.prototype.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
          };
          Selection2.prototype.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
              range.start.column = r.start.column;
              range.start.row = r.start.row;
              range.end.column = r.end.column;
              range.end.row = r.end.row;
            } else {
              range = r;
            }
            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
          };
          Selection2.prototype.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
              func(this);
              var end = this.getCursor();
              return Range.fromPoints(start, end);
            } catch (e) {
              return Range.fromPoints(start, start);
            } finally {
              this.moveCursorToPosition(start);
            }
          };
          Selection2.prototype.toJSON = function() {
            if (this.rangeCount) {
              var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
              });
            } else {
              var data = this.getRange();
              data.isBackwards = this.isBackwards();
            }
            return data;
          };
          Selection2.prototype.fromJSON = function(data) {
            if (data.start == void 0) {
              if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                  var r = Range.fromPoints(data[i].start, data[i].end);
                  if (data[i].isBackwards)
                    r.cursor = r.start;
                  this.addRange(r, true);
                }
                return;
              } else {
                data = data[0];
              }
            }
            if (this.rangeList)
              this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
          };
          Selection2.prototype.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount)
              return false;
            if (!data.length || !this.ranges)
              return this.getRange().isEqual(data);
            for (var i = this.ranges.length; i--; ) {
              if (!this.ranges[i].isEqual(data[i]))
                return false;
            }
            return true;
          };
          return Selection2;
        }()
      );
      Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
      Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;
      Selection.prototype.setSelectionRange = Selection.prototype.setRange;
      oop.implement(Selection.prototype, EventEmitter);
      exports2.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module", "ace/lib/report_error"], function(require2, exports2, module2) {
      "use strict";
      var reportError = require2("./lib/report_error").reportError;
      var MAX_TOKEN_COUNT = 2e3;
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2(rules) {
            this.states = rules;
            this.regExps = {};
            this.matchMappings = {};
            for (var key in this.states) {
              var state = this.states[key];
              var ruleRegExps = [];
              var matchTotal = 0;
              var mapping = this.matchMappings[key] = { defaultToken: "text" };
              var flag = "g";
              var splitterRurles = [];
              for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.defaultToken)
                  mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive && flag.indexOf("i") === -1)
                  flag += "i";
                if (rule.unicode && flag.indexOf("u") === -1)
                  flag += "u";
                if (rule.regex == null)
                  continue;
                if (rule.regex instanceof RegExp)
                  rule.regex = rule.regex.toString().slice(1, -1);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                  if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                  } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                      rule,
                      groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                  } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                  }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                  if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                  else
                    rule.onMatch = rule.token;
                }
                if (matchcount > 1) {
                  if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                      return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                  } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                  }
                  if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule);
                }
                mapping[matchTotal] = i;
                matchTotal += matchcount;
                ruleRegExps.push(adjustedregex);
                if (!rule.onMatch)
                  rule.onMatch = null;
              }
              if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
              }
              splitterRurles.forEach(function(rule2) {
                rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
              }, this);
              this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
            }
          }
          Tokenizer2.prototype.$setMaxTokenCount = function(m) {
            MAX_TOKEN_COUNT = m | 0;
          };
          Tokenizer2.prototype.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
              return [{ type: types, value: str }];
            var tokens = [];
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i])
                tokens[tokens.length] = {
                  type: types[i],
                  value: values[i]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.$arrayTokens = function(str) {
            if (!str)
              return [];
            var values = this.splitRegex.exec(str);
            if (!values)
              return "text";
            var tokens = [];
            var types = this.tokenArray;
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i + 1])
                tokens[tokens.length] = {
                  type: types[i],
                  value: values[i + 1]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.removeCapturingGroups = function(src) {
            var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x, y) {
              return y ? "(?:" : x;
            });
            return r;
          };
          Tokenizer2.prototype.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
              var stack = 0;
              var inChClass = false;
              var lastCapture = {};
              src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                  inChClass = square != "]";
                } else if (square) {
                  inChClass = true;
                } else if (parenClose) {
                  if (stack == lastCapture.stack) {
                    lastCapture.end = index + 1;
                    lastCapture.stack = -1;
                  }
                  stack--;
                } else if (parenOpen) {
                  stack++;
                  if (parenOpen.length != 1) {
                    lastCapture.stack = stack;
                    lastCapture.start = index;
                  }
                }
                return m;
              });
              if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^")
              src = "^" + src;
            if (src.charAt(src.length - 1) != "$")
              src += "$";
            return new RegExp(src, (flag || "").replace("g", ""));
          };
          Tokenizer2.prototype.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
              var stack = startState.slice(0);
              startState = stack[0];
              if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
              }
            } else
              var stack = [];
            var currentState = startState || "start";
            var state = this.states[currentState];
            if (!state) {
              currentState = "start";
              state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re = this.regExps[currentState];
            re.lastIndex = 0;
            var match, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;
            var token = { type: null, value: "" };
            while (match = re.exec(line)) {
              var type = mapping.defaultToken;
              var rule = null;
              var value = match[0];
              var index = re.lastIndex;
              if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                  token.value += skipped;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = { type, value: skipped };
                }
              }
              for (var i = 0; i < match.length - 2; i++) {
                if (match[i + 1] === void 0)
                  continue;
                rule = state[mapping[i]];
                if (rule.onMatch)
                  type = rule.onMatch(value, currentState, stack, line);
                else
                  type = rule.token;
                if (rule.next) {
                  if (typeof rule.next == "string") {
                    currentState = rule.next;
                  } else {
                    currentState = rule.next(currentState, stack);
                  }
                  state = this.states[currentState];
                  if (!state) {
                    this.reportError("state doesn't exist", currentState);
                    currentState = "start";
                    state = this.states[currentState];
                  }
                  mapping = this.matchMappings[currentState];
                  lastIndex = index;
                  re = this.regExps[currentState];
                  re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                  lastIndex = index;
                break;
              }
              if (value) {
                if (typeof type === "string") {
                  if ((!rule || rule.merge !== false) && token.type === type) {
                    token.value += value;
                  } else {
                    if (token.type)
                      tokens.push(token);
                    token = { type, value };
                  }
                } else if (type) {
                  if (token.type)
                    tokens.push(token);
                  token = { type: null, value: "" };
                  for (var i = 0; i < type.length; i++)
                    tokens.push(type[i]);
                }
              }
              if (lastIndex == line.length)
                break;
              lastIndex = index;
              if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                  this.reportError("infinite loop with in ace tokenizer", {
                    startState,
                    line
                  });
                }
                while (lastIndex < line.length) {
                  if (token.type)
                    tokens.push(token);
                  token = {
                    value: line.substring(lastIndex, lastIndex += 500),
                    type: "overflow"
                  };
                }
                currentState = "start";
                stack = [];
                break;
              }
            }
            if (token.type)
              tokens.push(token);
            if (stack.length > 1) {
              if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
            }
            return {
              tokens,
              state: stack.length ? stack : currentState
            };
          };
          return Tokenizer2;
        }()
      );
      Tokenizer.prototype.reportError = reportError;
      exports2.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports2, module2) {
      "use strict";
      var deepCopy = require2("../lib/deep_copy").deepCopy;
      var TextHighlightRules = function() {
        this.$rules = {
          "start": [{
            token: "empty_line",
            regex: "^$"
          }, {
            defaultToken: "text"
          }]
        };
      };
      (function() {
        this.addRules = function(rules, prefix) {
          if (!prefix) {
            for (var key in rules)
              this.$rules[key] = rules[key];
            return;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next == "string") {
                  if (rule.next.indexOf(prefix) !== 0)
                    rule.next = prefix + rule.next;
                }
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                  rule.nextState = prefix + rule.nextState;
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function() {
          return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i = 0; i < states.length; i++)
              states[i] = prefix + states[i];
          } else {
            states = [];
            for (var key in embedRules)
              states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
              addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
          }
          if (!this.$embeds)
            this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
          return this.$embeds;
        };
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function() {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              var toInsert = null;
              if (Array.isArray(rule)) {
                toInsert = rule;
                rule = {};
              }
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next)
                  rule.next = [];
                rule.next.push({
                  defaultToken: rule.token
                }, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string")
                    stateName = stateName[0] || "";
                  if (rules[stateName])
                    stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push)
                      rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              var includeName = typeof rule == "string" ? rule : rule.include;
              if (includeName) {
                if (includeName === "$self")
                  includeName = "start";
                if (Array.isArray(includeName))
                  toInsert = includeName.map(function(x) {
                    return rules[x];
                  });
                else
                  toInsert = rules[includeName];
              }
              if (toInsert) {
                var args = [i, 1].concat(toInsert);
                if (rule.noEscape)
                  args = args.filter(function(x) {
                    return !x.next;
                  });
                state.splice.apply(state, args);
                i--;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
          var keywords = /* @__PURE__ */ Object.create(null);
          this.$keywordList = [];
          Object.keys(map).forEach(function(className) {
            var a = map[className];
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; ) {
              var word = list[i];
              this.$keywordList.push(word);
              if (ignoreCase)
                word = word.toLowerCase();
              keywords[word] = className;
            }
          }, this);
          map = null;
          return ignoreCase ? function(value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function(value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function() {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports2.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var Behaviour = function() {
        this.$behaviours = {};
      };
      (function() {
        this.add = function(name, action, callback) {
          switch (void 0) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function(name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function(mode, filter) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
          } else {
            var behaviours = mode.getBehaviours(filter);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter) {
          if (!filter) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
              if (this.$behaviours[filter[i]]) {
                ret[filter[i]] = this.$behaviours[filter[i]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports2.Behaviour = Behaviour;
    });
    ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range = require2("./range").Range;
      var TokenIterator = (
        /** @class */
        function() {
          function TokenIterator2(session, initialRow, initialColumn) {
            this.$session = session;
            this.$row = initialRow;
            this.$rowTokens = session.getTokens(initialRow);
            var token = session.getTokenAt(initialRow, initialColumn);
            this.$tokenIndex = token ? token.index : -1;
          }
          TokenIterator2.prototype.stepBackward = function() {
            this.$tokenIndex -= 1;
            while (this.$tokenIndex < 0) {
              this.$row -= 1;
              if (this.$row < 0) {
                this.$row = 0;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
              this.$row += 1;
              if (!rowCount)
                rowCount = this.$session.getLength();
              if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentTokenRow = function() {
            return this.$row;
          };
          TokenIterator2.prototype.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== void 0)
              return column;
            column = 0;
            while (tokenIndex > 0) {
              tokenIndex -= 1;
              column += rowTokens[tokenIndex].value.length;
            }
            return column;
          };
          TokenIterator2.prototype.getCurrentTokenPosition = function() {
            return { row: this.$row, column: this.getCurrentTokenColumn() };
          };
          TokenIterator2.prototype.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
          };
          return TokenIterator2;
        }()
      );
      exports2.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("../../lib/oop");
      var Behaviour = require2("../behaviour").Behaviour;
      var TokenIterator = require2("../../token_iterator").TokenIterator;
      var lang = require2("../../lib/lang");
      var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
      var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
      var context;
      var contextCache = {};
      var defaultQuotes = { '"': '"', "'": "'" };
      var initContext = function(editor) {
        var id = -1;
        if (editor.multiSelect) {
          id = editor.selection.index;
          if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = { rangeCount: editor.multiSelect.rangeCount };
        }
        if (contextCache[id])
          return context = contextCache[id];
        context = contextCache[id] = {
          autoInsertedBrackets: 0,
          autoInsertedRow: -1,
          autoInsertedLineEnd: "",
          maybeInsertedBrackets: 0,
          maybeInsertedRow: -1,
          maybeInsertedLineStart: "",
          maybeInsertedLineEnd: ""
        };
      };
      var getWrapped = function(selection, selected, opening, closing) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
          text: opening + selected + closing,
          selection: [
            0,
            selection.start.column + 1,
            rowDiff,
            selection.end.column + (rowDiff ? 0 : 1)
          ]
        };
      };
      var CstyleBehaviour = function(options) {
        options = options || {};
        this.add("braces", "insertion", function(state, action, editor, session, text) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (text == "{") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "{", "}");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {
                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                  text: "{}",
                  selection: [1, 1]
                };
              } else {
                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                return {
                  text: "{",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "}") {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "}") {
              var matching = session.$findOpeningBracket("}", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
              closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === "}") {
              var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, "}");
              if (!openBracePos)
                return null;
              var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
              var next_indent = this.$getIndent(line);
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
              return;
            }
            var indent = next_indent + session.getTabString();
            return {
              text: "\n" + indent + "\n" + next_indent + closing,
              selection: [1, indent.length, 1, indent.length]
            };
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
        });
        this.add("braces", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "{") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == "}") {
              range.end.column++;
              return range;
            } else {
              context.maybeInsertedBrackets--;
            }
          }
        });
        this.add("parens", "insertion", function(state, action, editor, session, text) {
          if (text == "(") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "(", ")");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, ")");
              return {
                text: "()",
                selection: [1, 1]
              };
            }
          } else if (text == ")") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ")") {
              var matching = session.$findOpeningBracket(")", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("parens", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "(") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ")") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("brackets", "insertion", function(state, action, editor, session, text) {
          if (text == "[") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "[", "]");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, "]");
              return {
                text: "[]",
                selection: [1, 1]
              };
            }
          } else if (text == "]") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "]") {
              var matching = session.$findOpeningBracket("]", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("brackets", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "[") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == "]") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
              return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var leftChar = line.substring(cursor.column - 1, cursor.column);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              var token = session.getTokenAt(cursor.row, cursor.column);
              var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
              if (leftChar == "\\" && token && /escape/.test(token.type))
                return null;
              var stringBefore = token && /string|escape/.test(token.type);
              var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
              var pair;
              if (rightChar == quote) {
                pair = stringBefore !== stringAfter;
                if (pair && /string\.end/.test(rightToken.type))
                  pair = false;
              } else {
                if (stringBefore && !stringAfter)
                  return null;
                if (stringBefore && stringAfter)
                  return null;
                var wordRe = session.$mode.tokenRe;
                wordRe.lastIndex = 0;
                var isWordBefore = wordRe.test(leftChar);
                wordRe.lastIndex = 0;
                var isWordAfter = wordRe.test(rightChar);
                var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
                if (!shouldPairQuotes && isWordBefore || isWordAfter)
                  return null;
                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                  return null;
                var charBefore = line[cursor.column - 2];
                if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
                  return null;
                pair = true;
              }
              return {
                text: pair ? quote + quote : "",
                selection: [1, 1]
              };
            }
          }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
        if (options.closeDocComment !== false) {
          this.add("doc comment end", "insertion", function(state, action, editor, session, text) {
            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor.selection.isEmpty()) {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var nextLine = session.doc.getLine(cursor.row + 1);
              var indent = this.$getIndent(line);
              if (/\s*\*/.test(nextLine)) {
                if (/^\s*\*/.test(line)) {
                  return {
                    text: text + indent + "* ",
                    selection: [1, 3 + indent.length, 1, 3 + indent.length]
                  };
                } else {
                  return {
                    text: text + indent + " * ",
                    selection: [1, 3 + indent.length, 1, 3 + indent.length]
                  };
                }
              }
              if (/\/\*\*/.test(line.substring(0, cursor.column))) {
                return {
                  text: text + indent + " * " + text + " " + indent + "*/",
                  selection: [1, 4 + indent.length, 1, 4 + indent.length]
                };
              }
            }
          });
        }
      };
      CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
          if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
          var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
          if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour.$matchTokenType = function(token, types) {
        return types.indexOf(token.type || token) > -1;
      };
      CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
          context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
      };
      CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isMaybeInsertedClosing(cursor, line))
          context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
      };
      CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour.popAutoInsertedClosing = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
      };
      CstyleBehaviour.clearMaybeInsertedClosing = function() {
        if (context) {
          context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = -1;
        }
      };
      oop.inherits(CstyleBehaviour, Behaviour);
      exports2.CstyleBehaviour = CstyleBehaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
      var code = 0;
      var str = [];
      for (var i = 0; i < wordChars.length; i += 2) {
        str.push(code += wordChars[i]);
        if (wordChars[i + 1])
          str.push(45, code += wordChars[i + 1]);
      }
      exports2.wordChars = String.fromCharCode.apply(null, str);
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var config = require2("../config");
      var Tokenizer = require2("../tokenizer").Tokenizer;
      var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
      var CstyleBehaviour = require2("./behaviour/cstyle").CstyleBehaviour;
      var unicode = require2("../unicode");
      var lang = require2("../lib/lang");
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range = require2("../range").Range;
      var Mode = function() {
        this.HighlightRules = TextHighlightRules;
      };
      (function() {
        this.$defaultBehaviour = new CstyleBehaviour();
        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
          var doc = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment)
              return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function(line, i) {
              if (testRemove(line, i))
                return;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
              }
            };
            var uncomment = function(line, i) {
              var m;
              if (m = line.match(regexpEnd))
                doc.removeInLine(i, line.length - m[0].length, line.length);
              if (m = line.match(regexpStart))
                doc.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function(line, row) {
              if (regexpStart.test(line))
                return true;
              var tokens = session.getTokens(row);
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i].type === "comment")
                  return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function(line, i) {
              var m = line.match(regexpStart);
              if (!m)
                return;
              var start = m[1].length, end = m[0].length;
              if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                end--;
              doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent))
                  doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
                else
                  doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
              }
            };
            var testRemove = function(line, i) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ")
                spaces++;
              if (spaces % tabSize != 0)
                return false;
              var spaces = 0;
              while (line.charAt(after++) == " ")
                spaces++;
              if (tabSize > 2)
                return spaces % tabSize != tabSize - 1;
              else
                return spaces % tabSize == 0;
            };
          }
          function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
              fun(doc.getLine(i), i);
          }
          var minEmptyLength = Infinity;
          iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent)
                minIndent = indent;
              if (shouldRemove && !testRemove(line, i))
                shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment)
            return;
          if (!comment.start && comment[0])
            comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          var sel = session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow, colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.start);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                startRange = new Range(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.end);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                endRange = new Range(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange)
              session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
          return false;
        };
        this.autoOutdent = function(state, doc, row) {
        };
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
          return null;
        };
        this.createModeDelegates = function(mapping) {
          this.$embeds = [];
          this.$modes = {};
          for (var i in mapping) {
            if (mapping[i]) {
              var Mode2 = mapping[i];
              var id = Mode2.prototype.$id;
              var mode = config.$modes[id];
              if (!mode)
                config.$modes[id] = mode = new Mode2();
              if (!config.$modes[i])
                config.$modes[i] = mode;
              this.$embeds.push(i);
              this.$modes[i] = mode;
            }
          }
          var delegations = [
            "toggleBlockComment",
            "toggleCommentLines",
            "getNextLineIndent",
            "checkOutdent",
            "autoOutdent",
            "transformAction",
            "getCompletions"
          ];
          for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            })(this);
          }
        };
        this.$delegator = function(method, args, defaultHandler) {
          var state = args[0] || "start";
          if (typeof state != "string") {
            if (Array.isArray(state[2])) {
              var language = state[2][state[2].length - 1];
              var mode = this.$modes[language];
              if (mode)
                return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
          }
          for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]])
              continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
              args[0] = split[1];
              var mode = this.$modes[this.$embeds[i]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : void 0;
        };
        this.transformAction = function(state, action, editor, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function(append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0, l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token))
                    completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append)
            return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
          if (!this.$highlightRules)
            this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function(word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports2.Mode = Mode;
    });
    ace.define("ace/apply_delta", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      function throwDeltaError(delta, errorText) {
        console.log("Invalid Delta:", delta);
        throw "Invalid Delta: " + errorText;
      }
      function positionInDocument(docLines, position) {
        return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
      }
      function validateDelta(docLines, delta) {
        if (delta.action != "insert" && delta.action != "remove")
          throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
        if (!(delta.lines instanceof Array))
          throwDeltaError(delta, "delta.lines must be an Array");
        if (!delta.start || !delta.end)
          throwDeltaError(delta, "delta.start/end must be an present");
        var start = delta.start;
        if (!positionInDocument(docLines, delta.start))
          throwDeltaError(delta, "delta.start must be contained in document");
        var end = delta.end;
        if (delta.action == "remove" && !positionInDocument(docLines, end))
          throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
        var numRangeRows = end.row - start.row;
        var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
        if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
          throwDeltaError(delta, "delta.range must match delta lines");
      }
      exports2.applyDelta = function(docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Anchor = (
        /** @class */
        function() {
          function Anchor2(doc, row, column) {
            this.$onChange = this.onChange.bind(this);
            this.attach(doc);
            if (typeof column == "undefined")
              this.setPosition(row.row, row.column);
            else
              this.setPosition(row, column);
          }
          Anchor2.prototype.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
          };
          Anchor2.prototype.getDocument = function() {
            return this.document;
          };
          Anchor2.prototype.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
              return;
            if (delta.start.row > this.row)
              return;
            var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(point.row, point.column, true);
          };
          Anchor2.prototype.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
              pos = {
                row,
                column
              };
            } else {
              pos = this.$clipPositionToDocument(row, column);
            }
            if (this.row == pos.row && this.column == pos.column)
              return;
            var old = {
              row: this.row,
              column: this.column
            };
            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
              old,
              value: pos
            });
          };
          Anchor2.prototype.detach = function() {
            this.document.off("change", this.$onChange);
          };
          Anchor2.prototype.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
          };
          Anchor2.prototype.$clipPositionToDocument = function(row, column) {
            var pos = {};
            if (row >= this.document.getLength()) {
              pos.row = Math.max(0, this.document.getLength() - 1);
              pos.column = this.document.getLine(pos.row).length;
            } else if (row < 0) {
              pos.row = 0;
              pos.column = 0;
            } else {
              pos.row = row;
              pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }
            if (column < 0)
              pos.column = 0;
            return pos;
          };
          return Anchor2;
        }()
      );
      Anchor.prototype.$insertRight = false;
      oop.implement(Anchor.prototype, EventEmitter);
      function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
      }
      function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
          return {
            row: point.row,
            column: point.column
          };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
          return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
          };
        }
        return {
          row: deltaStart.row,
          column: deltaStart.column
        };
      }
      exports2.Anchor = Anchor;
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var applyDelta = require2("./apply_delta").applyDelta;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range = require2("./range").Range;
      var Anchor = require2("./anchor").Anchor;
      var Document = (
        /** @class */
        function() {
          function Document2(textOrLines) {
            this.$lines = [""];
            if (textOrLines.length === 0) {
              this.$lines = [""];
            } else if (Array.isArray(textOrLines)) {
              this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
            } else {
              this.insert({ row: 0, column: 0 }, textOrLines);
            }
          }
          Document2.prototype.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({ row: 0, column: 0 }, text || "");
          };
          Document2.prototype.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
          };
          Document2.prototype.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
          };
          Document2.prototype.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match ? match[1] : "\n";
            this._signal("changeNewLineMode");
          };
          Document2.prototype.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
          };
          Document2.prototype.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
              return;
            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
          };
          Document2.prototype.getNewLineMode = function() {
            return this.$newLineMode;
          };
          Document2.prototype.isNewLine = function(text) {
            return text == "\r\n" || text == "\r" || text == "\n";
          };
          Document2.prototype.getLine = function(row) {
            return this.$lines[row] || "";
          };
          Document2.prototype.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
          };
          Document2.prototype.getAllLines = function() {
            return this.getLines(0, this.getLength());
          };
          Document2.prototype.getLength = function() {
            return this.$lines.length;
          };
          Document2.prototype.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
          };
          Document2.prototype.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
              lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
              lines = this.getLines(range.start.row, range.end.row);
              lines[0] = (lines[0] || "").substring(range.start.column);
              var l = lines.length - 1;
              if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
          };
          Document2.prototype.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
          };
          Document2.prototype.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
          };
          Document2.prototype.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, ["", ""]);
          };
          Document2.prototype.insert = function(position, text) {
            if (this.getLength() <= 1)
              this.$detectNewLine(text);
            return this.insertMergedLines(position, this.$split(text));
          };
          Document2.prototype.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines: [text]
            }, true);
            return this.clonePos(end);
          };
          Document2.prototype.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === void 0) {
              row = length;
            } else if (row < 0) {
              row = 0;
            } else if (row >= length) {
              row = length - 1;
              column = void 0;
            }
            var line = this.getLine(row);
            if (column == void 0)
              column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return { row, column };
          };
          Document2.prototype.clonePos = function(pos) {
            return { row: pos.row, column: pos.column };
          };
          Document2.prototype.pos = function(row, column) {
            return { row, column };
          };
          Document2.prototype.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
              position.row = Math.max(0, length - 1);
              position.column = this.getLine(length - 1).length;
            } else {
              position.row = Math.max(0, position.row);
              position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
          };
          Document2.prototype.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
              lines = lines.concat([""]);
              column = 0;
            } else {
              lines = [""].concat(lines);
              row--;
              column = this.$lines[row].length;
            }
            this.insertMergedLines({ row, column }, lines);
          };
          Document2.prototype.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
              row: start.row + lines.length - 1,
              column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines
            });
            return this.clonePos(end);
          };
          Document2.prototype.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            });
            return this.clonePos(start);
          };
          Document2.prototype.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            }, true);
            return this.clonePos(start);
          };
          Document2.prototype.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine = lastRow < this.getLength() - 1;
            var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
            var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
            var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
            var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            this.applyDelta({
              start: range.start,
              end: range.end,
              action: "remove",
              lines: this.getLinesForRange(range)
            });
            return deletedLines;
          };
          Document2.prototype.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
              this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
              });
            }
          };
          Document2.prototype.replace = function(range, text) {
            if (!(range instanceof Range))
              range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
              return range.start;
            if (text == this.getTextRange(range))
              return range.end;
            this.remove(range);
            var end;
            if (text) {
              end = this.insert(range.start, text);
            } else {
              end = range.start;
            }
            return end;
          };
          Document2.prototype.applyDeltas = function(deltas) {
            for (var i = 0; i < deltas.length; i++) {
              this.applyDelta(deltas[i]);
            }
          };
          Document2.prototype.revertDeltas = function(deltas) {
            for (var i = deltas.length - 1; i >= 0; i--) {
              this.revertDelta(deltas[i]);
            }
          };
          Document2.prototype.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
              return;
            }
            if (isInsert && delta.lines.length > 2e4) {
              this.$splitAndapplyLargeDelta(delta, 2e4);
            } else {
              applyDelta(this.$lines, delta, doNotValidate);
              this._signal("change", delta);
            }
          };
          Document2.prototype.$safeApplyDelta = function(delta) {
            var docLength = this.$lines.length;
            if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
              this.applyDelta(delta);
            }
          };
          Document2.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row;
            var column = delta.start.column;
            for (var from = 0, to = 0; from < l; from = to) {
              to += MAX - 1;
              var chunk = lines.slice(from, to);
              chunk.push("");
              this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
              }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
          };
          Document2.prototype.revertDelta = function(delta) {
            this.$safeApplyDelta({
              start: this.clonePos(delta.start),
              end: this.clonePos(delta.end),
              action: delta.action == "insert" ? "remove" : "insert",
              lines: delta.lines.slice()
            });
          };
          Document2.prototype.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i = startRow || 0, l = lines.length; i < l; i++) {
              index -= lines[i].length + newlineLength;
              if (index < 0)
                return { row: i, column: index + lines[i].length + newlineLength };
            }
            return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
          };
          Document2.prototype.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i = startRow || 0; i < row; ++i)
              index += lines[i].length + newlineLength;
            return index + pos.column;
          };
          Document2.prototype.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
          };
          return Document2;
        }()
      );
      Document.prototype.$autoNewLine = "";
      Document.prototype.$newLineMode = "auto";
      oop.implement(Document.prototype, EventEmitter);
      exports2.Document = Document;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = (
        /** @class */
        function() {
          function BackgroundTokenizer2(tokenizer, editor) {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.tokenizer = tokenizer;
            var self2 = this;
            this.$worker = function() {
              if (!self2.running) {
                return;
              }
              var workerStart = /* @__PURE__ */ new Date();
              var currentLine = self2.currentLine;
              var endLine = -1;
              var doc = self2.doc;
              var startLine = currentLine;
              while (self2.lines[currentLine])
                currentLine++;
              var len = doc.getLength();
              var processedLines = 0;
              self2.running = false;
              while (currentLine < len) {
                self2.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                  currentLine++;
                } while (self2.lines[currentLine]);
                processedLines++;
                if (processedLines % 5 === 0 && /* @__PURE__ */ new Date() - workerStart > 20) {
                  self2.running = setTimeout(self2.$worker, 20);
                  break;
                }
              }
              self2.currentLine = currentLine;
              if (endLine == -1)
                endLine = currentLine;
              if (startLine <= endLine)
                self2.fireUpdateEvent(startLine, endLine);
            };
          }
          BackgroundTokenizer2.prototype.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];
            this.start(0);
          };
          BackgroundTokenizer2.prototype.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];
            this.stop();
          };
          BackgroundTokenizer2.prototype.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
              first: firstRow,
              last: lastRow
            };
            this._signal("update", { data });
          };
          BackgroundTokenizer2.prototype.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);
            this.stop();
            this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.scheduleStart = function() {
            if (!this.running)
              this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
              this.lines[startRow] = null;
            } else if (delta.action == "remove") {
              this.lines.splice(startRow, len + 1, null);
              this.states.splice(startRow, len + 1, null);
            } else {
              var args = Array(len + 1);
              args.unshift(startRow, 1);
              this.lines.splice.apply(this.lines, args);
              this.states.splice.apply(this.states, args);
            }
            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
            this.stop();
          };
          BackgroundTokenizer2.prototype.stop = function() {
            if (this.running)
              clearTimeout(this.running);
            this.running = false;
          };
          BackgroundTokenizer2.prototype.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
          };
          BackgroundTokenizer2.prototype.getState = function(row) {
            if (this.currentLine == row)
              this.$tokenizeRow(row);
            return this.states[row] || "start";
          };
          BackgroundTokenizer2.prototype.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];
            var data = this.tokenizer.getLineTokens(line, state, row);
            if (this.states[row] + "" !== data.state + "") {
              this.states[row] = data.state;
              this.lines[row + 1] = null;
              if (this.currentLine > row + 1)
                this.currentLine = row + 1;
            } else if (this.currentLine == row) {
              this.currentLine = row + 1;
            }
            return this.lines[row] = data.tokens;
          };
          BackgroundTokenizer2.prototype.cleanup = function() {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.removeAllListeners();
          };
          return BackgroundTokenizer2;
        }()
      );
      oop.implement(BackgroundTokenizer.prototype, EventEmitter);
      exports2.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var lang = require2("./lib/lang");
      var Range = require2("./range").Range;
      var SearchHighlight = (
        /** @class */
        function() {
          function SearchHighlight2(regExp, clazz, type) {
            if (type === void 0) {
              type = "text";
            }
            this.setRegexp(regExp);
            this.clazz = clazz;
            this.type = type;
          }
          SearchHighlight2.prototype.setRegexp = function(regExp) {
            if (this.regExp + "" == regExp + "")
              return;
            this.regExp = regExp;
            this.cache = [];
          };
          SearchHighlight2.prototype.update = function(html, markerLayer, session, config) {
            if (!this.regExp)
              return;
            var start = config.firstRow, end = config.lastRow;
            var renderedMarkerRanges = {};
            for (var i = start; i <= end; i++) {
              var ranges = this.cache[i];
              if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                  ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                  return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
              }
              for (var j = ranges.length; j--; ) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString])
                  continue;
                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
              }
            }
          };
          return SearchHighlight2;
        }()
      );
      SearchHighlight.prototype.MAX_RANGES = 500;
      exports2.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var UndoManager = (
        /** @class */
        function() {
          function UndoManager2() {
            this.$maxRev = 0;
            this.$fromUndo = false;
            this.$undoDepth = Infinity;
            this.reset();
          }
          UndoManager2.prototype.addSession = function(session) {
            this.$session = session;
          };
          UndoManager2.prototype.add = function(delta, allowMerge, session) {
            if (this.$fromUndo)
              return;
            if (delta == this.$lastDelta)
              return;
            if (!this.$keepRedoStack)
              this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
              this.lastDeltas = [];
              var undoStackLength = this.$undoStack.length;
              if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
              }
              this.$undoStack.push(this.lastDeltas);
              delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert")
              this.$lastDelta = delta;
            this.lastDeltas.push(delta);
          };
          UndoManager2.prototype.addSelection = function(selection, rev) {
            this.selections.push({
              value: selection,
              rev: rev || this.$rev
            });
          };
          UndoManager2.prototype.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
          };
          UndoManager2.prototype.markIgnored = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            for (var i = stack.length; i--; ) {
              var delta = stack[i][0];
              if (delta.id <= from)
                break;
              if (delta.id < to)
                delta.ignore = true;
            }
            this.lastDeltas = null;
          };
          UndoManager2.prototype.getSelection = function(rev, after) {
            var stack = this.selections;
            for (var i = stack.length; i--; ) {
              var selection = stack[i];
              if (selection.rev < rev) {
                if (after)
                  selection = stack[i + 1];
                return selection;
              }
            }
          };
          UndoManager2.prototype.getRevision = function() {
            return this.$rev;
          };
          UndoManager2.prototype.getDeltas = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for (var i = stack.length; i--; ) {
              var delta = stack[i][0];
              if (delta.id < to && !end)
                end = i + 1;
              if (delta.id <= from) {
                start = i + 1;
                break;
              }
            }
            return stack.slice(start, end);
          };
          UndoManager2.prototype.getChangedRanges = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.getChangedLines = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            if (!rearrangeUndoStack(stack, stack.length))
              return;
            if (!session)
              session = this.$session;
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
              this.$redoStack = [];
            this.$fromUndo = true;
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (deltaSet) {
              undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
              this.$redoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return undoSelectionRange;
          };
          UndoManager2.prototype.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            if (!session)
              session = this.$session;
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
              var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
              rebaseRedoStack(this.$redoStack, diff);
              this.$redoStackBaseRev = this.$rev;
              this.$redoStack.forEach(function(x) {
                x[0].id = ++this.$maxRev;
              }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            if (deltaSet) {
              redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
              this.$undoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return redoSelectionRange;
          };
          UndoManager2.prototype.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
          };
          UndoManager2.prototype.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
          };
          UndoManager2.prototype.canUndo = function() {
            return this.$undoStack.length > 0;
          };
          UndoManager2.prototype.canRedo = function() {
            return this.$redoStack.length > 0;
          };
          UndoManager2.prototype.bookmark = function(rev) {
            if (rev == void 0)
              rev = this.$rev;
            this.mark = rev;
          };
          UndoManager2.prototype.isAtBookmark = function() {
            return this.$rev === this.mark;
          };
          UndoManager2.prototype.toJSON = function() {
            return {
              $redoStack: this.$redoStack,
              $undoStack: this.$undoStack
            };
          };
          UndoManager2.prototype.fromJSON = function(json) {
            this.reset();
            this.$undoStack = json.$undoStack;
            this.$redoStack = json.$redoStack;
          };
          UndoManager2.prototype.$prettyPrint = function(delta) {
            if (delta)
              return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
          };
          return UndoManager2;
        }()
      );
      UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
      UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
      UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
      UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
      function rearrangeUndoStack(stack, pos) {
        for (var i = pos; i--; ) {
          var deltaSet = stack[i];
          if (deltaSet && !deltaSet[0].ignore) {
            while (i < pos - 1) {
              var swapped = swapGroups(stack[i], stack[i + 1]);
              stack[i] = swapped[0];
              stack[i + 1] = swapped[1];
              i++;
            }
            return true;
          }
        }
      }
      var Range = require2("./range").Range;
      var cmp = Range.comparePoints;
      var comparePoints = Range.comparePoints;
      function $updateMarkers(delta) {
        var isInsert = delta.action == "insert";
        var start = delta.start;
        var end = delta.end;
        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
        if (isInsert)
          end = start;
        for (var i in this.marks) {
          var point = this.marks[i];
          var cmp2 = comparePoints(point, start);
          if (cmp2 < 0) {
            continue;
          }
          if (cmp2 === 0) {
            if (isInsert) {
              if (point.bias == 1) {
                cmp2 = 1;
              } else {
                point.bias == -1;
                continue;
              }
            }
          }
          var cmp22 = isInsert ? cmp2 : comparePoints(point, end);
          if (cmp22 > 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
          }
          if (!isInsert && cmp22 <= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp22 === 0)
              point.bias = 1;
          }
        }
      }
      function clonePos(pos) {
        return { row: pos.row, column: pos.column };
      }
      function cloneDelta(d) {
        return {
          start: clonePos(d.start),
          end: clonePos(d.end),
          action: d.action,
          lines: d.lines.slice()
        };
      }
      function stringifyDelta(d) {
        d = d || this;
        if (Array.isArray(d)) {
          return d.map(stringifyDelta).join("\n");
        }
        var type = "";
        if (d.action) {
          type = d.action == "insert" ? "+" : "-";
          type += "[" + d.lines + "]";
        } else if (d.value) {
          if (Array.isArray(d.value)) {
            type = d.value.map(stringifyRange).join("\n");
          } else {
            type = stringifyRange(d.value);
          }
        }
        if (d.start) {
          type += stringifyRange(d);
        }
        if (d.id || d.rev) {
          type += "	(" + (d.id || d.rev) + ")";
        }
        return type;
      }
      function stringifyRange(r) {
        return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
      }
      function swap(d1, d2) {
        var i1 = d1.action == "insert";
        var i2 = d2.action == "insert";
        if (i1 && i2) {
          if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
          } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, 1);
          } else {
            return null;
          }
        } else if (i1 && !i2) {
          if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
          } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
          } else {
            return null;
          }
        } else if (!i1 && i2) {
          if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, 1);
          } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, 1);
          } else {
            return null;
          }
        } else if (!i1 && !i2) {
          if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, 1);
          } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
          } else {
            return null;
          }
        }
        return [d2, d1];
      }
      function swapGroups(ds1, ds2) {
        for (var i = ds1.length; i--; ) {
          for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
              while (i < ds1.length) {
                while (j--) {
                  swap(ds2[j], ds1[i]);
                }
                j = ds2.length;
                i++;
              }
              return [ds1, ds2];
            }
          }
        }
        ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
        return [ds2, ds1];
      }
      function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        if (i1 && i2) {
          if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, c1, 1);
          }
        } else if (i1 && !i2) {
          if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
          } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, 1);
          }
        } else if (!i1 && i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, 1);
          } else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, 1);
          }
        } else if (!i1 && !i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
          } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
              before = d1;
              d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
              after = splitDelta(d1, c1.end);
            }
            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
              d1.lines = after.lines;
              d1.start = after.start;
              d1.end = after.end;
              after = d1;
            }
            return [c1, before, after].filter(Boolean);
          }
        }
        return [c1, d1];
      }
      function shift(d1, d2, dir) {
        shiftPos(d1.start, d2.start, d2.end, dir);
        shiftPos(d1.end, d2.start, d2.end, dir);
      }
      function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
          pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
      }
      function splitDelta(c, pos) {
        var lines = c.lines;
        var end = c.end;
        c.end = clonePos(pos);
        var rowsBefore = c.end.row - c.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        var col = rowsBefore ? pos.column : pos.column - c.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col);
        var rest = {
          start: clonePos(pos),
          end,
          lines: otherLines,
          action: c.action
        };
        return rest;
      }
      function moveDeltasByOne(redoStack, d) {
        d = cloneDelta(d);
        for (var j = redoStack.length; j--; ) {
          var deltaSet = redoStack[j];
          for (var i = 0; i < deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
              if (xformed[2]) {
                deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                i++;
              } else if (!xformed[1]) {
                deltaSet.splice(i, 1);
                i--;
              }
            }
          }
          if (!deltaSet.length) {
            redoStack.splice(j, 1);
          }
        }
        return redoStack;
      }
      function rebaseRedoStack(redoStack, deltaSets) {
        for (var i = 0; i < deltaSets.length; i++) {
          var deltas = deltaSets[i];
          for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
          }
        }
      }
      exports2.UndoManager = UndoManager;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range = require2("../range").Range;
      var FoldLine = (
        /** @class */
        function() {
          function FoldLine2(foldData, folds) {
            this.foldData = foldData;
            if (Array.isArray(folds)) {
              this.folds = folds;
            } else {
              folds = this.folds = [folds];
            }
            var last = folds[folds.length - 1];
            this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
            this.start = this.range.start;
            this.end = this.range.end;
            this.folds.forEach(function(fold) {
              fold.setFoldLine(this);
            }, this);
          }
          FoldLine2.prototype.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
              fold.start.row += shift;
              fold.end.row += shift;
            });
          };
          FoldLine2.prototype.addFold = function(fold) {
            if (fold.sameRow) {
              if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
              }
              this.folds.push(fold);
              this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
              });
              if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
              } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
              }
            } else if (fold.start.row == this.end.row) {
              this.folds.push(fold);
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
              this.folds.unshift(fold);
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            } else {
              throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold.foldLine = this;
          };
          FoldLine2.prototype.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
          };
          FoldLine2.prototype.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
            if (endRow == null) {
              endRow = this.end.row;
              endColumn = this.end.column;
            }
            for (var i = 0; i < folds.length; i++) {
              fold = folds[i];
              cmp = fold.range.compareStart(endRow, endColumn);
              if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
              }
              stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
              stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
              if (stop || cmp === 0) {
                return;
              }
              isNewRow = !fold.sameRow;
              lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
          };
          FoldLine2.prototype.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for (var i = 0; i < this.folds.length; i++) {
              fold = this.folds[i];
              cmp = fold.range.compareEnd(row, column);
              if (cmp == -1) {
                return {
                  fold,
                  kind: "after"
                };
              } else if (cmp === 0) {
                return {
                  fold,
                  kind: "inside"
                };
              }
            }
            return null;
          };
          FoldLine2.prototype.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column), fold, folds;
            if (ret) {
              fold = ret.fold;
              if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                window.console && window.console.log(row, column, fold);
              } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                  this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                  fold = folds[i];
                  fold.start.column += len;
                  if (!fold.sameRow) {
                    return;
                  }
                  fold.end.column += len;
                }
                this.end.column += len;
              }
            }
          };
          FoldLine2.prototype.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            if (!pos || pos.kind == "inside")
              return null;
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            var i = folds.indexOf(fold);
            var foldBefore = folds[i - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i, folds.length - i);
            var newFoldLine = new FoldLine2(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
          };
          FoldLine2.prototype.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i = 0; i < folds.length; i++) {
              this.addFold(folds[i]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
          };
          FoldLine2.prototype.toString = function() {
            var ret = [this.range.toString() + ": ["];
            this.folds.forEach(function(fold) {
              ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
          };
          FoldLine2.prototype.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;
            for (var i = 0; i < this.folds.length; i++) {
              var fold = this.folds[i];
              idx -= fold.start.column - lastFoldEndColumn;
              if (idx < 0) {
                return {
                  row: fold.start.row,
                  column: fold.start.column + idx
                };
              }
              idx -= fold.placeholder.length;
              if (idx < 0) {
                return fold.start;
              }
              lastFoldEndColumn = fold.end.column;
            }
            return {
              row: this.end.row,
              column: this.end.column + idx
            };
          };
          return FoldLine2;
        }()
      );
      exports2.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range = require2("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = (
        /** @class */
        function() {
          function RangeList2() {
            this.ranges = [];
            this.$bias = 1;
          }
          RangeList2.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;
            for (var i = startIndex || 0; i < list.length; i++) {
              var range = list[i];
              var cmpEnd = comparePoints(pos, range.end);
              if (cmpEnd > 0)
                continue;
              var cmpStart = comparePoints(pos, range.start);
              if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
              if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
                return i;
              return -i - 1;
            }
            return -i - 1;
          };
          RangeList2.prototype.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            else
              endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
          };
          RangeList2.prototype.addList = function(list) {
            var removed = [];
            for (var i = list.length; i--; ) {
              removed.push.apply(removed, this.add(list[i]));
            }
            return removed;
          };
          RangeList2.prototype.substractPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges.splice(i, 1);
          };
          RangeList2.prototype.merge = function() {
            var removed = [];
            var list = this.ranges;
            list = list.sort(function(a, b) {
              return comparePoints(a.start, b.start);
            });
            var next = list[0], range;
            for (var i = 1; i < list.length; i++) {
              range = next;
              next = list[i];
              var cmp = comparePoints(range.end, next.start);
              if (cmp < 0)
                continue;
              if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;
              if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
              }
              list.splice(i, 1);
              removed.push(next);
              next = range;
              i--;
            }
            this.ranges = list;
            return removed;
          };
          RangeList2.prototype.contains = function(row, column) {
            return this.pointIndex({ row, column }) >= 0;
          };
          RangeList2.prototype.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
          };
          RangeList2.prototype.rangeAtPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges[i];
          };
          RangeList2.prototype.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
              return [];
            var startIndex = this.pointIndex({ row: startRow, column: 0 });
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            var clipped = [];
            for (var i = startIndex; i < endIndex; i++) {
              clipped.push(list[i]);
            }
            return clipped;
          };
          RangeList2.prototype.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
          };
          RangeList2.prototype.attach = function(session) {
            if (this.session)
              this.detach();
            this.session = session;
            this.onChange = this.$onChange.bind(this);
            this.session.on("change", this.onChange);
          };
          RangeList2.prototype.detach = function() {
            if (!this.session)
              return;
            this.session.removeListener("change", this.onChange);
            this.session = null;
          };
          RangeList2.prototype.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for (var i = 0, n = ranges.length; i < n; i++) {
              var r = ranges[i];
              if (r.end.row >= startRow)
                break;
            }
            if (delta.action == "insert") {
              var lineDif = endRow - startRow;
              var colDiff = -start.column + end.column;
              for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > startRow)
                  break;
                if (r.start.row == startRow && r.start.column >= start.column) {
                  if (r.start.column == start.column && this.$bias <= 0) {
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                  if (r.end.column == start.column && this.$bias < 0) {
                    continue;
                  }
                  if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                    if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                      r.end.column -= colDiff;
                  }
                  r.end.column += colDiff;
                  r.end.row += lineDif;
                }
              }
            } else {
              var lineDif = startRow - endRow;
              var colDiff = start.column - end.column;
              for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > endRow)
                  break;
                if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                  r.end.row = startRow;
                  r.end.column = start.column;
                } else if (r.end.row == endRow) {
                  if (r.end.column <= end.column) {
                    if (lineDif || r.end.column > start.column) {
                      r.end.column = start.column;
                      r.end.row = start.row;
                    }
                  } else {
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                  }
                } else if (r.end.row > endRow) {
                  r.end.row += lineDif;
                }
                if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                  r.start.row = startRow;
                  r.start.column = start.column;
                } else if (r.start.row == endRow) {
                  if (r.start.column <= end.column) {
                    if (lineDif || r.start.column > start.column) {
                      r.start.column = start.column;
                      r.start.row = start.row;
                    }
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                } else if (r.start.row > endRow) {
                  r.start.row += lineDif;
                }
              }
            }
            if (lineDif != 0 && i < n) {
              for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
              }
            }
          };
          return RangeList2;
        }()
      );
      RangeList.prototype.comparePoints = comparePoints;
      exports2.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var RangeList = require2("../range_list").RangeList;
      var Fold = (
        /** @class */
        function(_super) {
          __extends(Fold2, _super);
          function Fold2(range, placeholder) {
            var _this = _super.call(this) || this;
            _this.foldLine = null;
            _this.placeholder = placeholder;
            _this.range = range;
            _this.start = range.start;
            _this.end = range.end;
            _this.sameRow = range.start.row == range.end.row;
            _this.subFolds = _this.ranges = [];
            return _this;
          }
          Fold2.prototype.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
          };
          Fold2.prototype.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
              fold.setFoldLine(foldLine);
            });
          };
          Fold2.prototype.clone = function() {
            var range = this.range.clone();
            var fold = new Fold2(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
              fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
          };
          Fold2.prototype.addSubFold = function(fold) {
            if (this.range.isEqual(fold))
              return;
            consumeRange(fold, this.start);
            var row = fold.start.row, column = fold.start.column;
            for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
              cmp = this.subFolds[i].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            var afterStart = this.subFolds[i];
            var firstConsumed = 0;
            if (cmp == 0) {
              if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
              else
                firstConsumed = 1;
            }
            var row = fold.range.end.row, column = fold.range.end.column;
            for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
              cmp = this.subFolds[j].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            if (cmp == 0)
              j++;
            var consumedFolds = this.subFolds.splice(i, j - i, fold);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for (var k = firstConsumed; k < last; k++) {
              fold.addSubFold(consumedFolds[k]);
            }
            fold.setFoldLine(this.foldLine);
            return fold;
          };
          Fold2.prototype.restoreRange = function(range) {
            return restoreRange(range, this.start);
          };
          return Fold2;
        }(RangeList)
      );
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
          point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0)
          point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
      exports2.Fold = Fold;
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator", "ace/mouse/mouse_event"], function(require2, exports2, module2) {
      "use strict";
      var Range = require2("../range").Range;
      var FoldLine = require2("./fold_line").FoldLine;
      var Fold = require2("./fold").Fold;
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var MouseEvent = require2("../mouse/mouse_event").MouseEvent;
      function Folding() {
        this.getFoldAt = function(row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine)
            return null;
          var folds = foldLine.folds;
          for (var i = 0; i < folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
              if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                continue;
              } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                continue;
              }
              return folds[i];
            }
          }
        };
        this.getFoldsInRange = function(range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
              var fold = folds[j];
              cmp = fold.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function() {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
              folds.push(foldLines[i].folds[j]);
          return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine)
            return null;
          var lastFold = {
            end: { column: 0 }
          };
          var str, fold;
          for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold;
          }
          if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
          if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
          else if (trim == 1)
            return str.substring(column - lastFold.end.column);
          else
            return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function(first, last) {
          var foldData = this.$foldData, rowCount = last - first + 1;
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first)
                  rowCount -= last - start;
                else
                  rowCount = 0;
              }
              break;
            } else if (end >= first) {
              if (start >= first)
                rowCount -= end - start;
              else
                rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
          });
          return foldLine;
        };
        this.addFold = function(placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold;
          if (placeholder instanceof Fold)
            fold = placeholder;
          else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold.range);
          var startRow = fold.start.row;
          var startColumn = fold.start.column;
          var endRow = fold.end.row;
          var endColumn = fold.end.column;
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);
          if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            if (!fold.collapseChildren) {
              folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
              });
            }
          }
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold);
              added = true;
              if (!fold.sameRow) {
                var foldLineNext = foldData[i + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
          if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
          else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "add" });
          return fold;
        };
        this.addFolds = function(folds) {
          folds.forEach(function(fold) {
            this.addFold(fold);
          }, this);
        };
        this.removeFold = function(fold) {
          var foldLine = fold.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
          } else {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode)
              this.$updateWrapData(startRow, endRow);
            else
              this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "remove" });
        };
        this.removeFolds = function(folds) {
          var cloneFolds = [];
          for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
          }
          cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function(fold) {
          this.removeFold(fold);
          fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
          }
          fold.subFolds = [];
        };
        this.expandFolds = function(folds) {
          folds.forEach(function(fold) {
            this.expandFold(fold);
          }, this);
        };
        this.unfold = function(location, expandInner) {
          var range, folds;
          if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null)
              expandInner = true;
          } else if (typeof location == "number") {
            range = new Range(location, 0, location, this.getLine(location).length);
          } else if ("row" in location) {
            range = Range.fromPoints(location, location);
          } else if (Array.isArray(location)) {
            folds = [];
            location.forEach(function(range2) {
              folds = folds.concat(this.unfold(range2));
            }, this);
            return folds;
          } else {
            range = location;
          }
          folds = this.getFoldsInRangeList(range);
          var outermostFolds = folds;
          while (folds.length == 1 && Range.comparePoints(folds[0].start, range.start) < 0 && Range.comparePoints(folds[0].end, range.end) > 0) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
          }
          if (expandInner != false) {
            this.removeFolds(folds);
          } else {
            this.expandFolds(folds);
          }
          if (outermostFolds.length)
            return outermostFolds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null)
            startRow = foldLine.start.row;
          if (startColumn == null)
            startColumn = 0;
          if (endRow == null)
            endRow = foldLine.end.row;
          if (endColumn == null)
            endColumn = this.getLine(endRow).length;
          var doc = this.doc;
          var textLine = "";
          foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
              return;
            if (row == startRow) {
              if (column < startColumn)
                return;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function() {
          var fd = [];
          fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
              return fold.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function(tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
              this.expandFold(fold);
              return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
              if (range.comparePoint(bracketPos) == 1)
                range.end = bracketPos;
              else
                range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return;
            } else if (folds.length == 1) {
              fold = folds[0];
            }
          }
          if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
          if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
              return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          var type = token && token.type;
          if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
              type += "|doc-start|\\.doc";
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re.test(token.type) && !/^comment.end/.test(token.type));
              token = iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + (/^comment.start/.test(token.type) ? token.value.length : 2);
            iterator = new TokenIterator(this, row, column);
            if (dir != -1) {
              var lastRow = -1;
              do {
                token = iterator.stepForward();
                if (lastRow == -1) {
                  var state = this.getState(iterator.$row);
                  if (!re.test(state))
                    lastRow = iterator.$row;
                } else if (iterator.$row > lastRow) {
                  break;
                }
              } while (token && re.test(token.type) && !/^comment.start/.test(token.type));
              token = iterator.stepBackward();
            } else
              token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            if (!/^comment.end/.test(token.type)) {
              range.end.column += token.value.length - 2;
            }
            return range;
          }
        };
        this.foldAll = function(startRow, endRow, depth, test) {
          if (depth == void 0)
            depth = 1e5;
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets)
            return;
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
              foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
              continue;
            if (test && !test(row))
              continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              range.collapseChildren = depth;
              this.addFold("...", range);
            }
          }
        };
        this.foldToLevel = function(level) {
          this.foldAll();
          while (level-- > 0)
            this.unfold(null, false);
        };
        this.foldAllComments = function() {
          var session = this;
          this.foldAll(null, null, null, function(row) {
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              if (token.type == "text" && /^\s+$/.test(token.value))
                continue;
              if (/comment/.test(token.type))
                return true;
              return false;
            }
          });
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
          if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style)
            return;
          this.$foldStyle = style;
          if (style == "manual")
            this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
          if (this.$foldMode == foldMode)
            return;
          this.$foldMode = foldMode;
          this.off("change", this.$updateFoldWidgets);
          this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
          this._signal("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
          this.on("change", this.$updateFoldWidgets);
          this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || ignoreCurrent && fw[row])
            return {};
          var i = row - 1, firstRange;
          while (i >= 0) {
            var c = fw[i];
            if (c == null)
              c = fw[i] = this.getFoldWidget(i);
            if (c == "start") {
              var range = this.getFoldWidgetRange(i);
              if (!firstRange)
                firstRange = range;
              if (range && range.end.row >= row)
                break;
            }
            i--;
          }
          return {
            range: i !== -1 && range,
            firstRange
          };
        };
        this.onFoldWidgetClick = function(row, e) {
          if (e instanceof MouseEvent)
            e = e.domEvent;
          var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = e.target || e.srcElement;
            if (el && /ace_fold-widget/.test(el.className))
              el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function(row, options) {
          if (!this.getFoldWidget)
            return;
          var type = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type === "end" ? -1 : 1;
          var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold) {
            if (options.children || options.all)
              this.removeFold(fold);
            else
              this.expandFold(fold);
            return fold;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
              this.removeFold(fold);
              return fold;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
          } else if (range) {
            if (options.all)
              range.collapseChildren = 1e4;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range)
            return;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
              this.removeFold(fold);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function(delta) {
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == "remove") {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
        this.tokenizerUpdateFoldWidgets = function(e) {
          var rows = e.data;
          if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
              this.foldWidgets.splice(rows.first, this.foldWidgets.length);
          }
        };
      }
      exports2.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range = require2("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function(position, chr) {
          if (position.column == 0)
            return null;
          var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
          if (charBeforeCursor == "")
            return null;
          var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match)
            return null;
          if (match[1])
            return this.$findClosingBracket(match[1], position);
          else
            return this.$findOpeningBracket(match[2], position);
        };
        this.getBracketRange = function(pos) {
          var line = this.getLine(pos.row);
          var before = true, range;
          var chr = line.charAt(pos.column - 1);
          var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match) {
            chr = line.charAt(pos.column);
            pos = { row: pos.row, column: pos.column + 1 };
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match)
            return null;
          if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.getMatchingBracketRanges = function(pos, isBackwards) {
          var line = this.getLine(pos.row);
          var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
          var chr = !isBackwards && line.charAt(pos.column - 1);
          var match = chr && chr.match(bracketsRegExp);
          if (!match) {
            chr = (isBackwards === void 0 || isBackwards) && line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match = chr && chr.match(bracketsRegExp);
          }
          if (!match)
            return null;
          var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
          var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos) : this.$findOpeningBracket(match[2], pos);
          if (!bracketPos)
            return [startRange];
          var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
          return [startRange, endRange];
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{",
          "<": ">",
          ">": "<"
        };
        this.$findOpeningBracket = function(bracket, position, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function(bracket, position, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            valueIndex = 0;
          }
          return null;
        };
        this.getMatchingTags = function(pos) {
          var iterator = new TokenIterator(this, pos.row, pos.column);
          var token = this.$findTagName(iterator);
          if (!token)
            return;
          var prevToken = iterator.stepBackward();
          if (prevToken.value === "<") {
            return this.$findClosingTag(iterator, token);
          } else {
            return this.$findOpeningTag(iterator, token);
          }
        };
        this.$findTagName = function(iterator) {
          var token = iterator.getCurrentToken();
          var found = false;
          var backward = false;
          if (token && token.type.indexOf("tag-name") === -1) {
            do {
              if (backward)
                token = iterator.stepBackward();
              else
                token = iterator.stepForward();
              if (token) {
                if (token.value === "/>") {
                  backward = true;
                } else if (token.type.indexOf("tag-name") !== -1) {
                  found = true;
                }
              }
            } while (token && !found);
          }
          return token;
        };
        this.$findClosingTag = function(iterator, token) {
          var prevToken;
          var currentTag = token.value;
          var tag = token.value;
          var depth = 0;
          var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          token = iterator.stepForward();
          var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          var foundOpenTagEnd = false;
          do {
            prevToken = token;
            token = iterator.stepForward();
            if (token) {
              if (token.value === ">" && !foundOpenTagEnd) {
                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                foundOpenTagEnd = true;
              }
              if (token.type.indexOf("tag-name") !== -1) {
                currentTag = token.value;
                if (tag === currentTag) {
                  if (prevToken.value === "<") {
                    depth++;
                  } else if (prevToken.value === "</") {
                    depth--;
                    if (depth < 0) {
                      iterator.stepBackward();
                      var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                      token = iterator.stepForward();
                      var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                      token = iterator.stepForward();
                      if (token && token.value === ">") {
                        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      } else {
                        return;
                      }
                    }
                  }
                }
              } else if (tag === currentTag && token.value === "/>") {
                depth--;
                if (depth < 0) {
                  var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                  var closeTagName = closeTagStart;
                  var closeTagEnd = closeTagName;
                  var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                }
              }
            }
          } while (token && depth >= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
        this.$findOpeningTag = function(iterator, token) {
          var prevToken = iterator.getCurrentToken();
          var tag = token.value;
          var depth = 0;
          var startRow = iterator.getCurrentTokenRow();
          var startColumn = iterator.getCurrentTokenColumn();
          var endColumn = startColumn + 2;
          var closeTagStart = new Range(startRow, startColumn, startRow, endColumn);
          iterator.stepForward();
          var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          token = iterator.stepForward();
          if (!token || token.value !== ">")
            return;
          var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          iterator.stepBackward();
          iterator.stepBackward();
          do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;
            prevToken = iterator.stepBackward();
            if (token) {
              if (token.type.indexOf("tag-name") !== -1) {
                if (tag === token.value) {
                  if (prevToken.value === "<") {
                    depth++;
                    if (depth > 0) {
                      var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                      var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      do {
                        token = iterator.stepForward();
                      } while (token && token.value !== ">");
                      var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    }
                  } else if (prevToken.value === "</") {
                    depth--;
                  }
                }
              } else if (token.value === "/>") {
                var stepCount = 0;
                var tmpToken = prevToken;
                while (tmpToken) {
                  if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                    depth--;
                    break;
                  } else if (tmpToken.value === "<") {
                    break;
                  }
                  tmpToken = iterator.stepBackward();
                  stepCount++;
                }
                for (var i = 0; i < stepCount; i++) {
                  iterator.stepForward();
                }
              }
            }
          } while (prevToken && depth <= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
      }
      exports2.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/undomanager", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var BidiHandler = require2("./bidihandler").BidiHandler;
      var config = require2("./config");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Selection = require2("./selection").Selection;
      var TextMode = require2("./mode/text").Mode;
      var Range = require2("./range").Range;
      var Document = require2("./document").Document;
      var BackgroundTokenizer = require2("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = require2("./search_highlight").SearchHighlight;
      var UndoManager = require2("./undomanager").UndoManager;
      var EditSession = (
        /** @class */
        function() {
          function EditSession2(text, mode) {
            this.$breakpoints = [];
            this.$decorations = [];
            this.$frontMarkers = {};
            this.$backMarkers = {};
            this.$markerId = 1;
            this.$undoSelect = true;
            this.$foldData = [];
            this.id = "session" + ++EditSession2.$uid;
            this.$foldData.toString = function() {
              return this.join("\n");
            };
            this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
            var _self = this;
            this.bgTokenizer.on("update", function(e) {
              _self._signal("tokenizerUpdate", e);
            });
            this.on("changeFold", this.onChangeFold.bind(this));
            this.$onChange = this.onChange.bind(this);
            if (typeof text != "object" || !text.getLine)
              text = new Document(text);
            this.setDocument(text);
            this.selection = new Selection(this);
            this.$bidiHandler = new BidiHandler(this);
            config.resetOptions(this);
            this.setMode(mode);
            config._signal("session", this);
            this.destroyed = false;
          }
          EditSession2.prototype.setDocument = function(doc) {
            if (this.doc)
              this.doc.off("change", this.$onChange);
            this.doc = doc;
            doc.on("change", this.$onChange, true);
            this.bgTokenizer.setDocument(this.getDocument());
            this.resetCaches();
          };
          EditSession2.prototype.getDocument = function() {
            return this.doc;
          };
          EditSession2.prototype.$resetRowCache = function(docRow) {
            if (!docRow) {
              this.$docRowCache = [];
              this.$screenRowCache = [];
              return;
            }
            var l = this.$docRowCache.length;
            var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i) {
              this.$docRowCache.splice(i, l);
              this.$screenRowCache.splice(i, l);
            }
          };
          EditSession2.prototype.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;
            while (low <= hi) {
              var mid = low + hi >> 1;
              var c = cacheArray[mid];
              if (val > c)
                low = mid + 1;
              else if (val < c)
                hi = mid - 1;
              else
                return mid;
            }
            return low - 1;
          };
          EditSession2.prototype.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (!this.destroyed)
              this.bgTokenizer.start(0);
          };
          EditSession2.prototype.onChangeFold = function(e) {
            var fold = e.data;
            this.$resetRowCache(fold.start.row);
          };
          EditSession2.prototype.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);
            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
              if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                  action: "removeFolds",
                  folds: removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
              }
              this.$undoManager.add(delta, this.mergeUndoDeltas);
              this.mergeUndoDeltas = true;
              this.$informUndoManager.schedule();
            }
            this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
          };
          EditSession2.prototype.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);
            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
          };
          EditSession2.fromJSON = function(session) {
            session = JSON.parse(session);
            var undoManager = new UndoManager();
            undoManager.$undoStack = session.history.undo;
            undoManager.$redoStack = session.history.redo;
            undoManager.mark = session.history.mark;
            undoManager.$rev = session.history.rev;
            var editSession = new EditSession2(session.value);
            session.folds.forEach(function(fold) {
              editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
            });
            editSession.setAnnotations(session.annotations);
            editSession.setBreakpoints(session.breakpoints);
            editSession.setMode(session.mode);
            editSession.setScrollLeft(session.scrollLeft);
            editSession.setScrollTop(session.scrollTop);
            editSession.setUndoManager(undoManager);
            editSession.selection.fromJSON(session.selection);
            return editSession;
          };
          EditSession2.prototype.toJSON = function() {
            return {
              annotations: this.$annotations,
              breakpoints: this.$breakpoints,
              folds: this.getAllFolds().map(function(fold) {
                return fold.range;
              }),
              history: this.getUndoManager(),
              mode: this.$mode.$id,
              scrollLeft: this.$scrollLeft,
              scrollTop: this.$scrollTop,
              selection: this.selection.toJSON(),
              value: this.doc.getValue()
            };
          };
          EditSession2.prototype.toString = function() {
            return this.doc.getValue();
          };
          EditSession2.prototype.getSelection = function() {
            return this.selection;
          };
          EditSession2.prototype.getState = function(row) {
            return this.bgTokenizer.getState(row);
          };
          EditSession2.prototype.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
          };
          EditSession2.prototype.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c = 0;
            if (column == null) {
              var i = tokens.length - 1;
              c = this.getLine(row).length;
            } else {
              for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                  break;
              }
            }
            token = tokens[i];
            if (!token)
              return null;
            token.index = i;
            token.start = c - token.value.length;
            return token;
          };
          EditSession2.prototype.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            if (this.$informUndoManager)
              this.$informUndoManager.cancel();
            if (undoManager) {
              var self2 = this;
              undoManager.addSession(this);
              this.$syncInformUndoManager = function() {
                self2.$informUndoManager.cancel();
                self2.mergeUndoDeltas = false;
              };
              this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else {
              this.$syncInformUndoManager = function() {
              };
            }
          };
          EditSession2.prototype.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
              this.$syncInformUndoManager();
          };
          EditSession2.prototype.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
          };
          EditSession2.prototype.getTabString = function() {
            if (this.getUseSoftTabs()) {
              return lang.stringRepeat(" ", this.getTabSize());
            } else {
              return "	";
            }
          };
          EditSession2.prototype.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
          };
          EditSession2.prototype.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          };
          EditSession2.prototype.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
          };
          EditSession2.prototype.getTabSize = function() {
            return this.$tabSize;
          };
          EditSession2.prototype.isTabStop = function(position) {
            return this.$useSoftTabs && position.column % this.$tabSize === 0;
          };
          EditSession2.prototype.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
          };
          EditSession2.prototype.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
          };
          EditSession2.prototype.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
          };
          EditSession2.prototype.getOverwrite = function() {
            return this.$overwrite;
          };
          EditSession2.prototype.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
          };
          EditSession2.prototype.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
              this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.getBreakpoints = function() {
            return this.$breakpoints;
          };
          EditSession2.prototype.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i = 0; i < rows.length; i++) {
              this.$breakpoints[rows[i]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.setBreakpoint = function(row, className) {
            if (className === void 0)
              className = "ace_breakpoint";
            if (className)
              this.$breakpoints[row] = className;
            else
              delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;
            var marker = {
              range,
              type: type || "line",
              renderer: typeof type == "function" ? type : null,
              clazz,
              inFront: !!inFront,
              id
            };
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return id;
          };
          EditSession2.prototype.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
              return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return marker;
          };
          EditSession2.prototype.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
              return;
            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete markers[markerId];
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          };
          EditSession2.prototype.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
          };
          EditSession2.prototype.highlight = function(re) {
            if (!this.$searchHighlight) {
              var highlight = new SearchHighlight(null, "ace_selected-word", "text");
              this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re);
          };
          EditSession2.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
              clazz = endRow;
              endRow = startRow;
            }
            if (!clazz)
              clazz = "ace_step";
            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
          };
          EditSession2.prototype.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
          };
          EditSession2.prototype.getAnnotations = function() {
            return this.$annotations || [];
          };
          EditSession2.prototype.clearAnnotations = function() {
            this.setAnnotations([]);
          };
          EditSession2.prototype.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r?\n)/m);
            if (match) {
              this.$autoNewLine = match[1];
            } else {
              this.$autoNewLine = "\n";
            }
          };
          EditSession2.prototype.getWordRange = function(row, column) {
            var line = this.getLine(row);
            var inToken = false;
            if (column > 0)
              inToken = !!line.charAt(column - 1).match(this.tokenRe);
            if (!inToken)
              inToken = !!line.charAt(column).match(this.tokenRe);
            if (inToken)
              var re = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
              var re = /\s/;
            else
              var re = this.nonTokenRe;
            var start = column;
            if (start > 0) {
              do {
                start--;
              } while (start >= 0 && line.charAt(start).match(re));
              start++;
            }
            var end = column;
            while (end < line.length && line.charAt(end).match(re)) {
              end++;
            }
            return new Range(row, start, row, end);
          };
          EditSession2.prototype.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);
            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
              wordRange.end.column += 1;
            }
            return wordRange;
          };
          EditSession2.prototype.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
          };
          EditSession2.prototype.getNewLineMode = function() {
            return this.doc.getNewLineMode();
          };
          EditSession2.prototype.setUseWorker = function(useWorker) {
            this.setOption("useWorker", useWorker);
          };
          EditSession2.prototype.getUseWorker = function() {
            return this.$useWorker;
          };
          EditSession2.prototype.onReloadTokenizer = function(e) {
            var rows = e.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e);
          };
          EditSession2.prototype.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
              if (mode.getTokenizer)
                return this.$onChangeMode(mode);
              var options = mode;
              var path = options.path;
            } else {
              path = mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
              this.$modes["ace/mode/text"] = new TextMode();
            if (this.$modes[path] && !options) {
              this.$onChangeMode(this.$modes[path]);
              cb && cb();
              return;
            }
            this.$modeId = path;
            config.loadModule(["mode", path], (function(m) {
              if (this.$modeId !== path)
                return cb && cb();
              if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
              } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                  this.$modes[path] = m;
                  m.$id = path;
                }
                this.$onChangeMode(m);
              }
              cb && cb();
            }).bind(this));
            if (!this.$mode)
              this.$onChangeMode(this.$modes["ace/mode/text"], true);
          };
          EditSession2.prototype.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
              this.$modeId = mode.$id;
            if (this.$mode === mode)
              return;
            var oldMode = this.$mode;
            this.$mode = mode;
            this.$stopWorker();
            if (this.$useWorker)
              this.$startWorker();
            var tokenizer = mode.getTokenizer();
            if (tokenizer.on !== void 0) {
              var onReloadTokenizer = this.onReloadTokenizer.bind(this);
              tokenizer.on("update", onReloadTokenizer);
            }
            this.bgTokenizer.setTokenizer(tokenizer);
            this.bgTokenizer.setDocument(this.getDocument());
            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;
            if (!$isPlaceholder) {
              if (mode.attachToSession)
                mode.attachToSession(this);
              this.$options.wrapMethod.set.call(this, this.$wrapMethod);
              this.$setFolding(mode.foldingRules);
              this.bgTokenizer.start(0);
              this._emit("changeMode", { oldMode, mode });
            }
          };
          EditSession2.prototype.$stopWorker = function() {
            if (this.$worker) {
              this.$worker.terminate();
              this.$worker = null;
            }
          };
          EditSession2.prototype.$startWorker = function() {
            try {
              this.$worker = this.$mode.createWorker(this);
            } catch (e) {
              config.warn("Could not load worker", e);
              this.$worker = null;
            }
          };
          EditSession2.prototype.getMode = function() {
            return this.$mode;
          };
          EditSession2.prototype.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
              return;
            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
          };
          EditSession2.prototype.getScrollTop = function() {
            return this.$scrollTop;
          };
          EditSession2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
              return;
            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
          };
          EditSession2.prototype.getScrollLeft = function() {
            return this.$scrollLeft;
          };
          EditSession2.prototype.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets)
              return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
          };
          EditSession2.prototype.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null)
              return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w) {
              if (w && w.screenWidth > width)
                width = w.screenWidth;
            });
            return this.lineWidgetWidth = width;
          };
          EditSession2.prototype.$computeWidth = function(force) {
            if (this.$modified || force) {
              this.$modified = false;
              if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
              var lines = this.doc.getAllLines();
              var cache = this.$rowLengthCache;
              var longestScreenLine = 0;
              var foldIndex = 0;
              var foldLine = this.$foldData[foldIndex];
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              var len = lines.length;
              for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                  i = foldLine.end.row + 1;
                  if (i >= len)
                    break;
                  foldLine = this.$foldData[foldIndex++];
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i] == null)
                  cache[i] = this.$getStringScreenWidth(lines[i])[0];
                if (cache[i] > longestScreenLine)
                  longestScreenLine = cache[i];
              }
              this.screenWidth = longestScreenLine;
            }
          };
          EditSession2.prototype.getLine = function(row) {
            return this.doc.getLine(row);
          };
          EditSession2.prototype.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
          };
          EditSession2.prototype.getLength = function() {
            return this.doc.getLength();
          };
          EditSession2.prototype.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
          };
          EditSession2.prototype.insert = function(position, text) {
            return this.doc.insert(position, text);
          };
          EditSession2.prototype.remove = function(range) {
            return this.doc.remove(range);
          };
          EditSession2.prototype.removeFullLines = function(firstRow, lastRow) {
            return this.doc.removeFullLines(firstRow, lastRow);
          };
          EditSession2.prototype.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i = deltas.length - 1; i != -1; i--) {
              var delta = deltas[i];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
              } else if (delta.folds) {
                this.addFolds(delta.folds);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i = 0; i < deltas.length; i++) {
              var delta = deltas[i];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
          };
          EditSession2.prototype.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta2) {
              return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
            }
            var range, point;
            for (var i = 0; i < deltas.length; i++) {
              var delta = deltas[i];
              if (!delta.start)
                continue;
              if (!range) {
                if (isInsert(delta)) {
                  range = Range.fromPoints(delta.start, delta.end);
                } else {
                  range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
              }
              if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                  range.setEnd(point);
                }
              } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range = Range.fromPoints(delta.start, delta.start);
                }
              }
            }
            return range;
          };
          EditSession2.prototype.replace = function(range, text) {
            return this.doc.replace(range, text);
          };
          EditSession2.prototype.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);
            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
              this.remove(fromRange);
              var rowDiff = fromRange.start.row - fromRange.end.row;
              var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
              if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                  toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                  toRange.end.column += collDiff;
              }
              if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
              }
            }
            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
              var oldStart = fromRange.start;
              var newStart = toRange.start;
              var rowDiff = newStart.row - oldStart.row;
              var collDiff = newStart.column - oldStart.column;
              this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                  x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                  x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
              }));
            }
            return toRange;
          };
          EditSession2.prototype.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row = startRow; row <= endRow; row++)
              this.doc.insertInLine({ row, column: 0 }, indentString);
          };
          EditSession2.prototype.outdentRows = function(range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();
            for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
              var line = this.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              for (var j = 0; j < size; ++j)
                if (line.charAt(j) != " ")
                  break;
              if (j < size && line.charAt(j) == "	") {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
              } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
              }
              this.remove(deleteRange);
            }
          };
          EditSession2.prototype.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
              var row = this.getRowFoldStart(firstRow + dir);
              if (row < 0)
                return 0;
              var diff = row - firstRow;
            } else if (dir > 0) {
              var row = this.getRowFoldEnd(lastRow + dir);
              if (row > this.doc.getLength() - 1)
                return 0;
              var diff = row - lastRow;
            } else {
              firstRow = this.$clipRowToDocument(firstRow);
              lastRow = this.$clipRowToDocument(lastRow);
              var diff = lastRow - firstRow + 1;
            }
            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x) {
              x = x.clone();
              x.start.row += diff;
              x.end.row += diff;
              return x;
            });
            var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow + diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
          };
          EditSession2.prototype.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
          };
          EditSession2.prototype.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
          };
          EditSession2.prototype.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
          };
          EditSession2.prototype.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength() - 1));
          };
          EditSession2.prototype.$clipColumnToRow = function(row, column) {
            if (column < 0)
              return 0;
            return Math.min(this.doc.getLine(row).length, column);
          };
          EditSession2.prototype.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);
            if (row < 0) {
              row = 0;
              column = 0;
            } else {
              var len = this.doc.getLength();
              if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
              } else {
                column = Math.min(this.doc.getLine(row).length, column);
              }
            }
            return {
              row,
              column
            };
          };
          EditSession2.prototype.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
              range.start.row = 0;
              range.start.column = 0;
            } else {
              range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
            }
            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
              range.end.row = len;
              range.end.column = this.doc.getLine(len).length;
            } else {
              range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
            }
            return range;
          };
          EditSession2.prototype.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
              this.$useWrapMode = useWrapMode;
              this.$modified = true;
              this.$resetRowCache(0);
              if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
              }
              this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.getUseWrapMode = function() {
            return this.$useWrapMode;
          };
          EditSession2.prototype.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
              this.$wrapLimitRange = { min, max };
              this.$modified = true;
              this.$bidiHandler.markAsDirty();
              if (this.$useWrapMode)
                this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
              limits = { min: $printMargin, max: $printMargin };
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
              this.$wrapLimit = wrapLimit;
              this.$modified = true;
              if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
              }
              return true;
            }
            return false;
          };
          EditSession2.prototype.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min)
              wrapLimit = Math.max(min, wrapLimit);
            if (max)
              wrapLimit = Math.min(max, wrapLimit);
            return wrapLimit;
          };
          EditSession2.prototype.getWrapLimit = function() {
            return this.$wrapLimit;
          };
          EditSession2.prototype.setWrapLimit = function(limit) {
            this.setWrapLimitRange(limit, limit);
          };
          EditSession2.prototype.getWrapLimitRange = function() {
            return {
              min: this.$wrapLimitRange.min,
              max: this.$wrapLimitRange.max
            };
          };
          EditSession2.prototype.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            this.$updating = true;
            if (len != 0) {
              if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                  foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                  foldLine.shiftRow(-len);
                  var foldLineBefore = this.getFoldLine(firstRow);
                  if (foldLineBefore && foldLineBefore !== foldLine) {
                    foldLineBefore.merge(foldLine);
                    foldLine = foldLineBefore;
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= end.row) {
                    foldLine.shiftRow(-len);
                  }
                }
                lastRow = firstRow;
              } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                  var cmp = foldLine.range.compareInside(start.row, start.column);
                  if (cmp == 0) {
                    foldLine = foldLine.split(start.row, start.column);
                    if (foldLine) {
                      foldLine.shiftRow(len);
                      foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                    }
                  } else if (cmp == -1) {
                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                    foldLine.shiftRow(len);
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= firstRow) {
                    foldLine.shiftRow(len);
                  }
                }
              }
            } else {
              len = Math.abs(delta.start.column - delta.end.column);
              if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
              }
              var foldLine = this.getFoldLine(firstRow);
              if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
              }
            }
            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
              console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;
            if (useWrapMode)
              this.$updateWrapData(firstRow, lastRow);
            else
              this.$updateRowLengthCache(firstRow, lastRow);
            return removedFolds;
          };
          EditSession2.prototype.$updateRowLengthCache = function(firstRow, lastRow, b) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
          };
          EditSession2.prototype.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;
            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
              foldLine = this.getFoldLine(row, foldLine);
              if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
              } else {
                tokens = [];
                foldLine.walk((function(placeholder, row2, column, lastColumn) {
                  var walkTokens;
                  if (placeholder != null) {
                    walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                    walkTokens[0] = PLACEHOLDER_START;
                    for (var i = 1; i < walkTokens.length; i++) {
                      walkTokens[i] = PLACEHOLDER_BODY;
                    }
                  } else {
                    walkTokens = this.$getDisplayTokens(lines[row2].substring(lastColumn, column), tokens.length);
                  }
                  tokens = tokens.concat(walkTokens);
                }).bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
              }
            }
          };
          EditSession2.prototype.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) {
              return [];
            }
            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;
            var isCode = this.$wrapAsCode;
            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
            function getWrapIndent() {
              var indentation = 0;
              if (maxIndent === 0)
                return indentation;
              if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                  var token = tokens[i];
                  if (token == SPACE)
                    indentation += 1;
                  else if (token == TAB)
                    indentation += tabSize;
                  else if (token == TAB_SPACE)
                    continue;
                  else
                    break;
                }
              }
              if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
              return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
              var len = screenPos - lastSplit;
              for (var i = lastSplit; i < screenPos; i++) {
                var ch = tokens[i];
                if (ch === 12 || ch === 2)
                  len -= 1;
              }
              if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
              }
              lastDocSplit += len;
              splits.push(lastDocSplit);
              lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
              var split = lastSplit + wrapLimit - indent;
              if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
              }
              if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                  if (tokens[split] == PLACEHOLDER_START) {
                    break;
                  }
                }
                if (split > lastSplit) {
                  addSplit(split);
                  continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                  if (tokens[split] != PLACEHOLDER_BODY) {
                    break;
                  }
                }
                if (split == tokens.length) {
                  break;
                }
                addSplit(split);
                continue;
              }
              var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
              while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
              }
              if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                  split--;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                  split--;
                }
              } else {
                while (split > minSplit && tokens[split] < SPACE) {
                  split--;
                }
              }
              if (split > minSplit) {
                addSplit(++split);
                continue;
              }
              split = lastSplit + wrapLimit;
              if (tokens[split] == CHAR_EXT)
                split--;
              addSplit(split - indent);
            }
            return splits;
          };
          EditSession2.prototype.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;
            for (var i = 0; i < str.length; i++) {
              var c = str.charCodeAt(i);
              if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                  arr.push(TAB_SPACE);
                }
              } else if (c == 32) {
                arr.push(SPACE);
              } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                arr.push(PUNCTUATION);
              } else if (c >= 4352 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
              } else {
                arr.push(CHAR);
              }
            }
            return arr;
          };
          EditSession2.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
              return [0, 0];
            if (maxScreenColumn == null)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column < str.length; column++) {
              c = str.charCodeAt(column);
              if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else if (c >= 4352 && isFullWidth(c)) {
                screenColumn += 2;
              } else {
                screenColumn += 1;
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
          EditSession2.prototype.getRowLength = function(row) {
            var h = 1;
            if (this.lineWidgets)
              h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            if (!this.$useWrapMode || !this.$wrapData[row])
              return h;
            else
              return this.$wrapData[row].length + h;
          };
          EditSession2.prototype.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1;
            } else {
              return this.$wrapData[row].length + 1;
            }
          };
          EditSession2.prototype.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
              var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
              var splits = this.$wrapData[pos.row];
              return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
              return 0;
            }
          };
          EditSession2.prototype.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
          };
          EditSession2.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
          };
          EditSession2.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
          };
          EditSession2.prototype.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
              return void 0;
            } else {
              return this.$wrapData[row];
            }
          };
          EditSession2.prototype.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
          };
          EditSession2.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
          };
          EditSession2.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
          };
          EditSession2.prototype.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
              return { row: 0, column: 0 };
            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;
            var rowCache = this.$screenRowCache;
            var i = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var docRow = this.$docRowCache[i];
              var doCache = screenRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row <= screenRow) {
              rowLength = this.getRowLength(docRow);
              if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
              } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                  docRow = foldLine.end.row + 1;
                  foldLine = this.getNextFoldLine(docRow, foldLine);
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
              }
              if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
              }
            }
            if (foldLine && foldLine.start.row <= docRow) {
              line = this.getFoldDisplayLine(foldLine);
              docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
              return {
                row: maxRow,
                column: this.getLine(maxRow).length
              };
            } else {
              line = this.getLine(docRow);
              foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
              var splits = this.$wrapData[docRow];
              if (splits) {
                column = splits[splitIndex];
                if (splitIndex > 0 && splits.length) {
                  wrapIndent = splits.indent;
                  docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                  line = line.substring(docColumn);
                }
              }
            }
            if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
              screenColumn = this.$bidiHandler.offsetToCol(offsetX);
            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
              docColumn = column - 1;
            if (foldLine)
              return foldLine.idxToPosition(docColumn);
            return { row: docRow, column: docColumn };
          };
          EditSession2.prototype.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
              var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
            else
              pos = this.$clipPositionToDocument(docRow, docColumn);
            docRow = pos.row;
            docColumn = pos.column;
            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
              docRow = fold.start.row;
              docColumn = fold.start.column;
            }
            var rowEnd, row = 0;
            var rowCache = this.$docRowCache;
            var i = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var screenRow = this.$screenRowCache[i];
              var doCache = docRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row < docRow) {
              if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                  break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              } else {
                rowEnd = row + 1;
              }
              screenRow += this.getRowLength(row);
              row = rowEnd;
              if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
              }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
              textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
              foldStartRow = foldLine.start.row;
            } else {
              textLine = this.getLine(docRow).substring(0, docColumn);
              foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
              var wrapRow = this.$wrapData[foldStartRow];
              if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                  screenRow++;
                  screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
              }
            }
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
              screenRow += this.lineWidgets[row].rowsAbove;
            return {
              row: screenRow,
              column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
          };
          EditSession2.prototype.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
          };
          EditSession2.prototype.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
          };
          EditSession2.prototype.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
              screenRows = this.getLength();
              var foldData = this.$foldData;
              for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
              }
            } else {
              var lastRow = this.$wrapData.length;
              var row = 0, i = 0;
              var fold = this.$foldData[i++];
              var foldStart = fold ? fold.start.row : Infinity;
              while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row > foldStart) {
                  row = fold.end.row + 1;
                  fold = this.$foldData[i++];
                  foldStart = fold ? fold.start.row : Infinity;
                }
              }
            }
            if (this.lineWidgets)
              screenRows += this.$getWidgetScreenLength();
            return screenRows;
          };
          EditSession2.prototype.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar)
              return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
              if (maxScreenColumn === 0)
                return [0, 0];
              if (!maxScreenColumn)
                maxScreenColumn = Infinity;
              screenColumn = screenColumn || 0;
              var c, column;
              for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                if (c === "	") {
                  screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                  screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                  break;
                }
              }
              return [screenColumn, column];
            };
          };
          EditSession2.prototype.destroy = function() {
            if (!this.destroyed) {
              this.bgTokenizer.setDocument(null);
              this.bgTokenizer.cleanup();
              this.destroyed = true;
            }
            this.$stopWorker();
            this.removeAllListeners();
            if (this.doc) {
              this.doc.off("change", this.$onChange);
            }
            this.selection.detach();
          };
          return EditSession2;
        }()
      );
      EditSession.$uid = 0;
      EditSession.prototype.$modes = config.$modes;
      EditSession.prototype.getValue = EditSession.prototype.toString;
      EditSession.prototype.$defaultUndoManager = {
        undo: function() {
        },
        redo: function() {
        },
        hasUndo: function() {
        },
        hasRedo: function() {
        },
        reset: function() {
        },
        add: function() {
        },
        addSelection: function() {
        },
        startNewGroup: function() {
        },
        addSession: function() {
        }
      };
      EditSession.prototype.$overwrite = false;
      EditSession.prototype.$mode = null;
      EditSession.prototype.$modeId = null;
      EditSession.prototype.$scrollTop = 0;
      EditSession.prototype.$scrollLeft = 0;
      EditSession.prototype.$wrapLimit = 80;
      EditSession.prototype.$useWrapMode = false;
      EditSession.prototype.$wrapLimitRange = {
        min: null,
        max: null
      };
      EditSession.prototype.lineWidgets = null;
      EditSession.prototype.isFullWidth = isFullWidth;
      oop.implement(EditSession.prototype, EventEmitter);
      var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
      function isFullWidth(c) {
        if (c < 4352)
          return false;
        return c >= 4352 && c <= 4447 || c >= 4515 && c <= 4519 || c >= 4602 && c <= 4607 || c >= 9001 && c <= 9002 || c >= 11904 && c <= 11929 || c >= 11931 && c <= 12019 || c >= 12032 && c <= 12245 || c >= 12272 && c <= 12283 || c >= 12288 && c <= 12350 || c >= 12353 && c <= 12438 || c >= 12441 && c <= 12543 || c >= 12549 && c <= 12589 || c >= 12593 && c <= 12686 || c >= 12688 && c <= 12730 || c >= 12736 && c <= 12771 || c >= 12784 && c <= 12830 || c >= 12832 && c <= 12871 || c >= 12880 && c <= 13054 || c >= 13056 && c <= 19903 || c >= 19968 && c <= 42124 || c >= 42128 && c <= 42182 || c >= 43360 && c <= 43388 || c >= 44032 && c <= 55203 || c >= 55216 && c <= 55238 || c >= 55243 && c <= 55291 || c >= 63744 && c <= 64255 || c >= 65040 && c <= 65049 || c >= 65072 && c <= 65106 || c >= 65108 && c <= 65126 || c >= 65128 && c <= 65131 || c >= 65281 && c <= 65376 || c >= 65504 && c <= 65510;
      }
      require2("./edit_session/folding").Folding.call(EditSession.prototype);
      require2("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function(value) {
            if (!value || value == "off")
              value = false;
            else if (value == "free")
              value = true;
            else if (value == "printMargin")
              value = -1;
            else if (typeof value == "string")
              value = parseInt(value, 10) || false;
            if (this.$wrap == value)
              return;
            this.$wrap = value;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
          },
          get: function() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1)
                return "printMargin";
              if (!this.getWrapLimitRange().min)
                return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
              }
            }
          },
          initialValue: "auto"
        },
        indentedSoftWrap: {
          set: function() {
            if (this.$useWrapMode) {
              this.$useWrapMode = false;
              this.setUseWrapMode(true);
            }
          },
          initialValue: true
        },
        firstLineNumber: {
          set: function() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
              this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: { initialValue: true },
        tabSize: {
          set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
              this.$modified = true;
              this.$rowLengthCache = [];
              this.$tabSize = tabSize;
              this._signal("changeTabSize");
            }
          },
          initialValue: 4,
          handlesSet: true
        },
        navigateWithinSoftTabs: { initialValue: false },
        foldStyle: {
          set: function(val) {
            this.setFoldStyle(val);
          },
          handlesSet: true
        },
        overwrite: {
          set: function(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function(val) {
            this.doc.setNewLineMode(val);
          },
          get: function() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function(val) {
            this.setMode(val);
          },
          get: function() {
            return this.$modeId;
          },
          handlesSet: true
        }
      });
      exports2.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var lang = require2("./lib/lang");
      var oop = require2("./lib/oop");
      var Range = require2("./range").Range;
      var Search = (
        /** @class */
        function() {
          function Search2() {
            this.$options = {};
          }
          Search2.prototype.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
          };
          Search2.prototype.getOptions = function() {
            return lang.copyObject(this.$options);
          };
          Search2.prototype.setOptions = function(options) {
            this.$options = options;
          };
          Search2.prototype.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
              return false;
            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
              firstRange = new Range(sr, sc, er, ec);
              if (sc == ec && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                firstRange = null;
                return false;
              }
              return true;
            });
            return firstRange;
          };
          Search2.prototype.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
              return [];
            this.$assembleRegExp(options);
            var range = options.range;
            var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
            var ranges = [];
            var re = options.re;
            if (options.$isMultiLine) {
              var len = re.length;
              var maxRow = lines.length - len;
              var prevRange;
              outer:
                for (var row = re.offset || 0; row <= maxRow; row++) {
                  for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                      continue outer;
                  var startLine = lines[row];
                  var line = lines[row + len - 1];
                  var startIndex = startLine.length - startLine.match(re[0])[0].length;
                  var endIndex = line.match(re[len - 1])[0].length;
                  if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                    continue;
                  }
                  ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                  if (len > 2)
                    row = row + len - 2;
                }
            } else {
              for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                  var match = matches[j];
                  ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
              }
            }
            if (range) {
              var startColumn = range.start.column;
              var endColumn = range.end.column;
              var i = 0, j = ranges.length - 1;
              while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
                i++;
              var endRow = range.end.row - range.start.row;
              while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
                j--;
              ranges = ranges.slice(i, j + 1);
              for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
              }
            }
            return ranges;
          };
          Search2.prototype.replace = function(input, replacement) {
            var options = this.$options;
            var re = this.$assembleRegExp(options);
            if (options.$isMultiLine)
              return replacement;
            if (!re)
              return;
            var match = re.exec(input);
            if (!match || match[0].length != input.length)
              return null;
            replacement = input.replace(re, replacement);
            if (options.preserveCase) {
              replacement = replacement.split("");
              for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                  replacement[i] = replacement[i].toUpperCase();
                else
                  replacement[i] = replacement[i].toLowerCase();
              }
              replacement = replacement.join("");
            }
            return replacement;
          };
          Search2.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
              return options.re = options.needle;
            var needle = options.needle;
            if (!options.needle)
              return options.re = false;
            if (!options.regExp)
              needle = lang.escapeRegExp(needle);
            var modifier = options.caseSensitive ? "gm" : "gmi";
            try {
              new RegExp(needle, "u");
              options.$supportsUnicodeFlag = true;
              modifier += "u";
            } catch (e) {
              options.$supportsUnicodeFlag = false;
            }
            if (options.wholeWord)
              needle = addWordBoundary(needle, options);
            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
              return options.re = this.$assembleMultilineRegExp(needle, modifier);
            try {
              var re = new RegExp(needle, modifier);
            } catch (e) {
              re = false;
            }
            return options.re = re;
          };
          Search2.prototype.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re = [];
            for (var i = 0; i < parts.length; i++)
              try {
                re.push(new RegExp(parts[i], modifier));
              } catch (e) {
                return false;
              }
            return re;
          };
          Search2.prototype.$matchIterator = function(session, options) {
            var re = this.$assembleRegExp(options);
            if (!re)
              return false;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;
            var supportsUnicodeFlag = re.unicode;
            var range = options.range;
            var start = options.start;
            if (!start)
              start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
            if (start.start)
              start = start[skipCurrent != backwards ? "end" : "start"];
            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            if (backwards) {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row--; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
              };
            } else {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row = row + 1; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
              };
            }
            if (options.$isMultiLine) {
              var len = re.length;
              var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength())
                  return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1)
                  return;
                for (var i = 1; i < len; i++) {
                  line = session.getLine(startRow + i);
                  if (line.search(re[i]) == -1)
                    return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset)
                  return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                  return true;
              };
            } else if (backwards) {
              var forEachInLine = function(row, endIndex, callback) {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while (m = re.exec(line)) {
                  var length = m[0].length;
                  last = m.index;
                  if (!length) {
                    if (last >= line.length)
                      break;
                    re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                  }
                  if (m.index + length > endIndex)
                    break;
                  matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i >= 0; i -= 2) {
                  var column = matches[i - 1];
                  var length = matches[i];
                  if (callback(row, column, row, column + length))
                    return true;
                }
              };
            } else {
              var forEachInLine = function(row, startIndex, callback) {
                var line = session.getLine(row);
                var last;
                var m;
                re.lastIndex = startIndex;
                while (m = re.exec(line)) {
                  var length = m[0].length;
                  last = m.index;
                  if (callback(row, last, row, last + length))
                    return true;
                  if (!length) {
                    re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                    if (last >= line.length)
                      return false;
                  }
                }
              };
            }
            return { forEach };
          };
          return Search2;
        }()
      );
      function addWordBoundary(needle, options) {
        var supportsLookbehind = lang.supportsLookbehind();
        function wordBoundary(c, firstChar2) {
          if (firstChar2 === void 0) {
            firstChar2 = true;
          }
          var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
          if (wordRegExp.test(c) || options.regExp) {
            if (supportsLookbehind && options.$supportsUnicodeFlag) {
              if (firstChar2)
                return "(?<=^|[^\\p{L}\\p{N}_])";
              return "(?=[^\\p{L}\\p{N}_]|$)";
            }
            return "\\b";
          }
          return "";
        }
        var needleArray = Array.from(needle);
        var firstChar = needleArray[0];
        var lastChar = needleArray[needleArray.length - 1];
        return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
      }
      exports2.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var keyUtil = require2("../lib/keys");
      var useragent = require2("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      var MultiHashHandler = (
        /** @class */
        function() {
          function MultiHashHandler2(config, platform) {
            this.$init(config, platform, false);
          }
          MultiHashHandler2.prototype.$init = function(config, platform, $singleCommand) {
            this.platform = platform || (useragent.isMac ? "mac" : "win");
            this.commands = {};
            this.commandKeyBinding = {};
            this.addCommands(config);
            this.$singleCommand = $singleCommand;
          };
          MultiHashHandler2.prototype.addCommand = function(command) {
            if (this.commands[command.name])
              this.removeCommand(command);
            this.commands[command.name] = command;
            if (command.bindKey)
              this._buildKeyHash(command);
          };
          MultiHashHandler2.prototype.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === "string" ? command : command.name);
            command = this.commands[name];
            if (!keepCommand)
              delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for (var keyId in ckb) {
              var cmdGroup = ckb[keyId];
              if (cmdGroup == command) {
                delete ckb[keyId];
              } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                  cmdGroup.splice(i, 1);
                  if (cmdGroup.length == 1)
                    ckb[keyId] = cmdGroup[0];
                }
              }
            }
          };
          MultiHashHandler2.prototype.bindKey = function(key, command, position) {
            if (typeof key == "object" && key) {
              if (position == void 0)
                position = key.position;
              key = key[this.platform];
            }
            if (!key)
              return;
            if (typeof command == "function")
              return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
            key.split("|").forEach(function(keyPart) {
              var chain = "";
              if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart2) {
                  var binding2 = this.parseKeys(keyPart2);
                  var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                  chain += (chain ? " " : "") + id2;
                  this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
              }
              var binding = this.parseKeys(keyPart);
              var id = KEY_MODS[binding.hashId] + binding.key;
              this._addCommandToBinding(chain + id, command, position);
            }, this);
          };
          MultiHashHandler2.prototype._addCommandToBinding = function(keyId, command, position) {
            var ckb = this.commandKeyBinding, i;
            if (!command) {
              delete ckb[keyId];
            } else if (!ckb[keyId] || this.$singleCommand) {
              ckb[keyId] = command;
            } else {
              if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
              } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
              }
              if (typeof position != "number") {
                position = getPosition(command);
              }
              var commands = ckb[keyId];
              for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                  break;
              }
              commands.splice(i, 0, command);
            }
          };
          MultiHashHandler2.prototype.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
              var command = commands[name];
              if (!command)
                return;
              if (typeof command === "string")
                return this.bindKey(command, name);
              if (typeof command === "function")
                command = { exec: command };
              if (typeof command !== "object")
                return;
              if (!command.name)
                command.name = name;
              this.addCommand(command);
            }, this);
          };
          MultiHashHandler2.prototype.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
              this.removeCommand(commands[name]);
            }, this);
          };
          MultiHashHandler2.prototype.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
              this.bindKey(key, keyList[key]);
            }, this);
          };
          MultiHashHandler2.prototype._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
          };
          MultiHashHandler2.prototype.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
              return x;
            });
            var key = parts.pop();
            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode])
              key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length)
              return { key, hashId: -1 };
            else if (parts.length == 1 && parts[0] == "shift")
              return { key: key.toUpperCase(), hashId: -1 };
            var hashId = 0;
            for (var i = parts.length; i--; ) {
              var modifier = keyUtil.KEY_MODS[parts[i]];
              if (modifier == null) {
                if (typeof console != "undefined")
                  console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
              }
              hashId |= modifier;
            }
            return { key, hashId };
          };
          MultiHashHandler2.prototype.findKeyCommand = function(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
          };
          MultiHashHandler2.prototype.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0)
              return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
              data.$keyChain += " " + key;
              command = this.commandKeyBinding[data.$keyChain] || command;
            }
            if (command) {
              if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return { command: "null" };
              }
            }
            if (data.$keyChain) {
              if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
              else if (hashId == -1 || keyCode > 0)
                data.$keyChain = "";
            }
            return { command };
          };
          MultiHashHandler2.prototype.getStatusText = function(editor, data) {
            return data.$keyChain || "";
          };
          return MultiHashHandler2;
        }()
      );
      function getPosition(command) {
        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
      }
      var HashHandler = (
        /** @class */
        function(_super) {
          __extends(HashHandler2, _super);
          function HashHandler2(config, platform) {
            var _this = _super.call(this, config, platform) || this;
            _this.$singleCommand = true;
            return _this;
          }
          return HashHandler2;
        }(MultiHashHandler)
      );
      HashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
      };
      MultiHashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
      };
      exports2.HashHandler = HashHandler;
      exports2.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var oop = require2("../lib/oop");
      var MultiHashHandler = require2("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CommandManager = (
        /** @class */
        function(_super) {
          __extends(CommandManager2, _super);
          function CommandManager2(platform, commands) {
            var _this = _super.call(this, commands, platform) || this;
            _this.byName = _this.commands;
            _this.setDefaultHandler("exec", function(e) {
              if (!e.args) {
                return e.command.exec(e.editor, {}, e.event, true);
              }
              return e.command.exec(e.editor, e.args, e.event, false);
            });
            return _this;
          }
          CommandManager2.prototype.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
              for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args))
                  return true;
              }
              return false;
            }
            if (typeof command === "string")
              command = this.commands[command];
            if (!command)
              return false;
            if (editor && editor.$readOnly && !command.readOnly)
              return false;
            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
              return false;
            var e = { editor, command, args };
            e.returnValue = this._emit("exec", e);
            this._signal("afterExec", e);
            return e.returnValue === false ? false : true;
          };
          CommandManager2.prototype.toggleRecording = function(editor) {
            if (this.$inReplay)
              return;
            editor && editor._emit("changeStatus");
            if (this.recording) {
              this.macro.pop();
              this.off("exec", this.$addCommandToMacro);
              if (!this.macro.length)
                this.macro = this.oldMacro;
              return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
              this.$addCommandToMacro = (function(e) {
                this.macro.push([e.command, e.args]);
              }).bind(this);
            }
            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
          };
          CommandManager2.prototype.replay = function(editor) {
            if (this.$inReplay || !this.macro)
              return;
            if (this.recording)
              return this.toggleRecording(editor);
            try {
              this.$inReplay = true;
              this.macro.forEach(function(x) {
                if (typeof x == "string")
                  this.exec(x, editor);
                else
                  this.exec(x[0], editor, x[1]);
              }, this);
            } finally {
              this.$inReplay = false;
            }
          };
          CommandManager2.prototype.trimMacro = function(m) {
            return m.map(function(x) {
              if (typeof x[0] != "string")
                x[0] = x[0].name;
              if (!x[1])
                x = x[0];
              return x;
            });
          };
          return CommandManager2;
        }(MultiHashHandler)
      );
      oop.implement(CommandManager.prototype, EventEmitter);
      exports2.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var lang = require2("../lib/lang");
      var config = require2("../config");
      var Range = require2("../range").Range;
      function bindKey(win, mac) {
        return { win, mac };
      }
      exports2.commands = [
        {
          name: "showSettingsMenu",
          description: "Show settings menu",
          bindKey: bindKey("Ctrl-,", "Command-,"),
          exec: function(editor) {
            config.loadModule("ace/ext/settings_menu", function(module3) {
              module3.init(editor);
              editor.showSettingsMenu();
            });
          },
          readOnly: true
        },
        {
          name: "goToNextError",
          description: "Go to next error",
          bindKey: bindKey("Alt-E", "F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module3) {
              module3.showErrorMarker(editor, 1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "goToPreviousError",
          description: "Go to previous error",
          bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module3) {
              module3.showErrorMarker(editor, -1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selectall",
          description: "Select all",
          bindKey: bindKey("Ctrl-A", "Command-A"),
          exec: function(editor) {
            editor.selectAll();
          },
          readOnly: true
        },
        {
          name: "centerselection",
          description: "Center selection",
          bindKey: bindKey(null, "Ctrl-L"),
          exec: function(editor) {
            editor.centerSelection();
          },
          readOnly: true
        },
        {
          name: "gotoline",
          description: "Go to line...",
          bindKey: bindKey("Ctrl-L", "Command-L"),
          exec: function(editor, line) {
            if (typeof line === "number" && !isNaN(line))
              editor.gotoLine(line);
            editor.prompt({ $type: "gotoLine" });
          },
          readOnly: true
        },
        {
          name: "fold",
          bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
          exec: function(editor) {
            editor.session.toggleFold(false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfold",
          bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
          exec: function(editor) {
            editor.session.toggleFold(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleFoldWidget",
          description: "Toggle fold widget",
          bindKey: bindKey("F2", "F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleParentFoldWidget",
          description: "Toggle parent fold widget",
          bindKey: bindKey("Alt-F2", "Alt-F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldall",
          description: "Fold all",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldAllComments",
          description: "Fold all comments",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAllComments();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldOther",
          description: "Fold other",
          bindKey: bindKey("Alt-0", "Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfoldall",
          description: "Unfold all",
          bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
          exec: function(editor) {
            editor.session.unfold();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findnext",
          description: "Find next",
          bindKey: bindKey("Ctrl-K", "Command-G"),
          exec: function(editor) {
            editor.findNext();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findprevious",
          description: "Find previous",
          bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
          exec: function(editor) {
            editor.findPrevious();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "selectOrFindNext",
          description: "Select or find next",
          bindKey: bindKey("Alt-K", "Ctrl-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findNext();
          },
          readOnly: true
        },
        {
          name: "selectOrFindPrevious",
          description: "Select or find previous",
          bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findPrevious();
          },
          readOnly: true
        },
        {
          name: "find",
          description: "Find",
          bindKey: bindKey("Ctrl-F", "Command-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {
              e.Search(editor);
            });
          },
          readOnly: true
        },
        {
          name: "overwrite",
          description: "Overwrite",
          bindKey: "Insert",
          exec: function(editor) {
            editor.toggleOverwrite();
          },
          readOnly: true
        },
        {
          name: "selecttostart",
          description: "Select to start",
          bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
          exec: function(editor) {
            editor.getSelection().selectFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotostart",
          description: "Go to start",
          bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
          exec: function(editor) {
            editor.navigateFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectup",
          description: "Select up",
          bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
          exec: function(editor) {
            editor.getSelection().selectUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golineup",
          description: "Go line up",
          bindKey: bindKey("Up", "Up|Ctrl-P"),
          exec: function(editor, args) {
            editor.navigateUp(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttoend",
          description: "Select to end",
          bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
          exec: function(editor) {
            editor.getSelection().selectFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotoend",
          description: "Go to end",
          bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
          exec: function(editor) {
            editor.navigateFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectdown",
          description: "Select down",
          bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
          exec: function(editor) {
            editor.getSelection().selectDown();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golinedown",
          description: "Go line down",
          bindKey: bindKey("Down", "Down|Ctrl-N"),
          exec: function(editor, args) {
            editor.navigateDown(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordleft",
          description: "Select word left",
          bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
          exec: function(editor) {
            editor.getSelection().selectWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordleft",
          description: "Go to word left",
          bindKey: bindKey("Ctrl-Left", "Option-Left"),
          exec: function(editor) {
            editor.navigateWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolinestart",
          description: "Select to line start",
          bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolinestart",
          description: "Go to line start",
          bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
          exec: function(editor) {
            editor.navigateLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectleft",
          description: "Select left",
          bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
          exec: function(editor) {
            editor.getSelection().selectLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoleft",
          description: "Go to left",
          bindKey: bindKey("Left", "Left|Ctrl-B"),
          exec: function(editor, args) {
            editor.navigateLeft(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordright",
          description: "Select word right",
          bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordright",
          description: "Go to word right",
          bindKey: bindKey("Ctrl-Right", "Option-Right"),
          exec: function(editor) {
            editor.navigateWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolineend",
          description: "Select to line end",
          bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolineend",
          description: "Go to line end",
          bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
          exec: function(editor) {
            editor.navigateLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectright",
          description: "Select right",
          bindKey: bindKey("Shift-Right", "Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoright",
          description: "Go to right",
          bindKey: bindKey("Right", "Right|Ctrl-F"),
          exec: function(editor, args) {
            editor.navigateRight(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectpagedown",
          description: "Select page down",
          bindKey: "Shift-PageDown",
          exec: function(editor) {
            editor.selectPageDown();
          },
          readOnly: true
        },
        {
          name: "pagedown",
          description: "Page down",
          bindKey: bindKey(null, "Option-PageDown"),
          exec: function(editor) {
            editor.scrollPageDown();
          },
          readOnly: true
        },
        {
          name: "gotopagedown",
          description: "Go to page down",
          bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
          exec: function(editor) {
            editor.gotoPageDown();
          },
          readOnly: true
        },
        {
          name: "selectpageup",
          description: "Select page up",
          bindKey: "Shift-PageUp",
          exec: function(editor) {
            editor.selectPageUp();
          },
          readOnly: true
        },
        {
          name: "pageup",
          description: "Page up",
          bindKey: bindKey(null, "Option-PageUp"),
          exec: function(editor) {
            editor.scrollPageUp();
          },
          readOnly: true
        },
        {
          name: "gotopageup",
          description: "Go to page up",
          bindKey: "PageUp",
          exec: function(editor) {
            editor.gotoPageUp();
          },
          readOnly: true
        },
        {
          name: "scrollup",
          description: "Scroll up",
          bindKey: bindKey("Ctrl-Up", null),
          exec: function(e) {
            e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "scrolldown",
          description: "Scroll down",
          bindKey: bindKey("Ctrl-Down", null),
          exec: function(e) {
            e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "selectlinestart",
          description: "Select line start",
          bindKey: "Shift-Home",
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectlineend",
          description: "Select line end",
          bindKey: "Shift-End",
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "togglerecording",
          description: "Toggle recording",
          bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
          exec: function(editor) {
            editor.commands.toggleRecording(editor);
          },
          readOnly: true
        },
        {
          name: "replaymacro",
          description: "Replay macro",
          bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
          exec: function(editor) {
            editor.commands.replay(editor);
          },
          readOnly: true
        },
        {
          name: "jumptomatching",
          description: "Jump to matching",
          bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
          exec: function(editor) {
            editor.jumpToMatching();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selecttomatching",
          description: "Select to matching",
          bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
          exec: function(editor) {
            editor.jumpToMatching(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "expandToMatching",
          description: "Expand to matching",
          bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
          exec: function(editor) {
            editor.jumpToMatching(true, true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "passKeysToBrowser",
          description: "Pass keys to browser",
          bindKey: bindKey(null, null),
          exec: function() {
          },
          passEvent: true,
          readOnly: true
        },
        {
          name: "copy",
          description: "Copy",
          exec: function(editor) {
          },
          readOnly: true
        },
        {
          name: "cut",
          description: "Cut",
          exec: function(editor) {
            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit("cut", range);
            if (!range.isEmpty())
              editor.session.remove(range);
            editor.clearSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "paste",
          description: "Paste",
          exec: function(editor, args) {
            editor.$handlePaste(args);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "removeline",
          description: "Remove line",
          bindKey: bindKey("Ctrl-D", "Command-D"),
          exec: function(editor) {
            editor.removeLines();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEachLine"
        },
        {
          name: "duplicateSelection",
          description: "Duplicate selection",
          bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
          exec: function(editor) {
            editor.duplicateSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "sortlines",
          description: "Sort lines",
          bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
          exec: function(editor) {
            editor.sortLines();
          },
          scrollIntoView: "selection",
          multiSelectAction: "forEachLine"
        },
        {
          name: "togglecomment",
          description: "Toggle comment",
          bindKey: bindKey("Ctrl-/", "Command-/"),
          exec: function(editor) {
            editor.toggleCommentLines();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "toggleBlockComment",
          description: "Toggle block comment",
          bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
          exec: function(editor) {
            editor.toggleBlockComment();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "modifyNumberUp",
          description: "Modify number up",
          bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
          exec: function(editor) {
            editor.modifyNumber(1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "modifyNumberDown",
          description: "Modify number down",
          bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
          exec: function(editor) {
            editor.modifyNumber(-1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "replace",
          description: "Replace",
          bindKey: bindKey("Ctrl-H", "Command-Option-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {
              e.Search(editor, true);
            });
          }
        },
        {
          name: "undo",
          description: "Undo",
          bindKey: bindKey("Ctrl-Z", "Command-Z"),
          exec: function(editor) {
            editor.undo();
          }
        },
        {
          name: "redo",
          description: "Redo",
          bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
          exec: function(editor) {
            editor.redo();
          }
        },
        {
          name: "copylinesup",
          description: "Copy lines up",
          bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
          exec: function(editor) {
            editor.copyLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesup",
          description: "Move lines up",
          bindKey: bindKey("Alt-Up", "Option-Up"),
          exec: function(editor) {
            editor.moveLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "copylinesdown",
          description: "Copy lines down",
          bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
          exec: function(editor) {
            editor.copyLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesdown",
          description: "Move lines down",
          bindKey: bindKey("Alt-Down", "Option-Down"),
          exec: function(editor) {
            editor.moveLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "del",
          description: "Delete",
          bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
          exec: function(editor) {
            editor.remove("right");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "backspace",
          description: "Backspace",
          bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
          exec: function(editor) {
            editor.remove("left");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "cut_or_delete",
          description: "Cut or delete",
          bindKey: bindKey("Shift-Delete", null),
          exec: function(editor) {
            if (editor.selection.isEmpty()) {
              editor.remove("left");
            } else {
              return false;
            }
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestart",
          description: "Remove to line start",
          bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
          exec: function(editor) {
            editor.removeToLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineend",
          description: "Remove to line end",
          bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
          exec: function(editor) {
            editor.removeToLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestarthard",
          description: "Remove to line start hard",
          bindKey: bindKey("Ctrl-Shift-Backspace", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineendhard",
          description: "Remove to line end hard",
          bindKey: bindKey("Ctrl-Shift-Delete", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordleft",
          description: "Remove word left",
          bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
          exec: function(editor) {
            editor.removeWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordright",
          description: "Remove word right",
          bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
          exec: function(editor) {
            editor.removeWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "outdent",
          description: "Outdent",
          bindKey: bindKey("Shift-Tab", "Shift-Tab"),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "indent",
          description: "Indent",
          bindKey: bindKey("Tab", "Tab"),
          exec: function(editor) {
            editor.indent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockoutdent",
          description: "Block outdent",
          bindKey: bindKey("Ctrl-[", "Ctrl-["),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockindent",
          description: "Block indent",
          bindKey: bindKey("Ctrl-]", "Ctrl-]"),
          exec: function(editor) {
            editor.blockIndent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "insertstring",
          description: "Insert string",
          exec: function(editor, str) {
            editor.insert(str);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "inserttext",
          description: "Insert text",
          exec: function(editor, args) {
            editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "splitline",
          description: "Split line",
          bindKey: bindKey(null, "Ctrl-O"),
          exec: function(editor) {
            editor.splitLine();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "transposeletters",
          description: "Transpose letters",
          bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
          exec: function(editor) {
            editor.transposeLetters();
          },
          multiSelectAction: function(editor) {
            editor.transposeSelections(1);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "touppercase",
          description: "To uppercase",
          bindKey: bindKey("Ctrl-U", "Ctrl-U"),
          exec: function(editor) {
            editor.toUpperCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "tolowercase",
          description: "To lowercase",
          bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
          exec: function(editor) {
            editor.toLowerCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "autoindent",
          description: "Auto Indent",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.autoIndent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "animate"
        },
        {
          name: "expandtoline",
          description: "Expand to line",
          bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "openlink",
          bindKey: bindKey("Ctrl+F3", "F3"),
          exec: function(editor) {
            editor.openLink();
          }
        },
        {
          name: "joinlines",
          description: "Join lines",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);
            for (var i2 = selectionStart.row + 1; i2 <= selectionEnd.row + 1; i2++) {
              var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i2)));
              if (curLine.length !== 0) {
                curLine = " " + curLine;
              }
              insertLine += curLine;
            }
            if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
              insertLine += editor.session.doc.getNewLineCharacter();
            }
            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
            if (selectedCount > 0) {
              editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
              editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            } else {
              firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
              editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
          },
          multiSelectAction: "forEach",
          readOnly: true
        },
        {
          name: "invertSelection",
          description: "Invert selection",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
              ranges = [editor.selection.getRange()];
            }
            for (var i2 = 0; i2 < ranges.length; i2++) {
              if (i2 == ranges.length - 1) {
                if (!(ranges[i2].end.row === endRow && ranges[i2].end.column === endCol)) {
                  newRanges.push(new Range(ranges[i2].end.row, ranges[i2].end.column, endRow, endCol));
                }
              }
              if (i2 === 0) {
                if (!(ranges[i2].start.row === 0 && ranges[i2].start.column === 0)) {
                  newRanges.push(new Range(0, 0, ranges[i2].start.row, ranges[i2].start.column));
                }
              } else {
                newRanges.push(new Range(ranges[i2 - 1].end.row, ranges[i2 - 1].end.column, ranges[i2].start.row, ranges[i2].start.column));
              }
            }
            editor.exitMultiSelectMode();
            editor.clearSelection();
            for (var i2 = 0; i2 < newRanges.length; i2++) {
              editor.selection.addRange(newRanges[i2], false);
            }
          },
          readOnly: true,
          scrollIntoView: "none"
        },
        {
          name: "addLineAfter",
          description: "Add new line after the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert("\n");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "addLineBefore",
          description: "Add new line before the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert("\n");
            if (cursor.row === 0)
              editor.navigateUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "openCommandPallete",
          exec: function(editor) {
            console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
            editor.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "openCommandPalette",
          description: "Open command palette",
          bindKey: bindKey("F1", "F1"),
          exec: function(editor) {
            editor.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "modeSelect",
          description: "Change language mode...",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.prompt({ $type: "modes" });
          },
          readOnly: true
        }
      ];
      for (var i = 1; i < 9; i++) {
        exports2.commands.push({
          name: "foldToLevel" + i,
          description: "Fold To Level " + i,
          level: i,
          exec: function(editor) {
            editor.session.foldToLevel(this.level);
          },
          scrollIntoView: "center",
          readOnly: true
        });
      }
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("./lib/dom");
      var LineWidgets = (
        /** @class */
        function() {
          function LineWidgets2(session) {
            this.session = session;
            this.session.widgetManager = this;
            this.session.getRowLength = this.getRowLength;
            this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
            this.updateOnChange = this.updateOnChange.bind(this);
            this.renderWidgets = this.renderWidgets.bind(this);
            this.measureWidgets = this.measureWidgets.bind(this);
            this.session._changedWidgets = [];
            this.$onChangeEditor = this.$onChangeEditor.bind(this);
            this.session.on("change", this.updateOnChange);
            this.session.on("changeFold", this.updateOnFold);
            this.session.on("changeEditor", this.$onChangeEditor);
          }
          LineWidgets2.prototype.getRowLength = function(row) {
            var h;
            if (this.lineWidgets)
              h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else
              h = 0;
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1 + h;
            } else {
              return this.$wrapData[row].length + 1 + h;
            }
          };
          LineWidgets2.prototype.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w) {
              if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
            });
            return screenRows;
          };
          LineWidgets2.prototype.$onChangeEditor = function(e) {
            this.attach(e.editor);
          };
          LineWidgets2.prototype.attach = function(editor) {
            if (editor && editor.widgetManager && editor.widgetManager != this)
              editor.widgetManager.detach();
            if (this.editor == editor)
              return;
            this.detach();
            this.editor = editor;
            if (editor) {
              editor.widgetManager = this;
              editor.renderer.on("beforeRender", this.measureWidgets);
              editor.renderer.on("afterRender", this.renderWidgets);
            }
          };
          LineWidgets2.prototype.detach = function(e) {
            var editor = this.editor;
            if (!editor)
              return;
            this.editor = null;
            editor.widgetManager = null;
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w) {
              if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
              }
            });
          };
          LineWidgets2.prototype.updateOnFold = function(e, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e.action)
              return;
            var fold = e.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e.action == "add";
            for (var i = start + 1; i < end; i++) {
              if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
            }
            if (lineWidgets[end]) {
              if (hide) {
                if (!lineWidgets[start])
                  lineWidgets[start] = lineWidgets[end];
                else
                  lineWidgets[end].hidden = hide;
              } else {
                if (lineWidgets[start] == lineWidgets[end])
                  lineWidgets[start] = void 0;
                lineWidgets[end].hidden = hide;
              }
            }
          };
          LineWidgets2.prototype.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              var removed = lineWidgets.splice(startRow + 1, len);
              if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
              }
              removed.forEach(function(w) {
                w && this.removeLineWidget(w);
              }, this);
              this.$updateRows();
            } else {
              var args = new Array(len);
              if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                  startRow++;
              }
              args.unshift(startRow, 0);
              lineWidgets.splice.apply(lineWidgets, args);
              this.$updateRows();
            }
          };
          LineWidgets2.prototype.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var noWidgets = true;
            lineWidgets.forEach(function(w, i) {
              if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                  w.$oldWidget.row = i;
                  w = w.$oldWidget;
                }
              }
            });
            if (noWidgets)
              this.session.lineWidgets = null;
          };
          LineWidgets2.prototype.$registerLineWidget = function(w) {
            if (!this.session.lineWidgets)
              this.session.lineWidgets = new Array(this.session.getLength());
            var old = this.session.lineWidgets[w.row];
            if (old) {
              w.$oldWidget = old;
              if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
              }
            }
            this.session.lineWidgets[w.row] = w;
            return w;
          };
          LineWidgets2.prototype.addLineWidget = function(w) {
            this.$registerLineWidget(w);
            w.session = this.session;
            if (!this.editor)
              return w;
            var renderer = this.editor.renderer;
            if (w.html && !w.el) {
              w.el = dom.createElement("div");
              w.el.innerHTML = w.html;
            }
            if (w.text && !w.el) {
              w.el = dom.createElement("div");
              w.el.textContent = w.text;
            }
            if (w.el) {
              dom.addCssClass(w.el, "ace_lineWidgetContainer");
              if (w.className) {
                dom.addCssClass(w.el, w.className);
              }
              w.el.style.position = "absolute";
              w.el.style.zIndex = 5;
              renderer.container.appendChild(w.el);
              w._inDocument = true;
              if (!w.coverGutter) {
                w.el.style.zIndex = 3;
              }
              if (w.pixelHeight == null) {
                w.pixelHeight = w.el.offsetHeight;
              }
            }
            if (w.rowCount == null) {
              w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
            }
            var fold = this.session.getFoldAt(w.row, 0);
            w.$fold = fold;
            if (fold) {
              var lineWidgets = this.session.lineWidgets;
              if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
              else
                w.hidden = true;
            }
            this.session._emit("changeFold", { data: { start: { row: w.row } } });
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w);
            return w;
          };
          LineWidgets2.prototype.removeLineWidget = function(w) {
            w._inDocument = false;
            w.session = null;
            if (w.el && w.el.parentNode)
              w.el.parentNode.removeChild(w.el);
            if (w.editor && w.editor.destroy)
              try {
                w.editor.destroy();
              } catch (e) {
              }
            if (this.session.lineWidgets) {
              var w1 = this.session.lineWidgets[w.row];
              if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                  this.onWidgetChanged(w.$oldWidget);
              } else {
                while (w1) {
                  if (w1.$oldWidget == w) {
                    w1.$oldWidget = w.$oldWidget;
                    break;
                  }
                  w1 = w1.$oldWidget;
                }
              }
            }
            this.session._emit("changeFold", { data: { start: { row: w.row } } });
            this.$updateRows();
          };
          LineWidgets2.prototype.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w = lineWidgets && lineWidgets[row];
            var list = [];
            while (w) {
              list.push(w);
              w = w.$oldWidget;
            }
            return list;
          };
          LineWidgets2.prototype.onWidgetChanged = function(w) {
            this.session._changedWidgets.push(w);
            this.editor && this.editor.renderer.updateFull();
          };
          LineWidgets2.prototype.measureWidgets = function(e, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            if (!changedWidgets || !changedWidgets.length)
              return;
            var min = Infinity;
            for (var i = 0; i < changedWidgets.length; i++) {
              var w = changedWidgets[i];
              if (!w || !w.el)
                continue;
              if (w.session != this.session)
                continue;
              if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                  continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
              }
              w.h = w.el.offsetHeight;
              if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
              }
              var rowCount = w.h / config.lineHeight;
              if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                  rowCount = 0;
              }
              if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                  min = w.row;
              }
            }
            if (min != Infinity) {
              this.session._emit("changeFold", { data: { start: { row: min } } });
              this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
          };
          LineWidgets2.prototype.renderWidgets = function(e, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            while (first > 0 && !lineWidgets[first])
              first--;
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;
            renderer.$cursorLayer.config = config;
            for (var i = first; i <= last; i++) {
              var w = lineWidgets[i];
              if (!w || !w.el)
                continue;
              if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
              }
              if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
              }
              var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
              if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
              w.el.style.top = top - config.offset + "px";
              var left = w.coverGutter ? 0 : renderer.gutterWidth;
              if (!w.fixedWidth)
                left -= renderer.scrollLeft;
              w.el.style.left = left + "px";
              if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
              }
              if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
              } else {
                w.el.style.right = "";
              }
            }
          };
          return LineWidgets2;
        }()
      );
      exports2.LineWidgets = LineWidgets;
    });
    ace.define("ace/keyboard/gutter_handler", ["require", "exports", "module", "ace/lib/keys", "ace/mouse/default_gutter_handler"], function(require2, exports2, module2) {
      "use strict";
      var keys = require2("../lib/keys");
      var GutterTooltip = require2("../mouse/default_gutter_handler").GutterTooltip;
      var GutterKeyboardHandler = (
        /** @class */
        function() {
          function GutterKeyboardHandler2(editor) {
            this.editor = editor;
            this.gutterLayer = editor.renderer.$gutterLayer;
            this.element = editor.renderer.$gutter;
            this.lines = editor.renderer.$gutterLayer.$lines;
            this.activeRowIndex = null;
            this.activeLane = null;
            this.annotationTooltip = new GutterTooltip(this.editor);
          }
          GutterKeyboardHandler2.prototype.addListener = function() {
            this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.addEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.on("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.removeListener = function() {
            this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.off("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.$onGutterKeyDown = function(e) {
            if (this.annotationTooltip.isOpen) {
              e.preventDefault();
              if (e.keyCode === keys["escape"])
                this.annotationTooltip.hideTooltip();
              return;
            }
            if (e.target === this.element) {
              if (e.keyCode != keys["enter"]) {
                return;
              }
              e.preventDefault();
              var row = this.editor.getCursorPosition().row;
              if (!this.editor.isRowVisible(row))
                this.editor.scrollToLine(row, true, true);
              setTimeout((function() {
                var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                var nearestFoldIndex = this.$findNearestFoldWidget(index);
                var nearestAnnotationIndex = this.$findNearestAnnotation(index);
                if (nearestFoldIndex === null && nearestAnnotationIndex === null)
                  return;
                if (nearestFoldIndex === null && nearestAnnotationIndex !== null) {
                  this.activeRowIndex = nearestAnnotationIndex;
                  this.activeLane = "annotation";
                  this.$focusAnnotation(this.activeRowIndex);
                  return;
                }
                if (nearestFoldIndex !== null && nearestAnnotationIndex === null) {
                  this.activeRowIndex = nearestFoldIndex;
                  this.activeLane = "fold";
                  this.$focusFoldWidget(this.activeRowIndex);
                  return;
                }
                if (Math.abs(nearestAnnotationIndex - index) < Math.abs(nearestFoldIndex - index)) {
                  this.activeRowIndex = nearestAnnotationIndex;
                  this.activeLane = "annotation";
                  this.$focusAnnotation(this.activeRowIndex);
                  return;
                } else {
                  this.activeRowIndex = nearestFoldIndex;
                  this.activeLane = "fold";
                  this.$focusFoldWidget(this.activeRowIndex);
                  return;
                }
              }).bind(this), 10);
              return;
            }
            this.$handleGutterKeyboardInteraction(e);
            setTimeout((function() {
              this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e, this));
            }).bind(this), 10);
          };
          GutterKeyboardHandler2.prototype.$handleGutterKeyboardInteraction = function(e) {
            if (e.keyCode === keys["tab"]) {
              e.preventDefault();
              return;
            }
            if (e.keyCode === keys["escape"]) {
              e.preventDefault();
              this.$blurGutter();
              this.element.focus();
              this.lane = null;
              return;
            }
            if (e.keyCode === keys["up"]) {
              e.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetUp();
                  break;
                case "annotation":
                  this.$moveAnnotationUp();
                  break;
              }
              return;
            }
            if (e.keyCode === keys["down"]) {
              e.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetDown();
                  break;
                case "annotation":
                  this.$moveAnnotationDown();
                  break;
              }
              return;
            }
            if (e.keyCode === keys["left"]) {
              e.preventDefault();
              this.$switchLane("annotation");
              return;
            }
            if (e.keyCode === keys["right"]) {
              e.preventDefault();
              this.$switchLane("fold");
              return;
            }
            if (e.keyCode === keys["enter"] || e.keyCode === keys["space"]) {
              e.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "start") {
                    var rowFoldingWidget = this.$rowIndexToRow(this.activeRowIndex);
                    this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);
                    setTimeout((function() {
                      if (this.$rowIndexToRow(this.activeRowIndex) !== rowFoldingWidget) {
                        this.$blurFoldWidget(this.activeRowIndex);
                        this.activeRowIndex = this.$rowToRowIndex(rowFoldingWidget);
                        this.$focusFoldWidget(this.activeRowIndex);
                      }
                    }).bind(this), 10);
                    break;
                  } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end") {
                    break;
                  }
                  return;
                case "annotation":
                  var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
                  var rect = gutterElement.getBoundingClientRect();
                  var style = this.annotationTooltip.getElement().style;
                  style.left = rect.right + "px";
                  style.top = rect.bottom + "px";
                  this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                  break;
              }
              return;
            }
          };
          GutterKeyboardHandler2.prototype.$blurGutter = function() {
            if (this.activeRowIndex !== null) {
              switch (this.activeLane) {
                case "fold":
                  this.$blurFoldWidget(this.activeRowIndex);
                  break;
                case "annotation":
                  this.$blurAnnotation(this.activeRowIndex);
                  break;
              }
            }
            if (this.annotationTooltip.isOpen)
              this.annotationTooltip.hideTooltip();
            return;
          };
          GutterKeyboardHandler2.prototype.$isFoldWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$isAnnotationVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getAnnotation(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$getFoldWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[1];
          };
          GutterKeyboardHandler2.prototype.$getAnnotation = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[2];
          };
          GutterKeyboardHandler2.prototype.$findNearestFoldWidget = function(index) {
            if (this.$isFoldWidgetVisible(index))
              return index;
            var i = 0;
            while (index - i > 0 || index + i < this.lines.getLength() - 1) {
              i++;
              if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))
                return index + i;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$findNearestAnnotation = function(index) {
            if (this.$isAnnotationVisible(index))
              return index;
            var i = 0;
            while (index - i > 0 || index + i < this.lines.getLength() - 1) {
              i++;
              if (index - i >= 0 && this.$isAnnotationVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))
                return index + i;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$focusFoldWidget = function(index) {
            if (index == null)
              return;
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
            foldWidget.focus();
          };
          GutterKeyboardHandler2.prototype.$focusAnnotation = function(index) {
            if (index == null)
              return;
            var annotation = this.$getAnnotation(index);
            annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
            annotation.focus();
          };
          GutterKeyboardHandler2.prototype.$blurFoldWidget = function(index) {
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
            foldWidget.blur();
          };
          GutterKeyboardHandler2.prototype.$blurAnnotation = function(index) {
            var annotation = this.$getAnnotation(index);
            annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
            annotation.blur();
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isFoldWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusFoldWidget(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isFoldWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusFoldWidget(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$switchLane = function(desinationLane) {
            switch (desinationLane) {
              case "annotation":
                if (this.activeLane === "annotation") {
                  break;
                }
                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
                if (annotationIndex == null) {
                  break;
                }
                this.activeLane = "annotation";
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = annotationIndex;
                this.$focusAnnotation(this.activeRowIndex);
                break;
              case "fold":
                if (this.activeLane === "fold") {
                  break;
                }
                var foldWidgetIndex = this.$findNearestFoldWidget(this.activeRowIndex);
                if (foldWidgetIndex == null) {
                  break;
                }
                this.activeLane = "fold";
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = foldWidgetIndex;
                this.$focusFoldWidget(this.activeRowIndex);
                break;
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$rowIndexToRow = function(index) {
            var cell = this.lines.get(index);
            if (cell)
              return cell.row;
            return null;
          };
          GutterKeyboardHandler2.prototype.$rowToRowIndex = function(row) {
            for (var i = 0; i < this.lines.getLength(); i++) {
              var cell = this.lines.get(i);
              if (cell.row == row)
                return i;
            }
            return null;
          };
          return GutterKeyboardHandler2;
        }()
      );
      exports2.GutterKeyboardHandler = GutterKeyboardHandler;
      var GutterKeyboardEvent = (
        /** @class */
        function() {
          function GutterKeyboardEvent2(domEvent, gutterKeyboardHandler) {
            this.gutterKeyboardHandler = gutterKeyboardHandler;
            this.domEvent = domEvent;
          }
          GutterKeyboardEvent2.prototype.getKey = function() {
            return keys.keyCodeToString(this.domEvent.keyCode);
          };
          GutterKeyboardEvent2.prototype.getRow = function() {
            return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
          };
          GutterKeyboardEvent2.prototype.isInAnnotationLane = function() {
            return this.gutterKeyboardHandler.activeLane === "annotation";
          };
          GutterKeyboardEvent2.prototype.isInFoldLane = function() {
            return this.gutterKeyboardHandler.activeLane === "fold";
          };
          return GutterKeyboardEvent2;
        }()
      );
      exports2.GutterKeyboardEvent = GutterKeyboardEvent;
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/line_widgets", "ace/keyboard/gutter_handler", "ace/config", "ace/clipboard", "ace/lib/keys"], function(require2, exports2, module2) {
      "use strict";
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var useragent = require2("./lib/useragent");
      var TextInput = require2("./keyboard/textinput").TextInput;
      var MouseHandler = require2("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = require2("./mouse/fold_handler").FoldHandler;
      var KeyBinding = require2("./keyboard/keybinding").KeyBinding;
      var EditSession = require2("./edit_session").EditSession;
      var Search = require2("./search").Search;
      var Range = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var CommandManager = require2("./commands/command_manager").CommandManager;
      var defaultCommands = require2("./commands/default_commands").commands;
      var config = require2("./config");
      var TokenIterator = require2("./token_iterator").TokenIterator;
      var LineWidgets = require2("./line_widgets").LineWidgets;
      var GutterKeyboardHandler = require2("./keyboard/gutter_handler").GutterKeyboardHandler;
      var nls = require2("./config").nls;
      var clipboard = require2("./clipboard");
      var keys = require2("./lib/keys");
      var Editor = (
        /** @class */
        function() {
          function Editor2(renderer, session, options) {
            this.$toDestroy = [];
            var container = renderer.getContainerElement();
            this.container = container;
            this.renderer = renderer;
            this.id = "editor" + ++Editor2.$uid;
            this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
            if (typeof document == "object") {
              this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
              this.renderer.textarea = this.textInput.getElement();
              this.$mouseHandler = new MouseHandler(this);
              new FoldHandler(this);
            }
            this.keyBinding = new KeyBinding(this);
            this.$search = new Search().set({
              wrap: true
            });
            this.$historyTracker = this.$historyTracker.bind(this);
            this.commands.on("exec", this.$historyTracker);
            this.$initOperationListeners();
            this._$emitInputEvent = lang.delayedCall((function() {
              this._signal("input", {});
              if (this.session && !this.session.destroyed)
                this.session.bgTokenizer.scheduleStart();
            }).bind(this));
            this.on("change", function(_, _self) {
              _self._$emitInputEvent.schedule(31);
            });
            this.setSession(session || options && options.session || new EditSession(""));
            config.resetOptions(this);
            if (options)
              this.setOptions(options);
            config._signal("editor", this);
          }
          Editor2.prototype.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);
            this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
            this.on("change", (function() {
              if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
              }
              this.curOp.docChanged = true;
            }).bind(this), true);
            this.on("changeSelection", (function() {
              if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
              }
              this.curOp.selectionChanged = true;
            }).bind(this), true);
          };
          Editor2.prototype.startOperation = function(commandEvent) {
            if (this.curOp) {
              if (!commandEvent || this.curOp.command)
                return;
              this.prevOp = this.curOp;
            }
            if (!commandEvent) {
              this.previousCommand = null;
              commandEvent = {};
            }
            this.$opResetTimer.schedule();
            this.curOp = this.session.curOp = {
              command: commandEvent.command || {},
              args: commandEvent.args,
              scrollTop: this.renderer.scrollTop
            };
            this.curOp.selectionBefore = this.selection.toJSON();
          };
          Editor2.prototype.endOperation = function(e) {
            if (this.curOp && this.session) {
              if (e && e.returnValue === false || !this.session)
                return this.curOp = null;
              if (e == true && this.curOp.command && this.curOp.command.name == "mouse")
                return;
              this._signal("beforeEndOperation");
              if (!this.curOp)
                return;
              var command = this.curOp.command;
              var scrollIntoView = command && command.scrollIntoView;
              if (scrollIntoView) {
                switch (scrollIntoView) {
                  case "center-animate":
                    scrollIntoView = "animate";
                  case "center":
                    this.renderer.scrollCursorIntoView(null, 0.5);
                    break;
                  case "animate":
                  case "cursor":
                    this.renderer.scrollCursorIntoView();
                    break;
                  case "selectionPart":
                    var range = this.selection.getRange();
                    var config2 = this.renderer.layerConfig;
                    if (range.start.row >= config2.lastRow || range.end.row <= config2.firstRow) {
                      this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                    }
                    break;
                  default:
                    break;
                }
                if (scrollIntoView == "animate")
                  this.renderer.animateScrolling(this.curOp.scrollTop);
              }
              var sel = this.selection.toJSON();
              this.curOp.selectionAfter = sel;
              this.$lastSel = this.selection.toJSON();
              this.session.getUndoManager().addSelection(sel);
              this.prevOp = this.curOp;
              this.curOp = null;
            }
          };
          Editor2.prototype.$historyTracker = function(e) {
            if (!this.$mergeUndoDeltas)
              return;
            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && e.command.name == prev.command.name;
            if (e.command.name == "insertstring") {
              var text = e.args;
              if (this.mergeNextCommand === void 0)
                this.mergeNextCommand = true;
              shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
              this.mergeNextCommand = true;
            } else {
              shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
            }
            if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
              shouldMerge = false;
            }
            if (shouldMerge)
              this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e.command.name) !== -1)
              this.sequenceStartTime = Date.now();
          };
          Editor2.prototype.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
              this.$keybindingId = keyboardHandler;
              var _self = this;
              config.loadModule(["keybinding", keyboardHandler], function(module3) {
                if (_self.$keybindingId == keyboardHandler)
                  _self.keyBinding.setKeyboardHandler(module3 && module3.handler);
                cb && cb();
              });
            } else {
              this.$keybindingId = null;
              this.keyBinding.setKeyboardHandler(keyboardHandler);
              cb && cb();
            }
          };
          Editor2.prototype.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
          };
          Editor2.prototype.setSession = function(session) {
            if (this.session == session)
              return;
            if (this.curOp)
              this.endOperation();
            this.curOp = {};
            var oldSession = this.session;
            if (oldSession) {
              this.session.off("change", this.$onDocumentChange);
              this.session.off("changeMode", this.$onChangeMode);
              this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
              this.session.off("changeTabSize", this.$onChangeTabSize);
              this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
              this.session.off("changeWrapMode", this.$onChangeWrapMode);
              this.session.off("changeFold", this.$onChangeFold);
              this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
              this.session.off("changeBackMarker", this.$onChangeBackMarker);
              this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
              this.session.off("changeAnnotation", this.$onChangeAnnotation);
              this.session.off("changeOverwrite", this.$onCursorChange);
              this.session.off("changeScrollTop", this.$onScrollTopChange);
              this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              var selection = this.session.getSelection();
              selection.off("changeCursor", this.$onCursorChange);
              selection.off("changeSelection", this.$onSelectionChange);
            }
            this.session = session;
            if (session) {
              this.$onDocumentChange = this.onDocumentChange.bind(this);
              session.on("change", this.$onDocumentChange);
              this.renderer.setSession(session);
              this.$onChangeMode = this.onChangeMode.bind(this);
              session.on("changeMode", this.$onChangeMode);
              this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
              session.on("tokenizerUpdate", this.$onTokenizerUpdate);
              this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
              session.on("changeTabSize", this.$onChangeTabSize);
              this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
              session.on("changeWrapLimit", this.$onChangeWrapLimit);
              this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
              session.on("changeWrapMode", this.$onChangeWrapMode);
              this.$onChangeFold = this.onChangeFold.bind(this);
              session.on("changeFold", this.$onChangeFold);
              this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
              this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
              this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
              this.session.on("changeBackMarker", this.$onChangeBackMarker);
              this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
              this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
              this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
              this.session.on("changeAnnotation", this.$onChangeAnnotation);
              this.$onCursorChange = this.onCursorChange.bind(this);
              this.session.on("changeOverwrite", this.$onCursorChange);
              this.$onScrollTopChange = this.onScrollTopChange.bind(this);
              this.session.on("changeScrollTop", this.$onScrollTopChange);
              this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
              this.session.on("changeScrollLeft", this.$onScrollLeftChange);
              this.selection = session.getSelection();
              this.selection.on("changeCursor", this.$onCursorChange);
              this.$onSelectionChange = this.onSelectionChange.bind(this);
              this.selection.on("changeSelection", this.$onSelectionChange);
              this.onChangeMode();
              this.onCursorChange();
              this.onScrollTopChange();
              this.onScrollLeftChange();
              this.onSelectionChange();
              this.onChangeFrontMarker();
              this.onChangeBackMarker();
              this.onChangeBreakpoint();
              this.onChangeAnnotation();
              this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
              this.renderer.updateFull();
            } else {
              this.selection = null;
              this.renderer.setSession(session);
            }
            this._signal("changeSession", {
              session,
              oldSession
            });
            this.curOp = null;
            oldSession && oldSession._signal("changeEditor", { oldEditor: this });
            session && session._signal("changeEditor", { editor: this });
            if (session && !session.destroyed)
              session.bgTokenizer.scheduleStart();
          };
          Editor2.prototype.getSession = function() {
            return this.session;
          };
          Editor2.prototype.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);
            if (!cursorPos)
              this.selectAll();
            else if (cursorPos == 1)
              this.navigateFileEnd();
            else if (cursorPos == -1)
              this.navigateFileStart();
            return val;
          };
          Editor2.prototype.getValue = function() {
            return this.session.getValue();
          };
          Editor2.prototype.getSelection = function() {
            return this.selection;
          };
          Editor2.prototype.resize = function(force) {
            this.renderer.onResize(force);
          };
          Editor2.prototype.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
          };
          Editor2.prototype.getTheme = function() {
            return this.renderer.getTheme();
          };
          Editor2.prototype.setStyle = function(style) {
            this.renderer.setStyle(style);
          };
          Editor2.prototype.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
          };
          Editor2.prototype.getFontSize = function() {
            return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
          };
          Editor2.prototype.setFontSize = function(size) {
            this.setOption("fontSize", size);
          };
          Editor2.prototype.$highlightBrackets = function() {
            if (this.$highlightPending) {
              return;
            }
            var self2 = this;
            this.$highlightPending = true;
            setTimeout(function() {
              self2.$highlightPending = false;
              var session = self2.session;
              if (!session || session.destroyed)
                return;
              if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                  session.removeMarker(id);
                });
                session.$bracketHighlight = null;
              }
              var pos = self2.getCursorPosition();
              var handler = self2.getKeyboardHandler();
              var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self2);
              var ranges = session.getMatchingBracketRanges(pos, isBackwards);
              if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                  var tagNamesRanges = session.getMatchingTags(pos);
                  if (tagNamesRanges)
                    ranges = [tagNamesRanges.openTagName, tagNamesRanges.closeTagName];
                }
              }
              if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self2.session);
              if (!ranges) {
                if (self2.getHighlightIndentGuides())
                  self2.renderer.$textLayer.$highlightIndentGuide();
                return;
              }
              var markerType = "ace_bracket";
              if (!Array.isArray(ranges)) {
                ranges = [ranges];
              } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
              }
              if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                  ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                  ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
              }
              session.$bracketHighlight = {
                ranges,
                markerIds: ranges.map(function(range) {
                  return session.addMarker(range, markerType, "text");
                })
              };
              if (self2.getHighlightIndentGuides())
                self2.renderer.$textLayer.$highlightIndentGuide();
            }, 50);
          };
          Editor2.prototype.focus = function() {
            this.textInput.focus();
          };
          Editor2.prototype.isFocused = function() {
            return this.textInput.isFocused();
          };
          Editor2.prototype.blur = function() {
            this.textInput.blur();
          };
          Editor2.prototype.onFocus = function(e) {
            if (this.$isFocused)
              return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e);
          };
          Editor2.prototype.onBlur = function(e) {
            if (!this.$isFocused)
              return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e);
          };
          Editor2.prototype.$cursorChange = function() {
            this.renderer.updateCursor();
            this.$highlightBrackets();
            this.$updateHighlightActiveLine();
          };
          Editor2.prototype.onDocumentChange = function(delta) {
            var wrap = this.session.$useWrapMode;
            var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
            this.renderer.updateLines(delta.start.row, lastRow, wrap);
            this._signal("change", delta);
            this.$cursorChange();
          };
          Editor2.prototype.onTokenizerUpdate = function(e) {
            var rows = e.data;
            this.renderer.updateLines(rows.first, rows.last);
          };
          Editor2.prototype.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
          };
          Editor2.prototype.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
          };
          Editor2.prototype.onCursorChange = function() {
            this.$cursorChange();
            this._signal("changeSelection");
          };
          Editor2.prototype.$updateHighlightActiveLine = function() {
            var session = this.getSession();
            var highlight;
            if (this.$highlightActiveLine) {
              if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
              if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
              if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
            }
            if (session.$highlightLineMarker && !highlight) {
              session.removeMarker(session.$highlightLineMarker.id);
              session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
              var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
              range.id = session.addMarker(range, "ace_active-line", "screenLine");
              session.$highlightLineMarker = range;
            } else if (highlight) {
              session.$highlightLineMarker.start.row = highlight.row;
              session.$highlightLineMarker.end.row = highlight.row;
              session.$highlightLineMarker.start.column = highlight.column;
              session._signal("changeBackMarker");
            }
          };
          Editor2.prototype.onSelectionChange = function(e) {
            var session = this.session;
            if (session.$selectionMarker) {
              session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
              var range = this.selection.getRange();
              var style = this.getSelectionStyle();
              session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
              this.$updateHighlightActiveLine();
            }
            var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re);
            this._signal("changeSelection");
          };
          Editor2.prototype.$getSelectionHighLightRegexp = function() {
            var session = this.session;
            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
              return;
            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5e3 || !/[\w\d]/.test(needle))
              return;
            var re = this.$search.$assembleRegExp({
              wholeWord: true,
              caseSensitive: true,
              needle
            });
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re.test(wordWithBoundary))
              return;
            return re;
          };
          Editor2.prototype.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
          };
          Editor2.prototype.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
          };
          Editor2.prototype.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
          };
          Editor2.prototype.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
          };
          Editor2.prototype.onChangeMode = function(e) {
            this.renderer.updateText();
            this._emit("changeMode", e);
          };
          Editor2.prototype.onChangeWrapLimit = function() {
            this.renderer.updateFull();
          };
          Editor2.prototype.onChangeWrapMode = function() {
            this.renderer.onResize(true);
          };
          Editor2.prototype.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
          };
          Editor2.prototype.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
          };
          Editor2.prototype.getCopyText = function() {
            var text = this.getSelectedText();
            var nl = this.session.doc.getNewLineCharacter();
            var copyLine = false;
            if (!text && this.$copyWithEmptySelection) {
              copyLine = true;
              var ranges = this.selection.getAllRanges();
              for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (i && ranges[i - 1].start.row == range.start.row)
                  continue;
                text += this.session.getLine(range.start.row) + nl;
              }
            }
            var e = { text };
            this._signal("copy", e);
            clipboard.lineMode = copyLine ? e.text : false;
            return e.text;
          };
          Editor2.prototype.onCopy = function() {
            this.commands.exec("copy", this);
          };
          Editor2.prototype.onCut = function() {
            this.commands.exec("cut", this);
          };
          Editor2.prototype.onPaste = function(text, event) {
            var e = { text, event };
            this.commands.exec("paste", this, e);
          };
          Editor2.prototype.$handlePaste = function(e) {
            if (typeof e == "string")
              e = { text: e };
            this._signal("paste", e);
            var text = e.text;
            var lineMode = text === clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
              if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
              else
                this.insert(text);
            } else if (lineMode) {
              this.selection.rangeList.ranges.forEach(function(range2) {
                session.insert({ row: range2.start.row, column: 0 }, text);
              });
            } else {
              var lines = text.split(/\r\n|\r|\n/);
              var ranges = this.selection.rangeList.ranges;
              var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
              if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);
              for (var i = ranges.length; i--; ) {
                var range = ranges[i];
                if (!range.isEmpty())
                  session.remove(range);
                session.insert(range.start, lines[i]);
              }
            }
          };
          Editor2.prototype.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
          };
          Editor2.prototype.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !pasted) {
              var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
              if (transform) {
                if (text !== transform.text) {
                  if (!this.inVirtualSelectionMode) {
                    this.session.mergeUndoDeltas = false;
                    this.mergeNextCommand = false;
                  }
                }
                text = transform.text;
              }
            }
            if (text == "	")
              text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
              var range = this.getSelectionRange();
              cursor = this.session.remove(range);
              this.clearSelection();
            } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
              var range = new Range.fromPoints(cursor, cursor);
              range.end.column += text.length;
              this.session.remove(range);
            }
            if (text == "\n" || text == "\r\n") {
              var line = session.getLine(cursor.row);
              if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
              }
            }
            this.clearSelection();
            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);
            if (transform && transform.selection) {
              if (transform.selection.length == 2) {
                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
              } else {
                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
              }
            }
            if (this.$enableAutoIndent) {
              if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
              }
              if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
            }
          };
          Editor2.prototype.autoIndent = function() {
            var session = this.session;
            var mode = session.getMode();
            var startRow, endRow;
            if (this.selection.isEmpty()) {
              startRow = 0;
              endRow = session.doc.getLength() - 1;
            } else {
              var selectedRange = this.getSelectionRange();
              startRow = selectedRange.start.row;
              endRow = selectedRange.end.row;
            }
            var prevLineState = "";
            var prevLine = "";
            var lineIndent = "";
            var line, currIndent, range;
            var tab = session.getTabString();
            for (var row = startRow; row <= endRow; row++) {
              if (row > 0) {
                prevLineState = session.getState(row - 1);
                prevLine = session.getLine(row - 1);
                lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
              }
              line = session.getLine(row);
              currIndent = mode.$getIndent(line);
              if (lineIndent !== currIndent) {
                if (currIndent.length > 0) {
                  range = new Range(row, 0, row, currIndent.length);
                  session.remove(range);
                }
                if (lineIndent.length > 0) {
                  session.insert({ row, column: 0 }, lineIndent);
                }
              }
              mode.autoOutdent(prevLineState, session, row);
            }
          };
          Editor2.prototype.onTextInput = function(text, composition) {
            if (!composition)
              return this.keyBinding.onTextInput(text);
            this.startOperation({ command: { name: "insertstring" } });
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount)
              this.forEachSelection(applyComposition);
            else
              applyComposition();
            this.endOperation();
          };
          Editor2.prototype.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
              var r = this.selection.getRange();
              r.start.column -= composition.extendLeft;
              r.end.column += composition.extendRight;
              if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
              }
              this.selection.setRange(r);
              if (!text && !r.isEmpty())
                this.remove();
            }
            if (text || !this.selection.isEmpty())
              this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
              var r = this.selection.getRange();
              r.start.column -= composition.restoreStart;
              r.end.column -= composition.restoreEnd;
              this.selection.setRange(r);
            }
          };
          Editor2.prototype.onCommandKey = function(e, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e, hashId, keyCode);
          };
          Editor2.prototype.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
          };
          Editor2.prototype.getOverwrite = function() {
            return this.session.getOverwrite();
          };
          Editor2.prototype.toggleOverwrite = function() {
            this.session.toggleOverwrite();
          };
          Editor2.prototype.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
          };
          Editor2.prototype.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
          };
          Editor2.prototype.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
          };
          Editor2.prototype.getDragDelay = function() {
            return this.getOption("dragDelay");
          };
          Editor2.prototype.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
          };
          Editor2.prototype.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
          };
          Editor2.prototype.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
          };
          Editor2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          Editor2.prototype.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
          };
          Editor2.prototype.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
          };
          Editor2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.renderer.setAnimatedScroll(shouldAnimate);
          };
          Editor2.prototype.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
          };
          Editor2.prototype.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
          };
          Editor2.prototype.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
          };
          Editor2.prototype.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
          };
          Editor2.prototype.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
          };
          Editor2.prototype.setHighlightIndentGuides = function(highlight) {
            this.renderer.setHighlightIndentGuides(highlight);
          };
          Editor2.prototype.getHighlightIndentGuides = function() {
            return this.renderer.getHighlightIndentGuides();
          };
          Editor2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
          };
          Editor2.prototype.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
          };
          Editor2.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
          };
          Editor2.prototype.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
          };
          Editor2.prototype.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
          };
          Editor2.prototype.getReadOnly = function() {
            return this.getOption("readOnly");
          };
          Editor2.prototype.setBehavioursEnabled = function(enabled) {
            this.setOption("behavioursEnabled", enabled);
          };
          Editor2.prototype.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
          };
          Editor2.prototype.setWrapBehavioursEnabled = function(enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
          };
          Editor2.prototype.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
          };
          Editor2.prototype.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);
          };
          Editor2.prototype.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
          };
          Editor2.prototype.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
          };
          Editor2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          Editor2.prototype.remove = function(dir) {
            if (this.selection.isEmpty()) {
              if (dir == "left")
                this.selection.selectLeft();
              else
                this.selection.selectRight();
            }
            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
              var session = this.session;
              var state = session.getState(range.start.row);
              var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
              if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                  var line = session.getLine(range.end.row);
                  if (/^\s+$/.test(line)) {
                    range.end.column = line.length;
                  }
                }
              }
              if (new_range)
                range = new_range;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.removeWordRight = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordRight();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeWordLeft = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineStart = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineStart();
            if (this.selection.isEmpty())
              this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineEnd = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineEnd();
            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
              range.end.column = 0;
              range.end.row++;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.splitLine = function() {
            if (!this.selection.isEmpty()) {
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
            }
            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
          };
          Editor2.prototype.setGhostText = function(text, position) {
            if (!this.session.widgetManager) {
              this.session.widgetManager = new LineWidgets(this.session);
              this.session.widgetManager.attach(this);
            }
            this.renderer.setGhostText(text, position);
          };
          Editor2.prototype.removeGhostText = function() {
            if (!this.session.widgetManager)
              return;
            this.renderer.removeGhostText();
          };
          Editor2.prototype.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
              return;
            }
            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
              return;
            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
              swap = line.charAt(column) + line.charAt(column - 1);
              range = new Range(cursor.row, column - 1, cursor.row, column + 1);
            } else {
              swap = line.charAt(column - 1) + line.charAt(column - 2);
              range = new Range(cursor.row, column - 2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
          };
          Editor2.prototype.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();
            if (range.start.row < range.end.row) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "	");
              return;
            } else if (range.start.column < range.end.column) {
              var text = session.getTextRange(range);
              if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "	");
                return;
              }
            }
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);
            if (this.session.getUseSoftTabs()) {
              var count = size - column % size;
              var indentString = lang.stringRepeat(" ", count);
            } else {
              var count = column % size;
              while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
              }
              this.selection.setSelectionRange(range);
              indentString = "	";
            }
            return this.insert(indentString);
          };
          Editor2.prototype.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "	");
          };
          Editor2.prototype.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
          };
          Editor2.prototype.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;
            var lines = [];
            for (var i = rows.first; i <= rows.last; i++)
              lines.push(session.getLine(i));
            lines.sort(function(a, b) {
              if (a.toLowerCase() < b.toLowerCase())
                return -1;
              if (a.toLowerCase() > b.toLowerCase())
                return 1;
              return 0;
            });
            var deleteRange = new Range(0, 0, 0, 0);
            for (var i = rows.first; i <= rows.last; i++) {
              var line = session.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              deleteRange.end.column = line.length;
              session.replace(deleteRange, lines[i - rows.first]);
            }
          };
          Editor2.prototype.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
          };
          Editor2.prototype.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
          };
          Editor2.prototype.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;
            var s = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
              var m = _numberRx.exec(s);
              if (m.index <= column && m.index + m[0].length >= column) {
                var number = {
                  value: m[0],
                  start: m.index,
                  end: m.index + m[0].length
                };
                return number;
              }
            }
            return null;
          };
          Editor2.prototype.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column - 1, row, column);
            var c = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c)) && isFinite(c)) {
              var nr = this.getNumberAt(row, column);
              if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;
                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);
                if (fp !== nr.end && column < fp) {
                  amount *= Math.pow(10, nr.end - column - 1);
                } else {
                  amount *= Math.pow(10, nr.end - column);
                }
                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
              }
            } else {
              this.toggleWord();
            }
          };
          Editor2.prototype.toggleWord = function() {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0)
              delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) {
              wordParts.forEach(function(item2, i2) {
                itLength = curLength + item2.length;
                if (delta >= curLength && delta <= itLength) {
                  currentState = item2;
                  that.selection.clearSelection();
                  that.moveCursorTo(row, curLength + currWordStart);
                  that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
              });
            }
            var wordPairs = this.$toggleWordPairs;
            var reg;
            for (var i = 0; i < wordPairs.length; i++) {
              var item = wordPairs[i];
              for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item[j]) + ")\\s?$", "i"));
                if (firstCondition) {
                  var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                  if (secondCondition) {
                    reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), "i"), function(result) {
                      var res = item[negate];
                      if (result.toUpperCase() == result) {
                        res = res.toUpperCase();
                      } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                        res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                      }
                      return res;
                    });
                    this.insert(reg);
                    reg = "";
                  }
                }
              }
            }
          };
          Editor2.prototype.findLinkAt = function(row, column) {
            var e_1, _a;
            var line = this.session.getLine(row);
            var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
            var columnPosition = column;
            if (columnPosition < 0)
              columnPosition = 0;
            var previousPosition = 0, currentPosition = 0, match;
            try {
              for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
                var item = wordParts_1_1.value;
                currentPosition = previousPosition + item.length;
                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                  if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                    match = item.replace(/[\s:.,'";}\]]+$/, "");
                    break;
                  }
                }
                previousPosition = currentPosition;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return))
                  _a.call(wordParts_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            return match;
          };
          Editor2.prototype.openLink = function() {
            var cursor = this.selection.getCursor();
            var url = this.findLinkAt(cursor.row, cursor.column);
            if (url)
              window.open(url, "_blank");
            return url != null;
          };
          Editor2.prototype.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
          };
          Editor2.prototype.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
              var row = range.start.row;
              doc.duplicateLines(row, row);
            } else {
              var point = reverse ? range.start : range.end;
              var endPoint = doc.insert(point, doc.getTextRange(range), false);
              range.start = point;
              range.end = endPoint;
              sel.setSelectionRange(range, reverse);
            }
          };
          Editor2.prototype.moveLinesDown = function() {
            this.$moveLines(1, false);
          };
          Editor2.prototype.moveLinesUp = function() {
            this.$moveLines(-1, false);
          };
          Editor2.prototype.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
          };
          Editor2.prototype.copyLinesUp = function() {
            this.$moveLines(-1, true);
          };
          Editor2.prototype.copyLinesDown = function() {
            this.$moveLines(1, true);
          };
          Editor2.prototype.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
              var range = selection.toOrientedRange();
              rows = this.$getSelectedRows(range);
              moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
              if (copy && dir == -1)
                moved = 0;
              range.moveBy(moved, 0);
              selection.fromOrientedRange(range);
            } else {
              var ranges = selection.rangeList.ranges;
              selection.rangeList.detach(this.session);
              this.inVirtualSelectionMode = true;
              var diff = 0;
              var totalDiff = 0;
              var l = ranges.length;
              for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                  if (totalDiff)
                    ranges[i].moveBy(totalDiff, 0);
                  var subRows = this.$getSelectedRows(ranges[i]);
                  if (copy && subRows.first != last)
                    break;
                  else if (!copy && subRows.first > last + 1)
                    break;
                  last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1)
                  rangeIndex = i + 1;
                while (rangeIndex <= i) {
                  ranges[rangeIndex].moveBy(diff, 0);
                  rangeIndex++;
                }
                if (!copy)
                  diff = 0;
                totalDiff += diff;
              }
              selection.fromOrientedRange(selection.ranges[0]);
              selection.rangeList.attach(this.session);
              this.inVirtualSelectionMode = false;
            }
          };
          Editor2.prototype.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();
            return {
              first: this.session.getRowFoldStart(range.start.row),
              last: this.session.getRowFoldEnd(range.end.row)
            };
          };
          Editor2.prototype.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
          };
          Editor2.prototype.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
          };
          Editor2.prototype.onCompositionEnd = function() {
            this.renderer.hideComposition();
          };
          Editor2.prototype.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
          };
          Editor2.prototype.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
          };
          Editor2.prototype.isRowVisible = function(row) {
            return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
          };
          Editor2.prototype.isRowFullyVisible = function(row) {
            return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
          };
          Editor2.prototype.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          };
          Editor2.prototype.$moveByPage = function(dir, select) {
            var renderer = this.renderer;
            var config2 = this.renderer.layerConfig;
            var rows = dir * Math.floor(config2.height / config2.lineHeight);
            if (select === true) {
              this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
              });
            } else if (select === false) {
              this.selection.moveCursorBy(rows, 0);
              this.selection.clearSelection();
            }
            var scrollTop = renderer.scrollTop;
            renderer.scrollBy(0, rows * config2.lineHeight);
            if (select != null)
              renderer.scrollCursorIntoView(null, 0.5);
            renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.selectPageDown = function() {
            this.$moveByPage(1, true);
          };
          Editor2.prototype.selectPageUp = function() {
            this.$moveByPage(-1, true);
          };
          Editor2.prototype.gotoPageDown = function() {
            this.$moveByPage(1, false);
          };
          Editor2.prototype.gotoPageUp = function() {
            this.$moveByPage(-1, false);
          };
          Editor2.prototype.scrollPageDown = function() {
            this.$moveByPage(1);
          };
          Editor2.prototype.scrollPageUp = function() {
            this.$moveByPage(-1);
          };
          Editor2.prototype.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
          };
          Editor2.prototype.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
          };
          Editor2.prototype.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
              row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
              column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
          };
          Editor2.prototype.getCursorPosition = function() {
            return this.selection.getCursor();
          };
          Editor2.prototype.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
          };
          Editor2.prototype.getSelectionRange = function() {
            return this.selection.getRange();
          };
          Editor2.prototype.selectAll = function() {
            this.selection.selectAll();
          };
          Editor2.prototype.clearSelection = function() {
            this.selection.clearSelection();
          };
          Editor2.prototype.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
          };
          Editor2.prototype.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
          };
          Editor2.prototype.jumpToMatching = function(select, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var tokenCount = 0;
            if (prevToken && prevToken.type.indexOf("tag-name") !== -1) {
              prevToken = iterator.stepBackward();
            }
            var token = prevToken || iterator.stepForward();
            if (!token)
              return;
            var matchType;
            var found = false;
            var depth = {};
            var i = cursor.column - token.start;
            var bracketType;
            var brackets = {
              ")": "(",
              "(": "(",
              "]": "[",
              "[": "[",
              "{": "{",
              "}": "{"
            };
            do {
              if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                  if (!brackets[token.value[i]]) {
                    continue;
                  }
                  bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
                  if (isNaN(depth[bracketType])) {
                    depth[bracketType] = 0;
                  }
                  switch (token.value[i]) {
                    case "(":
                    case "[":
                    case "{":
                      depth[bracketType]++;
                      break;
                    case ")":
                    case "]":
                    case "}":
                      depth[bracketType]--;
                      if (depth[bracketType] === -1) {
                        matchType = "bracket";
                        found = true;
                      }
                      break;
                  }
                }
              } else if (token.type.indexOf("tag-name") !== -1) {
                if (isNaN(depth[token.value])) {
                  depth[token.value] = 0;
                }
                if (prevToken.value === "<" && tokenCount > 1) {
                  depth[token.value]++;
                } else if (prevToken.value === "</") {
                  depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                  matchType = "tag";
                  found = true;
                }
              }
              if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i = 0;
              }
            } while (token && !found);
            if (!matchType)
              return;
            var range, pos;
            if (matchType === "bracket") {
              range = this.session.getBracketRange(cursor);
              if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                  range = this.session.getBracketRange(pos);
              }
            } else if (matchType === "tag") {
              if (!token || token.type.indexOf("tag-name") === -1)
                return;
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
              if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                  if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                    range = tagsRanges.closeTag;
                    pos = range.start;
                  } else {
                    range = tagsRanges.openTag;
                    if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column)
                      pos = range.end;
                    else
                      pos = range.start;
                  }
                }
              }
              pos = pos || range.start;
            }
            pos = range && range.cursor || pos;
            if (pos) {
              if (select) {
                if (range && expand) {
                  this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                  this.clearSelection();
                } else {
                  this.selection.selectTo(pos.row, pos.column);
                }
              } else {
                this.selection.moveTo(pos.row, pos.column);
              }
            }
          };
          Editor2.prototype.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({ row: lineNumber - 1, column: column || 0 });
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);
            if (!this.isRowFullyVisible(lineNumber - 1))
              this.scrollToLine(lineNumber - 1, true, animate);
          };
          Editor2.prototype.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
          };
          Editor2.prototype.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
              var selectionStart = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
          };
          Editor2.prototype.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
              var selectionEnd = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
          };
          Editor2.prototype.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionStart = this.getSelectionRange().start;
              this.moveCursorToPosition(selectionStart);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorLeft();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionEnd = this.getSelectionRange().end;
              this.moveCursorToPosition(selectionEnd);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorRight();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
          };
          Editor2.prototype.replace = function(replacement, options) {
            if (options)
              this.$search.set(options);
            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
              return replaced;
            if (this.$tryReplace(range, replacement)) {
              replaced = 1;
            }
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
            return replaced;
          };
          Editor2.prototype.replaceAll = function(replacement, options) {
            if (options) {
              this.$search.set(options);
            }
            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
              return replaced;
            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for (var i = ranges.length - 1; i >= 0; --i) {
              if (this.$tryReplace(ranges[i], replacement)) {
                replaced++;
              }
            }
            this.selection.setSelectionRange(selection);
            return replaced;
          };
          Editor2.prototype.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
              range.end = this.session.replace(range, replacement);
              return range;
            } else {
              return null;
            }
          };
          Editor2.prototype.getLastSearchOptions = function() {
            return this.$search.getOptions();
          };
          Editor2.prototype.find = function(needle, options, animate) {
            if (!options)
              options = {};
            if (typeof needle == "string" || needle instanceof RegExp)
              options.needle = needle;
            else if (typeof needle == "object")
              oop.mixin(options, needle);
            var range = this.selection.getRange();
            if (options.needle == null) {
              needle = this.session.getTextRange(range) || this.$search.$options.needle;
              if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
              }
              this.$search.set({ needle });
            }
            this.$search.set(options);
            if (!options.start)
              this.$search.set({ start: range });
            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
              return newRange;
            if (newRange) {
              this.revealRange(newRange, animate);
              return newRange;
            }
            if (options.backwards)
              range.start = range.end;
            else
              range.end = range.start;
            this.selection.setRange(range);
          };
          Editor2.prototype.findNext = function(options, animate) {
            this.find({ skipCurrent: true, backwards: false }, options, animate);
          };
          Editor2.prototype.findPrevious = function(options, animate) {
            this.find(options, { skipCurrent: true, backwards: true }, animate);
          };
          Editor2.prototype.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);
            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
              this.renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.destroy = function() {
            if (this.$toDestroy) {
              this.$toDestroy.forEach(function(el) {
                el.destroy();
              });
              this.$toDestroy = null;
            }
            if (this.$mouseHandler)
              this.$mouseHandler.destroy();
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session)
              this.session.destroy();
            if (this._$emitInputEvent)
              this._$emitInputEvent.cancel();
            this.removeAllListeners();
          };
          Editor2.prototype.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
              return;
            var rect;
            var self2 = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
              this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
              shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
              if (shouldScroll)
                rect = self2.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
              if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
                var renderer = self2.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config2 = renderer.layerConfig;
                var top = pos.top - config2.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                  shouldScroll = true;
                } else if (pos.top < config2.height && pos.top + rect.top + config2.lineHeight > window.innerHeight) {
                  shouldScroll = false;
                } else {
                  shouldScroll = null;
                }
                if (shouldScroll != null) {
                  scrollAnchor.style.top = top + "px";
                  scrollAnchor.style.left = pos.left + "px";
                  scrollAnchor.style.height = config2.lineHeight + "px";
                  scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(enable2) {
              if (enable2)
                return;
              delete this.setAutoScrollEditorIntoView;
              this.off("changeSelection", onChangeSelection);
              this.renderer.off("afterRender", onAfterRender);
              this.renderer.off("beforeRender", onBeforeRender);
            };
          };
          Editor2.prototype.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
              return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
          };
          Editor2.prototype.prompt = function(message, options, callback) {
            var editor = this;
            config.loadModule("ace/ext/prompt", function(module3) {
              module3.prompt(editor, message, options, callback);
            });
          };
          return Editor2;
        }()
      );
      Editor.$uid = 0;
      Editor.prototype.curOp = null;
      Editor.prototype.prevOp = {};
      Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
      Editor.prototype.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
      ];
      oop.implement(Editor.prototype, EventEmitter);
      config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", { data: style });
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function(readOnly) {
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
          },
          initialValue: false
        },
        copyWithEmptySelection: {
          set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
          },
          initialValue: false
        },
        cursorStyle: {
          set: function(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: { initialValue: true },
        wrapBehavioursEnabled: { initialValue: true },
        enableAutoIndent: { initialValue: true },
        autoScrollEditorIntoView: {
          set: function(val) {
            this.setAutoScrollEditorIntoView(val);
          }
        },
        keyboardHandler: {
          set: function(val) {
            this.setKeyboardHandler(val);
          },
          get: function() {
            return this.$keybindingId;
          },
          handlesSet: true
        },
        value: {
          set: function(val) {
            this.session.setValue(val);
          },
          get: function() {
            return this.getValue();
          },
          handlesSet: true,
          hidden: true
        },
        session: {
          set: function(val) {
            this.setSession(val);
          },
          get: function() {
            return this.session;
          },
          handlesSet: true,
          hidden: true
        },
        showLineNumbers: {
          set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          },
          initialValue: true
        },
        relativeLineNumbers: {
          set: function(value) {
            if (this.$showLineNumbers && value)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          }
        },
        placeholder: {
          set: function(message) {
            if (!this.$updatePlaceholder) {
              this.$updatePlaceholder = (function() {
                var hasValue = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                if (hasValue && this.renderer.placeholderNode) {
                  this.renderer.off("afterRender", this.$updatePlaceholder);
                  dom.removeCssClass(this.container, "ace_hasPlaceholder");
                  this.renderer.placeholderNode.remove();
                  this.renderer.placeholderNode = null;
                } else if (!hasValue && !this.renderer.placeholderNode) {
                  this.renderer.on("afterRender", this.$updatePlaceholder);
                  dom.addCssClass(this.container, "ace_hasPlaceholder");
                  var el = dom.createElement("div");
                  el.className = "ace_placeholder";
                  el.textContent = this.$placeholder || "";
                  this.renderer.placeholderNode = el;
                  this.renderer.content.appendChild(this.renderer.placeholderNode);
                } else if (!hasValue && this.renderer.placeholderNode) {
                  this.renderer.placeholderNode.textContent = this.$placeholder || "";
                }
              }).bind(this);
              this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
          }
        },
        enableKeyboardAccessibility: {
          set: function(value) {
            var blurCommand = {
              name: "blurTextInput",
              description: "Set focus to the editor content div to allow tabbing through the page",
              bindKey: "Esc",
              exec: function(editor) {
                editor.blur();
                editor.renderer.scroller.focus();
              },
              readOnly: true
            };
            var focusOnEnterKeyup = function(e) {
              if (e.target == this.renderer.scroller && e.keyCode === keys["enter"]) {
                e.preventDefault();
                var row = this.getCursorPosition().row;
                if (!this.isRowVisible(row))
                  this.scrollToLine(row, true, true);
                this.focus();
              }
            };
            var gutterKeyboardHandler;
            if (value) {
              this.renderer.enableKeyboardAccessibility = true;
              this.renderer.keyboardFocusClassName = "ace_keyboard-focus";
              this.textInput.getElement().setAttribute("tabindex", -1);
              this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
              this.renderer.scroller.setAttribute("tabindex", 0);
              this.renderer.scroller.setAttribute("role", "group");
              this.renderer.scroller.setAttribute("aria-roledescription", nls("editor"));
              this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.setAttribute("aria-label", nls("Editor content, press Enter to start editing, press Escape to exit"));
              this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.addCommand(blurCommand);
              this.renderer.$gutter.setAttribute("tabindex", 0);
              this.renderer.$gutter.setAttribute("aria-hidden", false);
              this.renderer.$gutter.setAttribute("role", "group");
              this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor"));
              this.renderer.$gutter.setAttribute("aria-label", nls("Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit"));
              this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.content.setAttribute("aria-hidden", true);
              if (!gutterKeyboardHandler)
                gutterKeyboardHandler = new GutterKeyboardHandler(this);
              gutterKeyboardHandler.addListener();
            } else {
              this.renderer.enableKeyboardAccessibility = false;
              this.textInput.getElement().setAttribute("tabindex", 0);
              this.textInput.setNumberOfExtraLines(0);
              this.renderer.scroller.setAttribute("tabindex", -1);
              this.renderer.scroller.removeAttribute("role");
              this.renderer.scroller.removeAttribute("aria-roledescription");
              this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.removeAttribute("aria-label");
              this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.removeCommand(blurCommand);
              this.renderer.content.removeAttribute("aria-hidden");
              this.renderer.$gutter.setAttribute("tabindex", -1);
              this.renderer.$gutter.setAttribute("aria-hidden", true);
              this.renderer.$gutter.removeAttribute("role");
              this.renderer.$gutter.removeAttribute("aria-roledescription");
              this.renderer.$gutter.removeAttribute("aria-label");
              this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);
              if (gutterKeyboardHandler)
                gutterKeyboardHandler.removeListener();
            }
          },
          initialValue: false
        },
        customScrollbar: "renderer",
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        highlightIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",
        useResizeObserver: "renderer",
        useSvgGutterIcons: "renderer",
        showFoldedAnnotations: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      var relativeNumberRenderer = {
        getText: function(session, row) {
          return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "" : "")) + "";
        },
        getWidth: function(session, lastLineNumber, config2) {
          return Math.max(lastLineNumber.toString().length, (config2.lastRow + 1).toString().length, 2) * config2.characterWidth;
        },
        update: function(e, editor) {
          editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
        },
        attach: function(editor) {
          editor.renderer.$gutterLayer.$renderer = this;
          editor.on("changeSelection", this.update);
          this.update(null, editor);
        },
        detach: function(editor) {
          if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
          editor.off("changeSelection", this.update);
          this.update(null, editor);
        }
      };
      exports2.Editor = Editor;
    });
    ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var Lines = (
        /** @class */
        function() {
          function Lines2(element, canvasHeight) {
            this.element = element;
            this.canvasHeight = canvasHeight || 5e5;
            this.element.style.height = this.canvasHeight * 2 + "px";
            this.cells = [];
            this.cellCache = [];
            this.$offsetCoefficient = 0;
          }
          Lines2.prototype.moveContainer = function(config) {
            dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
          };
          Lines2.prototype.pageChanged = function(oldConfig, newConfig) {
            return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
          };
          Lines2.prototype.computeLineTop = function(row, config, session) {
            var screenTop = config.firstRowScreen * config.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
            return lineTop - screenPage * this.canvasHeight;
          };
          Lines2.prototype.computeLineHeight = function(row, config, session) {
            return config.lineHeight * session.getRowLineCount(row);
          };
          Lines2.prototype.getLength = function() {
            return this.cells.length;
          };
          Lines2.prototype.get = function(index) {
            return this.cells[index];
          };
          Lines2.prototype.shift = function() {
            this.$cacheCell(this.cells.shift());
          };
          Lines2.prototype.pop = function() {
            this.$cacheCell(this.cells.pop());
          };
          Lines2.prototype.push = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.push.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
              }
              this.element.appendChild(fragment);
            } else {
              this.cells.push(cell);
              this.element.appendChild(cell.element);
            }
          };
          Lines2.prototype.unshift = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.unshift.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
              }
              if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
              else
                this.element.appendChild(fragment);
            } else {
              this.cells.unshift(cell);
              this.element.insertAdjacentElement("afterbegin", cell.element);
            }
          };
          Lines2.prototype.last = function() {
            if (this.cells.length)
              return this.cells[this.cells.length - 1];
            else
              return null;
          };
          Lines2.prototype.$cacheCell = function(cell) {
            if (!cell)
              return;
            cell.element.remove();
            this.cellCache.push(cell);
          };
          Lines2.prototype.createCell = function(row, config, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
              var element = dom.createElement("div");
              if (initElement)
                initElement(element);
              this.element.appendChild(element);
              cell = {
                element,
                text: "",
                row
              };
            }
            cell.row = row;
            return cell;
          };
          return Lines2;
        }()
      );
      exports2.Lines = Lines;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var lang = require2("../lib/lang");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Lines = require2("./lines").Lines;
      var nls = require2("../config").nls;
      var Gutter = (
        /** @class */
        function() {
          function Gutter2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_gutter-layer";
            parentEl.appendChild(this.element);
            this.setShowFoldWidgets(this.$showFoldWidgets);
            this.gutterWidth = 0;
            this.$annotations = [];
            this.$updateAnnotations = this.$updateAnnotations.bind(this);
            this.$lines = new Lines(this.element);
            this.$lines.$offsetCoefficient = 1;
          }
          Gutter2.prototype.setSession = function(session) {
            if (this.session)
              this.session.off("change", this.$updateAnnotations);
            this.session = session;
            if (session)
              session.on("change", this.$updateAnnotations);
          };
          Gutter2.prototype.addGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
          };
          Gutter2.prototype.removeGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
          };
          Gutter2.prototype.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              var row = annotation.row;
              var rowInfo = this.$annotations[row];
              if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [], type: [] };
              var annoText = annotation.text;
              var annoType = annotation.type;
              annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
              if (rowInfo.text.indexOf(annoText) === -1) {
                rowInfo.text.push(annoText);
                rowInfo.type.push(annoType);
              }
              var className = annotation.className;
              if (className)
                rowInfo.className = className;
              else if (annoType == "error")
                rowInfo.className = " ace_error";
              else if (annoType == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
              else if (annoType == "info" && !rowInfo.className)
                rowInfo.className = " ace_info";
            }
          };
          Gutter2.prototype.$updateAnnotations = function(delta) {
            if (!this.$annotations.length)
              return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              this.$annotations.splice(firstRow, len + 1, null);
            } else {
              var args = new Array(len + 1);
              args.unshift(firstRow, 1);
              this.$annotations.splice.apply(this.$annotations, args);
            }
          };
          Gutter2.prototype.update = function(config) {
            this.config = config;
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              session.getLength() - 1
            );
            this.oldLastRow = lastRow;
            this.config = config;
            this.$lines.moveContainer(config);
            this.$updateCursorRow();
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;
            var cell = null;
            var index = -1;
            var row = firstRow;
            while (true) {
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
              }
              if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                  this.$lines.pop();
                break;
              }
              cell = this.$lines.get(++index);
              if (cell) {
                cell.row = row;
              } else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
              }
              this.$renderCell(cell, config, fold, row);
              row++;
            }
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$updateGutterWidth = function(config) {
            var session = this.session;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || session.$useWrapMode)
              lastLineText = session.getLength() + firstLineNumber - 1;
            var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
              this.gutterWidth = gutterWidth;
              this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
              this._signal("changeGutterWidth", gutterWidth);
            }
          };
          Gutter2.prototype.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
              return;
            var position = this.session.selection.getCursor();
            if (this.$cursorRow === position.row)
              return;
            this.$cursorRow = position.row;
          };
          Gutter2.prototype.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
              return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;
            if (this.$cursorCell && this.$cursorCell.row == row)
              return;
            if (this.$cursorCell)
              this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for (var i = 0; i < cells.length; i++) {
              var cell = cells[i];
              if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                  var fold = this.session.getFoldLine(this.$cursorRow);
                  if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                    cell = cells[i - 1];
                  else
                    break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
              }
            }
          };
          Gutter2.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              this.session.getLength() - 1
            );
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldLastRow > lastRow)
              for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (lastRow > oldLastRow) {
              this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
            }
            this.updateLineHighlight();
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$renderLines = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
              this.$renderCell(cell, config, foldLine, row);
              fragment.push(cell);
              row++;
            }
            return fragment;
          };
          Gutter2.prototype.$renderCell = function(cell, config, fold, row) {
            var element = cell.element;
            var session = this.session;
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];
            var annotationNode = element.childNodes[2];
            var annotationIconNode = annotationNode.firstChild;
            var firstLineNumber = session.$firstLineNumber;
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
            var lineHeight = config.lineHeight + "px";
            var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
            var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            var rowText = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
            if (this.$highlightGutterLine) {
              if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                  if (this.$cursorCell)
                    this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                  this.$cursorCell = cell;
                }
              }
            }
            if (breakpoints[row])
              className += breakpoints[row];
            if (decorations[row])
              className += decorations[row];
            if (this.$annotations[row] && row !== foldStart)
              className += this.$annotations[row].className;
            if (foldWidgets) {
              var c = foldWidgets[row];
              if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c) {
              var foldClass = "ace_fold-widget ace_" + c;
              var isClosedFold = c == "start" && row == foldStart && row < fold.end.row;
              if (isClosedFold) {
                foldClass += " ace_closed";
                var foldAnnotationClass = "";
                var annotationInFold = false;
                for (var i = row + 1; i <= fold.end.row; i++) {
                  if (!this.$annotations[i])
                    continue;
                  if (this.$annotations[i].className === " ace_error") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_error_fold";
                    break;
                  }
                  if (this.$annotations[i].className === " ace_warning") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_warning_fold";
                    continue;
                  }
                }
                className += foldAnnotationClass;
              } else
                foldClass += " ace_open";
              if (foldWidget.className != foldClass)
                foldWidget.className = foldClass;
              dom.setStyle(foldWidget.style, "height", lineHeight);
              dom.setStyle(foldWidget.style, "display", "inline-block");
              foldWidget.setAttribute("role", "button");
              foldWidget.setAttribute("tabindex", "-1");
              var foldRange = session.getFoldWidgetRange(row);
              if (foldRange)
                foldWidget.setAttribute("aria-label", nls("Toggle code folding, rows $0 through $1", [foldRange.start.row + 1, foldRange.end.row + 1]));
              else {
                if (fold)
                  foldWidget.setAttribute("aria-label", nls("Toggle code folding, rows $0 through $1", [fold.start.row + 1, fold.end.row + 1]));
                else
                  foldWidget.setAttribute("aria-label", nls("Toggle code folding, row $0", [row + 1]));
              }
              if (isClosedFold) {
                foldWidget.setAttribute("aria-expanded", "false");
                foldWidget.setAttribute("title", nls("Unfold code"));
              } else {
                foldWidget.setAttribute("aria-expanded", "true");
                foldWidget.setAttribute("title", nls("Fold code"));
              }
            } else {
              if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
                foldWidget.setAttribute("tabindex", "0");
                foldWidget.removeAttribute("role");
                foldWidget.removeAttribute("aria-label");
              }
            }
            if (annotationInFold && this.$showFoldedAnnotations) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              annotationIconNode.className += foldAnnotationClass;
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              annotationNode.setAttribute("aria-label", nls("Read annotations row $0", [rowText]));
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else if (this.$annotations[row]) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              if (this.$useSvgGutterIcons)
                annotationIconNode.className += this.$annotations[row].className;
              else
                element.classList.add(this.$annotations[row].className.replace(" ", ""));
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              annotationNode.setAttribute("aria-label", nls("Read annotations row $0", [rowText]));
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else {
              dom.setStyle(annotationNode.style, "display", "none");
              annotationNode.removeAttribute("aria-label");
              annotationNode.removeAttribute("role");
              annotationNode.setAttribute("tabindex", "0");
            }
            if (rowText !== textNode.data) {
              textNode.data = rowText;
            }
            if (element.className != className)
              element.className = className;
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
            cell.text = rowText;
            if (annotationNode.style.display === "none" && foldWidget.style.display === "none")
              cell.element.setAttribute("aria-hidden", true);
            else
              cell.element.setAttribute("aria-hidden", false);
            return cell;
          };
          Gutter2.prototype.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
          };
          Gutter2.prototype.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
              getWidth: function() {
                return 0;
              },
              getText: function() {
                return "";
              }
            };
          };
          Gutter2.prototype.getShowLineNumbers = function() {
            return this.$showLineNumbers;
          };
          Gutter2.prototype.setShowFoldWidgets = function(show) {
            if (show)
              dom.addCssClass(this.element, "ace_folding-enabled");
            else
              dom.removeCssClass(this.element, "ace_folding-enabled");
            this.$showFoldWidgets = show;
            this.$padding = null;
          };
          Gutter2.prototype.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
          };
          Gutter2.prototype.$computePadding = function() {
            if (!this.element.firstChild)
              return { left: 0, right: 0 };
            var style = dom.computedStyle(this.element.firstChild);
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
            return this.$padding;
          };
          Gutter2.prototype.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
              return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
              return "foldWidgets";
          };
          return Gutter2;
        }()
      );
      Gutter.prototype.$fixedWidth = false;
      Gutter.prototype.$highlightGutterLine = true;
      Gutter.prototype.$renderer = "";
      Gutter.prototype.$showLineNumbers = true;
      Gutter.prototype.$showFoldWidgets = true;
      oop.implement(Gutter.prototype, EventEmitter);
      function onCreateCell(element) {
        var textNode = document.createTextNode("");
        element.appendChild(textNode);
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        var annotationNode = dom.createElement("span");
        element.appendChild(annotationNode);
        var annotationIconNode = dom.createElement("span");
        annotationNode.appendChild(annotationIconNode);
        return element;
      }
      exports2.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var Range = require2("../range").Range;
      var dom = require2("../lib/dom");
      var Marker = (
        /** @class */
        function() {
          function Marker2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_marker-layer";
            parentEl.appendChild(this.element);
          }
          Marker2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Marker2.prototype.setSession = function(session) {
            this.session = session;
          };
          Marker2.prototype.setMarkers = function(markers) {
            this.markers = markers;
          };
          Marker2.prototype.elt = function(className, css) {
            var x = this.i != -1 && this.element.childNodes[this.i];
            if (!x) {
              x = document.createElement("div");
              this.element.appendChild(x);
              this.i = -1;
            } else {
              this.i++;
            }
            x.style.cssText = css;
            x.className = className;
          };
          Marker2.prototype.update = function(config) {
            if (!config)
              return;
            this.config = config;
            this.i = 0;
            var html;
            for (var key in this.markers) {
              var marker = this.markers[key];
              if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
              }
              var range = marker.range.clipRows(config.firstRow, config.lastRow);
              if (range.isEmpty())
                continue;
              range = range.toScreenRange(this.session);
              if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
              } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
              } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
              } else if (range.isMultiLine()) {
                if (marker.type == "text")
                  this.drawTextMarker(html, range, marker.clazz, config);
                else
                  this.drawMultiLineMarker(html, range, marker.clazz, config);
              } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
              }
            }
            if (this.i != -1) {
              while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
            }
          };
          Marker2.prototype.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
          };
          Marker2.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0;
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range(row, range.start.column, row, curr);
            for (; row <= end; row++) {
              lineRange.start.row = lineRange.end.row = row;
              lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
              lineRange.end.column = next;
              prev = curr;
              curr = next;
              next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
              this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
            }
          };
          Marker2.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height = config.lineHeight;
            var top = this.$getTop(range.start.row, config);
            var left = padding + range.start.column * config.characterWidth;
            extraStyle = extraStyle || "";
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
              var range1 = range.clone();
              range1.end.row = range1.start.row;
              range1.end.column = this.session.getLine(range1.start.row).length;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else {
              this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;right:0;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
              var range1 = range.clone();
              range1.start.row = range1.end.row;
              range1.start.column = 0;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
              top = this.$getTop(range.end.row, config);
              var width = range.end.column * config.characterWidth;
              this.elt(clazz + " ace_br12", "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0)
              return;
            top = this.$getTop(range.start.row + 1, config);
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
            this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;right:0;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row))
              return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            this.elt(clazz, "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
            selections.forEach(function(selection) {
              this.elt(clazz, "height:" + height + "px;width:" + (selection.width + (extraLength || 0)) + "px;top:" + top + "px;left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
            }, this);
          };
          Marker2.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row)
              height += this.$getTop(range.end.row, config) - top;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          Marker2.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          return Marker2;
        }()
      );
      Marker.prototype.$padding = 0;
      function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
      }
      exports2.Marker = Marker;
    });
    ace.define("ace/layer/text_util", ["require", "exports", "module"], function(require2, exports2, module2) {
      var textTokens = /* @__PURE__ */ new Set(["text", "rparen", "lparen"]);
      exports2.isTextToken = function(tokenType) {
        return textTokens.has(tokenType);
      };
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter", "ace/config", "ace/layer/text_util"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var Lines = require2("./lines").Lines;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var nls = require2("../config").nls;
      var isTextToken = require2("./text_util").isTextToken;
      var Text = (
        /** @class */
        function() {
          function Text2(parentEl) {
            this.dom = dom;
            this.element = this.dom.createElement("div");
            this.element.className = "ace_layer ace_text-layer";
            parentEl.appendChild(this.element);
            this.$updateEolChar = this.$updateEolChar.bind(this);
            this.$lines = new Lines(this.element);
          }
          Text2.prototype.$updateEolChar = function() {
            var doc = this.session.doc;
            var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
              this.EOL_CHAR = EOL_CHAR;
              return true;
            }
          };
          Text2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
          };
          Text2.prototype.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
          };
          Text2.prototype.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
          };
          Text2.prototype.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on("changeCharacterSize", (function(e) {
              this._signal("changeCharacterSize", e);
            }).bind(this));
            this.$pollSizeChanges();
          };
          Text2.prototype.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
          };
          Text2.prototype.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          };
          Text2.prototype.setSession = function(session) {
            this.session = session;
            if (session)
              this.$computeTabString();
          };
          Text2.prototype.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
              return false;
            this.showInvisibles = showInvisibles;
            if (typeof showInvisibles == "string") {
              this.showSpaces = /tab/i.test(showInvisibles);
              this.showTabs = /space/i.test(showInvisibles);
              this.showEOL = /eol/i.test(showInvisibles);
            } else {
              this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
            }
            this.$computeTabString();
            return true;
          };
          Text2.prototype.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
              return false;
            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
          };
          Text2.prototype.setHighlightIndentGuides = function(highlight) {
            if (this.$highlightIndentGuides === highlight)
              return false;
            this.$highlightIndentGuides = highlight;
            return highlight;
          };
          Text2.prototype.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i < tabSize + 1; i++) {
              if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                tabStr.push(span);
              } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
              }
            }
            if (this.displayIndentGuides) {
              this.$indentGuideRe = /\s\S| \t|\t |\s$/;
              var className = "ace_indent-guide";
              var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
              var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
              var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
              var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
              var span = this.dom.createElement("span");
              span.className = className + spaceClass;
              span.textContent = spaceContent;
              this.$tabStrings[" "] = span;
              var span = this.dom.createElement("span");
              span.className = className + tabClass;
              span.textContent = tabContent;
              this.$tabStrings["	"] = span;
            }
          };
          Text2.prototype.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
              return this.update(config);
            }
            this.config = config;
            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);
            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;
            for (var row = config.firstRow; row < first; row++) {
              var foldLine = this.session.getFoldLine(row);
              if (foldLine) {
                if (foldLine.containsRow(first)) {
                  first = foldLine.start.row;
                  break;
                } else {
                  row = foldLine.end.row;
                }
              }
              lineElementsIdx++;
            }
            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > last)
                break;
              var lineElement = lineElements[lineElementsIdx++];
              if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                if (heightChanged)
                  lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
                var height = config.lineHeight * this.session.getRowLength(row) + "px";
                if (lineElement.style.height != height) {
                  heightChanged = true;
                  lineElement.style.height = height;
                }
              }
              row++;
            }
            if (heightChanged) {
              while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
              }
            }
          };
          Text2.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = config.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (!oldConfig || oldConfig.lastRow < config.firstRow)
              return this.update(config);
            if (config.lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldConfig.lastRow > config.lastRow)
              for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (config.lastRow > oldConfig.lastRow) {
              this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
            }
            this.$highlightIndentGuide();
          };
          Text2.prototype.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var line = this.$lines.createCell(row, config, this.session);
              var lineEl = line.element;
              this.dom.removeChildren(lineEl);
              dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
              dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
              this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
              if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
              } else {
                lineEl.className = "ace_line";
              }
              fragment.push(line);
              row++;
            }
            return fragment;
          };
          Text2.prototype.update = function(config) {
            this.$lines.moveContainer(config);
            this.config = config;
            var firstRow = config.firstRow;
            var lastRow = config.lastRow;
            var lines = this.$lines;
            while (lines.getLength())
              lines.pop();
            lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
          };
          Text2.prototype.$renderToken = function(parent, screenColumn, token, value) {
            var self2 = this;
            var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            var valueFragment = this.dom.createFragment(this.element);
            var m;
            var i = 0;
            while (m = re.exec(value)) {
              var tab = m[1];
              var simpleSpace = m[2];
              var controlCharacter = m[3];
              var cjkSpace = m[4];
              var cjk = m[5];
              if (!self2.showSpaces && simpleSpace)
                continue;
              var before = i != m.index ? value.slice(i, m.index) : "";
              i = m.index + m[0].length;
              if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
              }
              if (tab) {
                var tabSize = self2.session.getScreenTabSize(screenColumn + m.index);
                valueFragment.appendChild(self2.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
              } else if (simpleSpace) {
                if (self2.showSpaces) {
                  var span = this.dom.createElement("span");
                  span.className = "ace_invisible ace_invisible_space";
                  span.textContent = lang.stringRepeat(self2.SPACE_CHAR, simpleSpace.length);
                  valueFragment.appendChild(span);
                } else {
                  valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
                }
              } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self2.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
              } else if (cjkSpace) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = self2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self2.showSpaces ? self2.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
              } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
              }
            }
            valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
            if (!isTextToken(token.type)) {
              var classes = "ace_" + token.type.replace(/\./g, " ace_");
              var span = this.dom.createElement("span");
              if (token.type == "fold") {
                span.style.width = token.value.length * this.config.characterWidth + "px";
                span.setAttribute("title", nls("Unfold code"));
              }
              span.className = classes;
              span.appendChild(valueFragment);
              parent.appendChild(span);
            } else {
              parent.appendChild(valueFragment);
            }
            return screenColumn + value.length;
          };
          Text2.prototype.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
              return value;
            if (value[0] == " ") {
              cols -= cols % this.tabSize;
              var count = cols / this.tabSize;
              for (var i = 0; i < count; i++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            } else if (value[0] == "	") {
              for (var i = 0; i < cols; i++) {
                parent.appendChild(this.$tabStrings["	"].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            }
            this.$highlightIndentGuide();
            return value;
          };
          Text2.prototype.$highlightIndentGuide = function() {
            if (!this.$highlightIndentGuides || !this.displayIndentGuides)
              return;
            this.$highlightIndentGuideMarker = {
              indentLevel: void 0,
              start: void 0,
              end: void 0,
              dir: void 0
            };
            var lines = this.session.doc.$lines;
            if (!lines)
              return;
            var cursor = this.session.selection.getCursor();
            var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
            var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
            this.$highlightIndentGuideMarker = {
              indentLevel: elementIndentLevel,
              start: cursor.row
            };
            var bracketHighlight = this.session.$bracketHighlight;
            if (bracketHighlight) {
              var ranges = this.session.$bracketHighlight.ranges;
              for (var i = 0; i < ranges.length; i++) {
                if (cursor.row !== ranges[i].start.row) {
                  this.$highlightIndentGuideMarker.end = ranges[i].start.row;
                  if (cursor.row > ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.dir = -1;
                  } else {
                    this.$highlightIndentGuideMarker.dir = 1;
                  }
                  break;
                }
              }
            }
            if (!this.$highlightIndentGuideMarker.end) {
              if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i = cursor.row + 1; i < lines.length; i++) {
                  var line = lines[i];
                  var currentIndent = /^\s*/.exec(line)[0].length;
                  if (line !== "") {
                    this.$highlightIndentGuideMarker.end = i;
                    if (currentIndent <= initialIndent)
                      break;
                  }
                }
              }
            }
            this.$renderHighlightIndentGuide();
          };
          Text2.prototype.$clearActiveIndentGuide = function() {
            var cells = this.$lines.cells;
            for (var i = 0; i < cells.length; i++) {
              var cell = cells[i];
              var childNodes = cell.element.childNodes;
              if (childNodes.length > 0) {
                for (var j = 0; j < childNodes.length; j++) {
                  if (childNodes[j].classList && childNodes[j].classList.contains("ace_indent-guide-active")) {
                    childNodes[j].classList.remove("ace_indent-guide-active");
                    break;
                  }
                }
              }
            }
          };
          Text2.prototype.$setIndentGuideActive = function(cell, indentLevel) {
            var line = this.session.doc.getLine(cell.row);
            if (line !== "") {
              var childNodes = cell.element.childNodes;
              if (childNodes) {
                var node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide"))
                  node.classList.add("ace_indent-guide-active");
              }
            }
          };
          Text2.prototype.$renderHighlightIndentGuide = function() {
            if (!this.$lines)
              return;
            var cells = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
            if (indentLevel !== 0) {
              if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i = 0; i < cells.length; i++) {
                  var cell = cells[i];
                  if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                    if (cell.row >= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              } else {
                for (var i = cells.length - 1; i >= 0; i--) {
                  var cell = cells[i];
                  if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                    if (cell.row <= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              }
            }
          };
          Text2.prototype.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            return lineEl;
          };
          Text2.prototype.$renderWrappedLine = function(parent, tokens, splits) {
            var chars = 0;
            var split = 0;
            var splitChars = splits[0];
            var screenColumn = 0;
            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              var value = token.value;
              if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                  continue;
                chars -= value.length;
              }
              if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
              } else {
                while (chars + value.length >= splitChars) {
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                  value = value.substring(splitChars - chars);
                  chars = splitChars;
                  lineEl = this.$createLineElement();
                  parent.appendChild(lineEl);
                  lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("", splits.indent), this.element));
                  split++;
                  screenColumn = 0;
                  splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                  chars += value.length;
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                }
              }
            }
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
              this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
          };
          Text2.prototype.$renderSimpleLine = function(parent, tokens) {
            var screenColumn = 0;
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              var value = token.value;
              if (i == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                  continue;
              }
              if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
              screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
          };
          Text2.prototype.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            parent.appendChild(overflowEl);
          };
          Text2.prototype.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false)
              foldLine = this.session.getFoldLine(row);
            if (foldLine)
              var tokens = this.$getFoldLineTokens(row, foldLine);
            else
              var tokens = this.session.getTokens(row);
            var lastLineEl = parent;
            if (tokens.length) {
              var splits = this.session.getRowSplitData(row);
              if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
              } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                  lastLineEl = this.$createLineElement();
                  parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
              }
            } else if (this.$useLineGroups()) {
              lastLineEl = this.$createLineElement();
              parent.appendChild(lastLineEl);
            }
            if (this.showEOL && lastLineEl) {
              if (foldLine)
                row = foldLine.end.row;
              var invisibleEl = this.dom.createElement("span");
              invisibleEl.className = "ace_invisible ace_invisible_eol";
              invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
              lastLineEl.appendChild(invisibleEl);
            }
          };
          Text2.prototype.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];
            function addTokens(tokens2, from, to) {
              var idx = 0, col = 0;
              while (col + tokens2[idx].value.length < from) {
                col += tokens2[idx].value.length;
                idx++;
                if (idx == tokens2.length)
                  return;
              }
              if (col != from) {
                var value = tokens2[idx].value.substring(from - col);
                if (value.length > to - from)
                  value = value.substring(0, to - from);
                renderTokens.push({
                  type: tokens2[idx].type,
                  value
                });
                col = from + value.length;
                idx += 1;
              }
              while (col < to && idx < tokens2.length) {
                var value = tokens2[idx].value;
                if (value.length + col > to) {
                  renderTokens.push({
                    type: tokens2[idx].type,
                    value: value.substring(0, to - col)
                  });
                } else
                  renderTokens.push(tokens2[idx]);
                col += value.length;
                idx += 1;
              }
            }
            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
              if (placeholder != null) {
                renderTokens.push({
                  type: "fold",
                  value: placeholder
                });
              } else {
                if (isNewRow)
                  tokens = session.getTokens(row2);
                if (tokens.length)
                  addTokens(tokens, lastColumn, column);
              }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
            return renderTokens;
          };
          Text2.prototype.$useLineGroups = function() {
            return this.session.getUseWrapMode();
          };
          return Text2;
        }()
      );
      Text.prototype.EOF_CHAR = "";
      Text.prototype.EOL_CHAR_LF = "";
      Text.prototype.EOL_CHAR_CRLF = "";
      Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
      Text.prototype.TAB_CHAR = "";
      Text.prototype.SPACE_CHAR = "";
      Text.prototype.$padding = 0;
      Text.prototype.MAX_LINE_LENGTH = 1e4;
      Text.prototype.showInvisibles = false;
      Text.prototype.showSpaces = false;
      Text.prototype.showTabs = false;
      Text.prototype.showEOL = false;
      Text.prototype.displayIndentGuides = true;
      Text.prototype.$highlightIndentGuides = true;
      Text.prototype.$tabStrings = [];
      Text.prototype.destroy = {};
      Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;
      oop.implement(Text.prototype, EventEmitter);
      exports2.Text = Text;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var Cursor = (
        /** @class */
        function() {
          function Cursor2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_cursor-layer";
            parentEl.appendChild(this.element);
            this.isVisible = false;
            this.isBlinking = true;
            this.blinkInterval = 1e3;
            this.smoothBlinking = false;
            this.cursors = [];
            this.cursor = this.addCursor();
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.$updateCursors = this.$updateOpacity.bind(this);
          }
          Cursor2.prototype.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
          };
          Cursor2.prototype.$startCssAnimation = function() {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              cursors[i].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = true;
            setTimeout((function() {
              if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
              }
            }).bind(this));
          };
          Cursor2.prototype.$stopCssAnimation = function() {
            this.$isAnimating = false;
            dom.removeCssClass(this.element, "ace_animate-blinking");
          };
          Cursor2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Cursor2.prototype.setSession = function(session) {
            this.session = session;
          };
          Cursor2.prototype.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
              this.isBlinking = blinking;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
              this.blinkInterval = blinkInterval;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
              this.smoothBlinking = smoothBlinking;
              dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
              this.$updateCursors(true);
              this.restartTimer();
            }
          };
          Cursor2.prototype.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
          };
          Cursor2.prototype.removeCursor = function() {
            if (this.cursors.length > 1) {
              var el = this.cursors.pop();
              el.parentNode.removeChild(el);
              return el;
            }
          };
          Cursor2.prototype.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = false;
              dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            update(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
              this.$stopCssAnimation();
              return;
            }
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = true;
              setTimeout((function() {
                if (this.$isSmoothBlinking) {
                  dom.addCssClass(this.element, "ace_smooth-blinking");
                }
              }).bind(this));
            }
            if (dom.HAS_CSS_ANIMATION) {
              this.$startCssAnimation();
            } else {
              var blink = (function() {
                this.timeoutId = setTimeout(function() {
                  update(false);
                }, 0.6 * this.blinkInterval);
              }).bind(this);
              this.intervalId = setInterval(function() {
                update(true);
                blink();
              }, this.blinkInterval);
              blink();
            }
          };
          Cursor2.prototype.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session)
              return { left: 0, top: 0 };
            if (!position)
              position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return { left: cursorLeft, top: cursorTop };
          };
          Cursor2.prototype.isCursorInView = function(pixelPos, config) {
            return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
          };
          Cursor2.prototype.update = function(config) {
            this.config = config;
            var selections = this.session.$selectionMarkers;
            var i = 0, cursorIndex = 0;
            if (selections === void 0 || selections.length === 0) {
              selections = [{ cursor: null }];
            }
            for (var i = 0, n = selections.length; i < n; i++) {
              var pixelPos = this.getPixelPosition(selections[i].cursor, true);
              if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                continue;
              }
              var element = this.cursors[cursorIndex++] || this.addCursor();
              var style = element.style;
              if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                  dom.setStyle(style, "display", "none");
                } else {
                  dom.setStyle(style, "display", "block");
                  dom.translate(element, pixelPos.left, pixelPos.top);
                  dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                  dom.setStyle(style, "height", config.lineHeight + "px");
                }
              } else {
                this.drawCursor(element, pixelPos, config, selections[i], this.session);
              }
            }
            while (this.cursors.length > cursorIndex)
              this.removeCursor();
            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
          };
          Cursor2.prototype.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
              this.overwrite = overwrite;
              if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
              else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
          };
          Cursor2.prototype.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
          };
          return Cursor2;
        }()
      );
      Cursor.prototype.$padding = 0;
      Cursor.prototype.drawCursor = null;
      exports2.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var MAX_SCROLL_H = 32768;
      var Scrollbar = (
        /** @class */
        function() {
          function Scrollbar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "ace_scrollbar-inner";
            this.inner.textContent = "";
            this.element.appendChild(this.inner);
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addListener(this.element, "scroll", this.onScroll.bind(this));
            event.addListener(this.element, "mousedown", event.preventDefault);
          }
          Scrollbar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return Scrollbar2;
        }()
      );
      oop.implement(Scrollbar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollTop = this.element.scrollTop;
              if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
              }
              this._emit("scroll", { data: this.scrollTop });
            }
            this.skipEvent = false;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.element.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
              this.coeff = MAX_SCROLL_H / height;
              height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
              this.coeff = 1;
            }
            this.inner.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
              this.skipEvent = true;
              this.scrollTop = scrollTop;
              this.element.scrollTop = scrollTop * this.coeff;
            }
          };
          return VScrollBar2;
        }(Scrollbar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.height = renderer.$scrollbarWidth;
            _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
            return _this;
          }
          HScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollLeft = this.element.scrollLeft;
              this._emit("scroll", { data: this.scrollLeft });
            }
            this.skipEvent = false;
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.element.style.width = width + "px";
          };
          HScrollBar2.prototype.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
              this.skipEvent = true;
              this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
          };
          return HScrollBar2;
        }(Scrollbar)
      );
      exports2.ScrollBar = VScrollBar;
      exports2.ScrollBarV = VScrollBar;
      exports2.ScrollBarH = HScrollBar;
      exports2.VScrollBar = VScrollBar;
      exports2.HScrollBar = HScrollBar;
    });
    ace.define("ace/scrollbar_custom", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
      var ScrollBar = (
        /** @class */
        function() {
          function ScrollBar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_sb" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "";
            this.element.appendChild(this.inner);
            this.VScrollWidth = 12;
            this.HScrollHeight = 12;
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
          }
          ScrollBar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return ScrollBar2;
        }()
      );
      oop.implement(ScrollBar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            _this.parent = parent;
            _this.width = _this.VScrollWidth;
            _this.renderer = renderer;
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onMouseDown = function(eType, e) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e) !== 0 || e.detail === 2) {
              return;
            }
            if (e.target === this.inner) {
              var self2 = this;
              var mousePageY = e.clientY;
              var onMouseMove = function(e2) {
                mousePageY = e2.clientY;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startY = e.clientY;
              var startTop = this.thumbTop;
              var onScrollInterval = function() {
                if (mousePageY === void 0)
                  return;
                var scrollTop = self2.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self2.scrollTop)
                  return;
                self2._emit("scroll", { data: scrollTop });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e);
            }
            var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
            return event.preventDefault(e);
          };
          VScrollBar2.prototype.getHeight = function() {
            return this.height;
          };
          VScrollBar2.prototype.scrollTopFromThumbTop = function(thumbTop) {
            var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
            scrollTop = scrollTop >> 0;
            if (scrollTop < 0) {
              scrollTop = 0;
            } else if (scrollTop > this.pageHeight - this.viewHeight) {
              scrollTop = this.pageHeight - this.viewHeight;
            }
            return scrollTop;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.height = Math.max(0, height);
            this.slideHeight = this.height;
            this.viewHeight = this.height;
            this.setScrollHeight(this.pageHeight, true);
          };
          VScrollBar2.prototype.setScrollHeight = function(height, force) {
            if (this.pageHeight === height && !force)
              return;
            this.pageHeight = height;
            this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
            if (this.thumbHeight > this.slideHeight)
              this.thumbHeight = this.slideHeight;
            if (this.thumbHeight < 15)
              this.thumbHeight = 15;
            this.inner.style.height = this.thumbHeight + "px";
            if (this.scrollTop > this.pageHeight - this.viewHeight) {
              this.scrollTop = this.pageHeight - this.viewHeight;
              if (this.scrollTop < 0)
                this.scrollTop = 0;
              this._emit("scroll", { data: this.scrollTop });
            }
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            this.scrollTop = scrollTop;
            if (scrollTop < 0)
              scrollTop = 0;
            this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
            this.inner.style.top = this.thumbTop + "px";
          };
          return VScrollBar2;
        }(ScrollBar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.scrollWidth = 0;
            _this.height = _this.HScrollHeight;
            _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
            _this.renderer = renderer;
            return _this;
          }
          HScrollBar2.prototype.onMouseDown = function(eType, e) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e) !== 0 || e.detail === 2) {
              return;
            }
            if (e.target === this.inner) {
              var self2 = this;
              var mousePageX = e.clientX;
              var onMouseMove = function(e2) {
                mousePageX = e2.clientX;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startX = e.clientX;
              var startLeft = this.thumbLeft;
              var onScrollInterval = function() {
                if (mousePageX === void 0)
                  return;
                var scrollLeft = self2.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self2.scrollLeft)
                  return;
                self2._emit("scroll", { data: scrollLeft });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e);
            }
            var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
            return event.preventDefault(e);
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.scrollLeftFromThumbLeft = function(thumbLeft) {
            var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
            scrollLeft = scrollLeft >> 0;
            if (scrollLeft < 0) {
              scrollLeft = 0;
            } else if (scrollLeft > this.pageWidth - this.viewWidth) {
              scrollLeft = this.pageWidth - this.viewWidth;
            }
            return scrollLeft;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.width = Math.max(0, width);
            this.element.style.width = this.width + "px";
            this.slideWidth = this.width;
            this.viewWidth = this.width;
            this.setScrollWidth(this.pageWidth, true);
          };
          HScrollBar2.prototype.setScrollWidth = function(width, force) {
            if (this.pageWidth === width && !force)
              return;
            this.pageWidth = width;
            this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
            if (this.thumbWidth > this.slideWidth)
              this.thumbWidth = this.slideWidth;
            if (this.thumbWidth < 15)
              this.thumbWidth = 15;
            this.inner.style.width = this.thumbWidth + "px";
            if (this.scrollLeft > this.pageWidth - this.viewWidth) {
              this.scrollLeft = this.pageWidth - this.viewWidth;
              if (this.scrollLeft < 0)
                this.scrollLeft = 0;
              this._emit("scroll", { data: this.scrollLeft });
            }
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            this.scrollLeft = scrollLeft;
            if (scrollLeft < 0)
              scrollLeft = 0;
            this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
            this.inner.style.left = this.thumbLeft + "px";
          };
          return HScrollBar2;
        }(ScrollBar)
      );
      HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
      exports2.ScrollBar = VScrollBar;
      exports2.ScrollBarV = VScrollBar;
      exports2.ScrollBarH = HScrollBar;
      exports2.VScrollBar = VScrollBar;
      exports2.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("./lib/event");
      var RenderLoop = (
        /** @class */
        function() {
          function RenderLoop2(onRender, win) {
            this.onRender = onRender;
            this.pending = false;
            this.changes = 0;
            this.$recursionLimit = 2;
            this.window = win || window;
            var _self = this;
            this._flush = function(ts) {
              _self.pending = false;
              var changes = _self.changes;
              if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
              }
              if (_self.changes) {
                if (_self.$recursionLimit-- < 0)
                  return;
                _self.schedule();
              } else {
                _self.$recursionLimit = 2;
              }
            };
          }
          RenderLoop2.prototype.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
              event.nextFrame(this._flush);
              this.pending = true;
            }
          };
          RenderLoop2.prototype.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
          };
          return RenderLoop2;
        }()
      );
      exports2.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 512;
      var USE_OBSERVER = typeof ResizeObserver == "function";
      var L = 200;
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(parentEl) {
            this.el = dom.createElement("div");
            this.$setMeasureNodeStyles(this.el.style, true);
            this.$main = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$main.style);
            this.$measureNode = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$measureNode.style);
            this.el.appendChild(this.$main);
            this.el.appendChild(this.$measureNode);
            parentEl.appendChild(this.el);
            this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
            this.$characterSize = { width: 0, height: 0 };
            if (USE_OBSERVER)
              this.$addObserver();
            else
              this.checkForSizeChanges();
          }
          FontMetrics2.prototype.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";
            if (useragent.isIE < 8) {
              style["font-family"] = "inherit";
            } else {
              style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
          };
          FontMetrics2.prototype.checkForSizeChanges = function(size) {
            if (size === void 0)
              size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
              this.$measureNode.style.fontWeight = "bold";
              var boldSize = this.$measureSizes();
              this.$measureNode.style.fontWeight = "";
              this.$characterSize = size;
              this.charSizes = /* @__PURE__ */ Object.create(null);
              this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
              this._emit("changeCharacterSize", { data: size });
            }
          };
          FontMetrics2.prototype.$addObserver = function() {
            var self2 = this;
            this.$observer = new window.ResizeObserver(function(e) {
              self2.checkForSizeChanges();
            });
            this.$observer.observe(this.$measureNode);
          };
          FontMetrics2.prototype.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
              return this.$pollSizeChangesTimer;
            var self2 = this;
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
              self2.checkForSizeChanges();
              event.onIdle(cb, 500);
            }, 500);
          };
          FontMetrics2.prototype.setPolling = function(val) {
            if (val) {
              this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
              clearInterval(this.$pollSizeChangesTimer);
              this.$pollSizeChangesTimer = 0;
            }
          };
          FontMetrics2.prototype.$measureSizes = function(node) {
            var size = {
              height: (node || this.$measureNode).clientHeight,
              width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0)
              return null;
            return size;
          };
          FontMetrics2.prototype.$measureCharWidth = function(ch) {
            this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
          };
          FontMetrics2.prototype.getCharacterWidth = function(ch) {
            var w = this.charSizes[ch];
            if (w === void 0) {
              w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w;
          };
          FontMetrics2.prototype.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer)
              this.$observer.disconnect();
            if (this.el && this.el.parentNode)
              this.el.parentNode.removeChild(this.el);
          };
          FontMetrics2.prototype.$getZoom = function(element) {
            if (!element || !element.parentElement)
              return 1;
            return (window.getComputedStyle(element).zoom || 1) * this.$getZoom(element.parentElement);
          };
          FontMetrics2.prototype.$initTransformMeasureNodes = function() {
            var t = function(t2, l) {
              return ["div", {
                style: "position: absolute;top:" + t2 + "px;left:" + l + "px;"
              }];
            };
            this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
          };
          FontMetrics2.prototype.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
              var zoom = this.$getZoom(this.el);
              clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
              var det = l1[1] * l2[0] - l1[0] * l2[1];
              return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
              ];
            }
            function sub(a2, b2) {
              return [a2[0] - b2[0], a2[1] - b2[1]];
            }
            function add(a2, b2) {
              return [a2[0] + b2[0], a2[1] + b2[1]];
            }
            function mul(a2, b2) {
              return [a2 * b2[0], a2 * b2[1]];
            }
            if (!this.els)
              this.$initTransformMeasureNodes();
            function p(el) {
              var r = el.getBoundingClientRect();
              return [r.left, r.top];
            }
            var a = p(this.els[0]);
            var b = p(this.els[1]);
            var c = p(this.els[2]);
            var d = p(this.els[3]);
            var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
            var m1 = mul(1 + h[0], sub(b, a));
            var m2 = mul(1 + h[1], sub(c, a));
            if (elPos) {
              var x = elPos;
              var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
              var ut = add(mul(x[0], m1), mul(x[1], m2));
              return add(mul(1 / k / L, ut), a);
            }
            var u = sub(clientPos, a);
            var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
            return mul(L, f);
          };
          return FontMetrics2;
        }()
      );
      FontMetrics.prototype.$characterSize = { width: 0, height: 0 };
      oop.implement(FontMetrics.prototype, EventEmitter);
      exports2.FontMetrics = FontMetrics;
    });
    ace.define("ace/css/editor-css", ["require", "exports", "module"], function(require2, exports2, module2) {
      module2.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}
.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    max-width: 100%;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(60em, 66vw);
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
    white-space: pre;
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}`;
    });
    ace.define("ace/layer/decorators", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Decorator = (
        /** @class */
        function() {
          function Decorator2(parent, renderer) {
            this.canvas = dom.createElement("canvas");
            this.renderer = renderer;
            this.pixelRatio = 1;
            this.maxHeight = renderer.layerConfig.maxHeight;
            this.lineHeight = renderer.layerConfig.lineHeight;
            this.canvasHeight = parent.parent.scrollHeight;
            this.heightRatio = this.canvasHeight / this.maxHeight;
            this.canvasWidth = parent.width;
            this.minDecorationHeight = 2 * this.pixelRatio | 0;
            this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
            this.canvas.width = this.canvasWidth;
            this.canvas.height = this.canvasHeight;
            this.canvas.style.top = "0px";
            this.canvas.style.right = "0px";
            this.canvas.style.zIndex = "7px";
            this.canvas.style.position = "absolute";
            this.colors = {};
            this.colors.dark = {
              "error": "rgba(255, 18, 18, 1)",
              "warning": "rgba(18, 136, 18, 1)",
              "info": "rgba(18, 18, 136, 1)"
            };
            this.colors.light = {
              "error": "rgb(255,51,51)",
              "warning": "rgb(32,133,72)",
              "info": "rgb(35,68,138)"
            };
            parent.element.appendChild(this.canvas);
          }
          Decorator2.prototype.$updateDecorators = function(config) {
            var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
            if (config) {
              this.maxHeight = config.maxHeight;
              this.lineHeight = config.lineHeight;
              this.canvasHeight = config.height;
              var allLineHeight = (config.lastRow + 1) * this.lineHeight;
              if (allLineHeight < this.canvasHeight) {
                this.heightRatio = 1;
              } else {
                this.heightRatio = this.canvasHeight / this.maxHeight;
              }
            }
            var ctx = this.canvas.getContext("2d");
            function compare(a, b) {
              if (a.priority < b.priority)
                return -1;
              if (a.priority > b.priority)
                return 1;
              return 0;
            }
            var annotations = this.renderer.session.$annotations;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (annotations) {
              var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
              };
              annotations.forEach(function(item) {
                item.priority = priorities[item.type] || null;
              });
              annotations = annotations.sort(compare);
              var foldData = this.renderer.session.$foldData;
              for (var i = 0; i < annotations.length; i++) {
                var row = annotations[i].row;
                var compensateFold = this.compensateFoldRows(row, foldData);
                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y1 = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y2 = Math.round(((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio);
                var height = y2 - y1;
                if (height < this.minDecorationHeight) {
                  var yCenter = (y1 + y2) / 2 | 0;
                  if (yCenter < this.halfMinDecorationHeight) {
                    yCenter = this.halfMinDecorationHeight;
                  } else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {
                    yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                  }
                  y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                  y2 = Math.round(yCenter + this.halfMinDecorationHeight);
                }
                ctx.fillStyle = colors[annotations[i].type] || null;
                ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);
              }
            }
            var cursor = this.renderer.session.selection.getCursor();
            if (cursor) {
              var compensateFold = this.compensateFoldRows(cursor.row, foldData);
              var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(0, currentY, this.canvasWidth, 2);
            }
          };
          Decorator2.prototype.compensateFoldRows = function(row, foldData) {
            var compensateFold = 0;
            if (foldData && foldData.length > 0) {
              for (var j = 0; j < foldData.length; j++) {
                if (row > foldData[j].start.row && row < foldData[j].end.row) {
                  compensateFold += row - foldData[j].start.row;
                } else if (row >= foldData[j].end.row) {
                  compensateFold += foldData[j].end.row - foldData[j].start.row;
                }
              }
            }
            return compensateFold;
          };
          return Decorator2;
        }()
      );
      oop.implement(Decorator.prototype, EventEmitter);
      exports2.Decorator = Decorator;
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/scrollbar_custom", "ace/scrollbar_custom", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/css/editor-css", "ace/layer/decorators", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var config = require2("./config");
      var GutterLayer = require2("./layer/gutter").Gutter;
      var MarkerLayer = require2("./layer/marker").Marker;
      var TextLayer = require2("./layer/text").Text;
      var CursorLayer = require2("./layer/cursor").Cursor;
      var HScrollBar = require2("./scrollbar").HScrollBar;
      var VScrollBar = require2("./scrollbar").VScrollBar;
      var HScrollBarCustom = require2("./scrollbar_custom").HScrollBar;
      var VScrollBarCustom = require2("./scrollbar_custom").VScrollBar;
      var RenderLoop = require2("./renderloop").RenderLoop;
      var FontMetrics = require2("./layer/font_metrics").FontMetrics;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var editorCss = require2("./css/editor-css");
      var Decorator = require2("./layer/decorators").Decorator;
      var useragent = require2("./lib/useragent");
      dom.importCssString(editorCss, "ace_editor.css", false);
      var VirtualRenderer = (
        /** @class */
        function() {
          function VirtualRenderer2(container, theme) {
            var _self = this;
            this.container = container || dom.createElement("div");
            dom.addCssClass(this.container, "ace_editor");
            if (dom.HI_DPI)
              dom.addCssClass(this.container, "ace_hidpi");
            this.setTheme(theme);
            if (config.get("useStrictCSP") == null)
              config.set("useStrictCSP", false);
            this.$gutter = dom.createElement("div");
            this.$gutter.className = "ace_gutter";
            this.container.appendChild(this.$gutter);
            this.$gutter.setAttribute("aria-hidden", true);
            this.scroller = dom.createElement("div");
            this.scroller.className = "ace_scroller";
            this.container.appendChild(this.scroller);
            this.content = dom.createElement("div");
            this.content.className = "ace_content";
            this.scroller.appendChild(this.content);
            this.$gutterLayer = new GutterLayer(this.$gutter);
            this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
            this.$markerBack = new MarkerLayer(this.content);
            var textLayer = this.$textLayer = new TextLayer(this.content);
            this.canvas = textLayer.element;
            this.$markerFront = new MarkerLayer(this.content);
            this.$cursorLayer = new CursorLayer(this.content);
            this.$horizScroll = false;
            this.$vScroll = false;
            this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.on("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.on("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            this.scrollTop = 0;
            this.scrollLeft = 0;
            this.cursorPos = {
              row: 0,
              column: 0
            };
            this.$fontMetrics = new FontMetrics(this.container);
            this.$textLayer.$setFontMetrics(this.$fontMetrics);
            this.$textLayer.on("changeCharacterSize", function(e) {
              _self.updateCharacterSize();
              _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
              _self._signal("changeCharacterSize", e);
            });
            this.$size = {
              width: 0,
              height: 0,
              scrollerHeight: 0,
              scrollerWidth: 0,
              $dirty: true
            };
            this.layerConfig = {
              width: 1,
              padding: 0,
              firstRow: 0,
              firstRowScreen: 0,
              lastRow: 0,
              lineHeight: 0,
              characterWidth: 0,
              minHeight: 1,
              maxHeight: 1,
              offset: 0,
              height: 1,
              gutterOffset: 1
            };
            this.scrollMargin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.margin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.$keepTextAreaAtCursor = !useragent.isIOS;
            this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
            this.$loop.schedule(this.CHANGE_FULL);
            this.updateCharacterSize();
            this.setPadding(4);
            this.$addResizeObserver();
            config.resetOptions(this);
            config._signal("renderer", this);
          }
          VirtualRenderer2.prototype.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
              this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
              this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }
            this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
          };
          VirtualRenderer2.prototype.setSession = function(session) {
            if (this.session)
              this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
              session.setScrollTop(-this.scrollMargin.top);
            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
              return;
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          };
          VirtualRenderer2.prototype.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === void 0)
              lastRow = Infinity;
            if (!this.$changedLines) {
              this.$changedLines = {
                firstRow,
                lastRow
              };
            } else {
              if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;
              if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
              if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
              else
                return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
              return;
            this.$loop.schedule(this.CHANGE_LINES);
          };
          VirtualRenderer2.prototype.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          };
          VirtualRenderer2.prototype.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
          };
          VirtualRenderer2.prototype.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
          };
          VirtualRenderer2.prototype.updateFull = function(force) {
            if (force)
              this.$renderChanges(this.CHANGE_FULL, true);
            else
              this.$loop.schedule(this.CHANGE_FULL);
          };
          VirtualRenderer2.prototype.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
          };
          VirtualRenderer2.prototype.$updateSizeAsync = function() {
            if (this.$loop.pending)
              this.$size.$dirty = true;
            else
              this.onResize();
          };
          VirtualRenderer2.prototype.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
              return;
            else if (this.resizing > 0)
              this.resizing++;
            else
              this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
              height = el.clientHeight || el.scrollHeight;
            if (!width)
              width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);
            if (this.$resizeTimer)
              this.$resizeTimer.cancel();
            if (!this.$size.scrollerHeight || !width && !height)
              return this.resizing = 0;
            if (force)
              this.$gutterLayer.$padding = null;
            if (force)
              this.$renderChanges(changes | this.$changes, true);
            else
              this.$loop.schedule(changes | this.$changes);
            if (this.resizing)
              this.resizing = 0;
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            if (this.$customScrollbar) {
              this.$updateCustomScrollbar(true);
            }
          };
          VirtualRenderer2.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= this.$extraHeight || 0;
            var changes = 0;
            var size = this.$size;
            var oldSize = {
              width: size.width,
              height: size.height,
              scrollerHeight: size.scrollerHeight,
              scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
              size.height = height;
              changes |= this.CHANGE_SIZE;
              size.scrollerHeight = size.height;
              if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
              this.scrollBarV.setHeight(size.scrollerHeight);
              this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
              changes = changes | this.CHANGE_SCROLL;
            }
            if (width && (force || size.width != width)) {
              changes |= this.CHANGE_SIZE;
              size.width = width;
              if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
              this.gutterWidth = gutterWidth;
              dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
              dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
              size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
              dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
              var right = this.scrollBarV.getWidth() + "px";
              dom.setStyle(this.scrollBarH.element.style, "right", right);
              dom.setStyle(this.scroller.style, "right", right);
              dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
              this.scrollBarH.setWidth(size.scrollerWidth);
              if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
              }
            }
            size.$dirty = !width || !height;
            if (changes)
              this._signal("resize", oldSize);
            return changes;
          };
          VirtualRenderer2.prototype.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth)
              this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else {
              this.$computeLayerConfig();
            }
          };
          VirtualRenderer2.prototype.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
          };
          VirtualRenderer2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.setOption("animatedScroll", shouldAnimate);
          };
          VirtualRenderer2.prototype.getAnimatedScroll = function() {
            return this.$animatedScroll;
          };
          VirtualRenderer2.prototype.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
          };
          VirtualRenderer2.prototype.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
          };
          VirtualRenderer2.prototype.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
          };
          VirtualRenderer2.prototype.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
          };
          VirtualRenderer2.prototype.getHighlightIndentGuides = function() {
            return this.getOption("highlightIndentGuides");
          };
          VirtualRenderer2.prototype.setHighlightIndentGuides = function(highlight) {
            this.setOption("highlightIndentGuides", highlight);
          };
          VirtualRenderer2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
          };
          VirtualRenderer2.prototype.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
          };
          VirtualRenderer2.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.setOption("printMarginColumn", showPrintMargin);
          };
          VirtualRenderer2.prototype.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
          };
          VirtualRenderer2.prototype.getShowGutter = function() {
            return this.getOption("showGutter");
          };
          VirtualRenderer2.prototype.setShowGutter = function(show) {
            return this.setOption("showGutter", show);
          };
          VirtualRenderer2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          VirtualRenderer2.prototype.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
          };
          VirtualRenderer2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          VirtualRenderer2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          VirtualRenderer2.prototype.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
              return;
            if (!this.$printMarginEl) {
              var containerEl = dom.createElement("div");
              containerEl.className = "ace_layer ace_print-margin-layer";
              this.$printMarginEl = dom.createElement("div");
              this.$printMarginEl.className = "ace_print-margin";
              containerEl.appendChild(this.$printMarginEl);
              this.content.insertBefore(containerEl, this.content.firstChild);
            }
            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            if (this.session && this.session.$wrap == -1)
              this.adjustWrapLimit();
          };
          VirtualRenderer2.prototype.getContainerElement = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.getMouseEventTarget = function() {
            return this.scroller;
          };
          VirtualRenderer2.prototype.getTextAreaContainer = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed)
              return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
              dom.translate(this.textarea, -100, 0);
              return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos)
              return;
            if (composition && composition.markerRange)
              pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            var config2 = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config2.offset;
            var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
            if (posTop < 0 || posTop > config2.height - h) {
              dom.translate(this.textarea, 0, 0);
              return;
            }
            var w = 1;
            var maxTop = this.$size.height - h;
            if (!composition) {
              posTop += this.lineHeight;
            } else {
              if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
              } else {
                posTop += this.lineHeight + 2;
              }
            }
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w)
              posLeft = this.$size.scrollerWidth - w;
            posLeft += this.gutterWidth + this.margin.left;
            dom.setStyle(style, "height", h + "px");
            dom.setStyle(style, "width", w + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
          };
          VirtualRenderer2.prototype.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
          };
          VirtualRenderer2.prototype.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          };
          VirtualRenderer2.prototype.getLastFullyVisibleRow = function() {
            var config2 = this.layerConfig;
            var lastRow = config2.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config2.lineHeight;
            if (top - this.session.getScrollTop() > config2.height - config2.lineHeight)
              return lastRow - 1;
            return lastRow;
          };
          VirtualRenderer2.prototype.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
          };
          VirtualRenderer2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
          };
          VirtualRenderer2.prototype.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
              this.session.setScrollTop(-sm.top);
            this.updateFull();
          };
          VirtualRenderer2.prototype.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
          };
          VirtualRenderer2.prototype.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
              scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
              if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
              }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          };
          VirtualRenderer2.prototype.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          };
          VirtualRenderer2.prototype.freeze = function() {
            this.$frozen = true;
          };
          VirtualRenderer2.prototype.unfreeze = function() {
            this.$frozen = false;
          };
          VirtualRenderer2.prototype.$renderChanges = function(changes, force) {
            if (this.$changes) {
              changes |= this.$changes;
              this.$changes = 0;
            }
            if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
              this.$changes |= changes;
              return;
            }
            if (this.$size.$dirty) {
              this.$changes |= changes;
              return this.onResize(true);
            }
            if (!this.lineHeight) {
              this.$textLayer.checkForSizeChanges();
            }
            this._signal("beforeRender", changes);
            if (this.session && this.session.$bidiHandler)
              this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var config2 = this.layerConfig;
            if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
              changes |= this.$computeLayerConfig() | this.$loop.clear();
              if (config2.firstRow != this.layerConfig.firstRow && config2.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config2.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                if (st > 0) {
                  this.scrollTop = st;
                  changes = changes | this.CHANGE_SCROLL;
                  changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
              }
              config2 = this.layerConfig;
              this.$updateScrollBarV();
              if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              var width = config2.width + 2 * this.$padding + "px";
              var height = config2.minHeight + "px";
              dom.setStyle(this.content.style, "width", width);
              dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
              if (this.enableKeyboardAccessibility)
                this.scroller.className += this.keyboardFocusClassName;
            }
            if (changes & this.CHANGE_FULL) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_SCROLL) {
              this.$changedLines = null;
              if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config2);
              else
                this.$textLayer.scrollLines(config2);
              if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                  this.$gutterLayer.update(config2);
                else
                  this.$gutterLayer.scrollLines(config2);
              }
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_TEXT) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_LINES) {
              if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_CURSOR) {
              if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            }
            if (changes & this.CHANGE_CURSOR) {
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
              this.$markerFront.update(config2);
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
              this.$markerBack.update(config2);
            }
            this._signal("afterRender", changes);
          };
          VirtualRenderer2.prototype.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
              desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
              desiredHeight = this.$maxPixelHeight;
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
              if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
              }
              var w = this.container.clientWidth;
              this.container.style.height = desiredHeight + "px";
              this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
              this.desiredHeight = desiredHeight;
              this._signal("autosize");
            }
          };
          VirtualRenderer2.prototype.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;
            var longestLine = this.$getLongestLine();
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
              this.$horizScroll = horizScroll;
              this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll;
            if (this.$maxLines && this.lineHeight > 1)
              this.$autosize();
            var minHeight = size.scrollerHeight + this.lineHeight;
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            maxHeight += scrollPastEnd;
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
              firstRow = foldLine.start.row;
            }
            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;
            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
            offset = this.scrollTop - firstRowScreen * lineHeight;
            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged)
              changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
              changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
              this._signal("scrollbarVisibilityChanged");
              if (vScrollChanged)
                longestLine = this.$getLongestLine();
            }
            this.layerConfig = {
              width: longestLine,
              padding: this.$padding,
              firstRow,
              firstRowScreen,
              lastRow,
              lineHeight,
              characterWidth: this.characterWidth,
              minHeight,
              maxHeight,
              offset,
              gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
              height: this.$size.scrollerHeight
            };
            if (this.session.$bidiHandler)
              this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
            return changes;
          };
          VirtualRenderer2.prototype.$updateLines = function() {
            if (!this.$changedLines)
              return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;
            var layerConfig = this.layerConfig;
            if (firstRow > layerConfig.lastRow + 1) {
              return;
            }
            if (lastRow < layerConfig.firstRow) {
              return;
            }
            if (lastRow === Infinity) {
              if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
              this.$textLayer.update(layerConfig);
              return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
          };
          VirtualRenderer2.prototype.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
              charCount += 1;
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
              charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
          };
          VirtualRenderer2.prototype.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          };
          VirtualRenderer2.prototype.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
          };
          VirtualRenderer2.prototype.addGutterDecoration = function(row, className) {
            this.$gutterLayer.addGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.removeGutterDecoration = function(row, className) {
            this.$gutterLayer.removeGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.updateBreakpoints = function(rows) {
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
          };
          VirtualRenderer2.prototype.hideCursor = function() {
            this.$cursorLayer.hideCursor();
          };
          VirtualRenderer2.prototype.showCursor = function() {
            this.$cursorLayer.showCursor();
          };
          VirtualRenderer2.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
          };
          VirtualRenderer2.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
              return;
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var newLeft = pos.left;
            var newTop = pos.top;
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            if (this.$scrollAnimation) {
              this.$stopAnimation = true;
            }
            var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            if (currentTop + topMargin > newTop) {
              if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
              if (newTop === 0)
                newTop = -this.scrollMargin.top;
              this.session.setScrollTop(newTop);
            } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
              if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
              this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }
            var currentLeft = this.scrollLeft;
            var twoCharsWidth = 2 * this.layerConfig.characterWidth;
            if (newLeft - twoCharsWidth < currentLeft) {
              newLeft -= twoCharsWidth;
              if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
              }
              this.session.setScrollLeft(newLeft);
            } else {
              newLeft += twoCharsWidth;
              if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
              } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
              }
            }
          };
          VirtualRenderer2.prototype.getScrollTop = function() {
            return this.session.getScrollTop();
          };
          VirtualRenderer2.prototype.getScrollLeft = function() {
            return this.session.getScrollLeft();
          };
          VirtualRenderer2.prototype.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
          };
          VirtualRenderer2.prototype.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          };
          VirtualRenderer2.prototype.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
          };
          VirtualRenderer2.prototype.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
              cursor = { row: cursor, column: 0 };
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h * (alignment || 0);
            this.session.setScrollTop(offset);
            return offset;
          };
          VirtualRenderer2.prototype.$calcSteps = function(fromValue, toValue) {
            var i = 0;
            var l = this.STEPS;
            var steps = [];
            var func = function(t, x_min, dx) {
              return dx * (Math.pow(t - 1, 3) + 1) + x_min;
            };
            for (i = 0; i < l; ++i)
              steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
            return steps;
          };
          VirtualRenderer2.prototype.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
            var offset = pos.top;
            if (center)
              offset -= this.$size.scrollerHeight / 2;
            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
              this.animateScrolling(initialScroll, callback);
          };
          VirtualRenderer2.prototype.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
              return;
            var _self = this;
            if (fromValue == toValue)
              return;
            if (this.$scrollAnimation) {
              var oldSteps = this.$scrollAnimation.steps;
              if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                  return;
              }
            }
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = { from: fromValue, to: toValue, steps };
            clearInterval(this.$timer);
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            function endAnimation() {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              _self.$stopAnimation = false;
              callback && callback();
            }
            this.$timer = setInterval(function() {
              if (_self.$stopAnimation) {
                endAnimation();
                return;
              }
              if (!_self.session)
                return clearInterval(_self.$timer);
              if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
              } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
              } else {
                endAnimation();
              }
            }, 10);
          };
          VirtualRenderer2.prototype.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
              this.$loop.schedule(this.CHANGE_SCROLL);
              this.scrollTop = scrollTop;
            }
          };
          VirtualRenderer2.prototype.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
              this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
          };
          VirtualRenderer2.prototype.scrollTo = function(x, y) {
            this.session.setScrollTop(y);
            this.session.setScrollLeft(x);
          };
          VirtualRenderer2.prototype.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
          };
          VirtualRenderer2.prototype.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
              return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
              return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
              return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
              return true;
          };
          VirtualRenderer2.prototype.pixelToScreenCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x, y]);
              x = p[1] - this.gutterWidth - this.margin.left;
              y = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            return { row, column: col, side: offset - col > 0 ? 1 : -1, offsetX };
          };
          VirtualRenderer2.prototype.screenToTextCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x, y]);
              x = p[1] - this.gutterWidth - this.margin.left;
              y = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
          };
          VirtualRenderer2.prototype.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);
            var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
            var y = pos.row * this.lineHeight;
            return {
              pageX: canvasPos.left + x - this.scrollLeft,
              pageY: canvasPos.top + y - this.scrollTop
            };
          };
          VirtualRenderer2.prototype.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) {
              composition.cssText = this.textarea.style.cssText;
            }
            if (composition.useTextareaForIME == void 0)
              composition.useTextareaForIME = this.$useTextareaForIME;
            if (this.$useTextareaForIME) {
              dom.addCssClass(this.textarea, "ace_composition");
              this.textarea.style.cssText = "";
              this.$moveTextAreaToCursor();
              this.$cursorLayer.element.style.display = "none";
            } else {
              composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
            }
          };
          VirtualRenderer2.prototype.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
          };
          VirtualRenderer2.prototype.hideComposition = function() {
            if (!this.$composition)
              return;
            if (this.$composition.markerId)
              this.session.removeMarker(this.$composition.markerId);
            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            var cursor = this.session.selection.cursor;
            this.removeExtraToken(cursor.row, cursor.column);
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
          };
          VirtualRenderer2.prototype.setGhostText = function(text, position) {
            var cursor = this.session.selection.cursor;
            var insertPosition = position || { row: cursor.row, column: cursor.column };
            this.removeGhostText();
            var textLines = text.split("\n");
            this.addToken(textLines[0], "ghost_text", insertPosition.row, insertPosition.column);
            this.$ghostText = {
              text,
              position: {
                row: insertPosition.row,
                column: insertPosition.column
              }
            };
            if (textLines.length > 1) {
              this.$ghostTextWidget = {
                text: textLines.slice(1).join("\n"),
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text"
              };
              this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
              var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
              var el = this.container;
              var height = el.getBoundingClientRect().height;
              var ghostTextHeight = textLines.length * this.lineHeight;
              var fitsY = ghostTextHeight < height - pixelPosition.top;
              if (fitsY)
                return;
              if (ghostTextHeight < height) {
                this.scrollBy(0, (textLines.length - 1) * this.lineHeight);
              } else {
                this.scrollBy(0, pixelPosition.top);
              }
            }
          };
          VirtualRenderer2.prototype.removeGhostText = function() {
            if (!this.$ghostText)
              return;
            var position = this.$ghostText.position;
            this.removeExtraToken(position.row, position.column);
            if (this.$ghostTextWidget) {
              this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
              this.$ghostTextWidget = null;
            }
            this.$ghostText = null;
          };
          VirtualRenderer2.prototype.addToken = function(text, type, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = { type, value: text };
            var tokens = session.getTokens(row);
            if (column == null || !tokens.length) {
              tokens.push(newToken);
            } else {
              var l = 0;
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                l += token.value.length;
                if (column <= l) {
                  var diff = token.value.length - (l - column);
                  var before = token.value.slice(0, diff);
                  var after = token.value.slice(diff);
                  tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                  break;
                }
              }
            }
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.removeExtraToken = function(row, column) {
            this.session.bgTokenizer.lines[row] = null;
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent("themeChange", { theme });
            if (!theme || typeof theme == "string") {
              var moduleName = theme || this.$options.theme.initialValue;
              config.loadModule(["theme", moduleName], afterLoad);
            } else {
              afterLoad(theme);
            }
            function afterLoad(module3) {
              if (_self.$themeId != theme)
                return cb && cb();
              if (!module3 || !module3.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
              if (module3.$id)
                _self.$themeId = module3.$id;
              dom.importCssString(module3.cssText, module3.cssClass, _self.container);
              if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
              var padding = "padding" in module3 ? module3.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
              if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
              _self.$theme = module3.cssClass;
              _self.theme = module3;
              dom.addCssClass(_self.container, module3.cssClass);
              dom.setCssClass(_self.container, "ace_dark", module3.isDark);
              if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
              }
              _self._dispatchEvent("themeLoaded", { theme: module3 });
              cb && cb();
            }
          };
          VirtualRenderer2.prototype.getTheme = function() {
            return this.$themeId;
          };
          VirtualRenderer2.prototype.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
          };
          VirtualRenderer2.prototype.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
          };
          VirtualRenderer2.prototype.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
          };
          VirtualRenderer2.prototype.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
          };
          VirtualRenderer2.prototype.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
          };
          VirtualRenderer2.prototype.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
            this.removeAllListeners();
            this.container.textContent = "";
            this.setOption("useResizeObserver", false);
          };
          VirtualRenderer2.prototype.$updateCustomScrollbar = function(val) {
            var _self = this;
            this.$horizScroll = this.$vScroll = null;
            this.scrollBarV.element.remove();
            this.scrollBarH.element.remove();
            if (this.$scrollDecorator) {
              delete this.$scrollDecorator;
            }
            if (val === true) {
              this.scrollBarV = new VScrollBarCustom(this.container, this);
              this.scrollBarH = new HScrollBarCustom(this.container, this);
              this.scrollBarV.setHeight(this.$size.scrollerHeight);
              this.scrollBarH.setWidth(this.$size.scrollerWidth);
              this.scrollBarV.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
              });
              this.$scrollDecorator = new Decorator(this.scrollBarV, this);
              this.$scrollDecorator.$updateDecorators();
            } else {
              this.scrollBarV = new VScrollBar(this.container, this);
              this.scrollBarH = new HScrollBar(this.container, this);
              this.scrollBarV.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
              });
            }
          };
          VirtualRenderer2.prototype.$addResizeObserver = function() {
            if (!window.ResizeObserver || this.$resizeObserver)
              return;
            var self2 = this;
            this.$resizeTimer = lang.delayedCall(function() {
              if (!self2.destroyed)
                self2.onResize();
            }, 50);
            this.$resizeObserver = new window.ResizeObserver(function(e) {
              var w = e[0].contentRect.width;
              var h = e[0].contentRect.height;
              if (Math.abs(self2.$size.width - w) > 1 || Math.abs(self2.$size.height - h) > 1) {
                self2.$resizeTimer.delay();
              } else {
                self2.$resizeTimer.cancel();
              }
            });
            this.$resizeObserver.observe(this.container);
          };
          return VirtualRenderer2;
        }()
      );
      VirtualRenderer.prototype.CHANGE_CURSOR = 1;
      VirtualRenderer.prototype.CHANGE_MARKER = 2;
      VirtualRenderer.prototype.CHANGE_GUTTER = 4;
      VirtualRenderer.prototype.CHANGE_SCROLL = 8;
      VirtualRenderer.prototype.CHANGE_LINES = 16;
      VirtualRenderer.prototype.CHANGE_TEXT = 32;
      VirtualRenderer.prototype.CHANGE_SIZE = 64;
      VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
      VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
      VirtualRenderer.prototype.CHANGE_FULL = 512;
      VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
      VirtualRenderer.prototype.$changes = 0;
      VirtualRenderer.prototype.$padding = null;
      VirtualRenderer.prototype.$frozen = false;
      VirtualRenderer.prototype.STEPS = 8;
      oop.implement(VirtualRenderer.prototype, EventEmitter);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
        useResizeObserver: {
          set: function(value) {
            if (!value && this.$resizeObserver) {
              this.$resizeObserver.disconnect();
              this.$resizeTimer.cancel();
              this.$resizeTimer = this.$resizeObserver = null;
            } else if (value && !this.$resizeObserver) {
              this.$addResizeObserver();
            }
          }
        },
        animatedScroll: { initialValue: false },
        showInvisibles: {
          set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function(val) {
            if (typeof val == "number")
              this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        useSvgGutterIcons: {
          set: function(value) {
            this.$gutterLayer.$useSvgGutterIcons = value;
          },
          initialValue: false
        },
        showFoldedAnnotations: {
          set: function(value) {
            this.$gutterLayer.$showFoldedAnnotations = value;
          },
          initialValue: false
        },
        fadeFoldWidgets: {
          set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
              this.$textLayer.$highlightIndentGuide();
            } else {
              this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        hScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function(size) {
            if (typeof size == "number")
              size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {
          set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }
        },
        maxLines: {
          set: function(val) {
            this.updateFull();
          }
        },
        minLines: {
          set: function(val) {
            if (!(this.$minLines < 562949953421311))
              this.$minLines = 0;
            this.updateFull();
          }
        },
        maxPixelHeight: {
          set: function(val) {
            this.updateFull();
          },
          initialValue: 0
        },
        scrollPastEnd: {
          set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
              return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {
          set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }
        },
        customScrollbar: {
          set: function(val) {
            this.$updateCustomScrollbar(val);
          },
          initialValue: false
        },
        theme: {
          set: function(val) {
            this.setTheme(val);
          },
          get: function() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        },
        hasCssTransforms: {},
        useTextareaForIME: {
          initialValue: !useragent.isMobile && !useragent.isIE
        }
      });
      exports2.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("../lib/oop");
      var net = require2("../lib/net");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var config = require2("../config");
      function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
          return new Blob([script], { "type": "application/javascript" });
        } catch (e) {
          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
          var blobBuilder = new BlobBuilder();
          blobBuilder.append(script);
          return blobBuilder.getBlob("application/javascript");
        }
      }
      function createWorker(workerUrl) {
        if (typeof Worker == "undefined")
          return { postMessage: function() {
          }, terminate: function() {
          } };
        if (config.get("loadWorkerFromBlob")) {
          var blob = $workerBlob(workerUrl);
          var URL = window.URL || window.webkitURL;
          var blobURL = URL.createObjectURL(blob);
          return new Worker(blobURL);
        }
        return new Worker(workerUrl);
      }
      var WorkerClient = function(worker) {
        if (!worker.postMessage)
          worker = this.$createWorkerFromOldConfig.apply(this, arguments);
        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
          if (require2.nameToUrl && !require2.toUrl)
            require2.toUrl = require2.nameToUrl;
          if (config.get("packaged") || !require2.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod, "worker");
          } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(require2.toUrl("ace/worker/worker.js", null, "_"));
            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
              tlns[ns] = normalizePath(require2.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
          }
          this.$worker = createWorker(workerUrl);
          if (importScripts) {
            this.send("importScripts", importScripts);
          }
          this.$worker.postMessage({
            init: true,
            tlns,
            module: mod,
            classname
          });
          return this.$worker;
        };
        this.onMessage = function(e) {
          var msg = e.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, { data: msg.data });
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function(err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path) {
          return net.qualifyURL(path);
        };
        this.terminate = function() {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker.onerror = function(e) {
            e.preventDefault();
          };
          this.$worker = null;
          if (this.$doc)
            this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function(cmd, args) {
          this.$worker.postMessage({ command: cmd, args });
        };
        this.call = function(cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function(event, data) {
          try {
            if (data.data && data.data.err)
              data.data.err = { message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code };
            this.$worker && this.$worker.postMessage({ event, data: { data: data.data } });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function(doc) {
          if (this.$doc)
            this.terminate();
          this.$doc = doc;
          this.call("setValue", [doc.getValue()]);
          doc.on("change", this.changeListener, true);
        };
        this.changeListener = function(delta) {
          if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
          }
          if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
          else
            this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function() {
          var q = this.deltaQueue;
          if (!q)
            return;
          this.deltaQueue = null;
          if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else
            this.emit("change", { data: q });
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var messageBuffer = [];
        var workerClient = new WorkerClient({
          messageBuffer,
          terminate: function() {
          },
          postMessage: function(e) {
            messageBuffer.push(e);
            if (!main)
              return;
            if (emitSync)
              setTimeout(processNext);
            else
              processNext();
          }
        });
        workerClient.setEmitSync = function(val) {
          emitSync = val;
        };
        var processNext = function() {
          var msg = messageBuffer.shift();
          if (msg.command)
            main[msg.command].apply(main, msg.args);
          else if (msg.event)
            sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
          workerClient.onMessage({ data: msg });
        };
        sender.callback = function(data, callbackId) {
          this.postMessage({ type: "call", id: callbackId, data });
        };
        sender.emit = function(name, data) {
          this.postMessage({ type: "event", name, data });
        };
        config.loadModule(["worker", mod], function(Main) {
          main = new Main[classname](sender);
          while (messageBuffer.length)
            processNext();
        });
        return workerClient;
      };
      exports2.UIWorkerClient = UIWorkerClient;
      exports2.WorkerClient = WorkerClient;
      exports2.createWorker = createWorker;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require2, exports2, module2) {
      "use strict";
      var Range = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var oop = require2("./lib/oop");
      var PlaceHolder = (
        /** @class */
        function() {
          function PlaceHolder2(session, length, pos, others, mainClass, othersClass) {
            var _self = this;
            this.length = length;
            this.session = session;
            this.doc = session.getDocument();
            this.mainClass = mainClass;
            this.othersClass = othersClass;
            this.$onUpdate = this.onUpdate.bind(this);
            this.doc.on("change", this.$onUpdate, true);
            this.$others = others;
            this.$onCursorChange = function() {
              setTimeout(function() {
                _self.onCursorChange();
              });
            };
            this.$pos = pos;
            var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
            this.$undoStackDepth = undoStack.length;
            this.setup();
            session.selection.on("changeCursor", this.$onCursorChange);
          }
          PlaceHolder2.prototype.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
              session.selection.toSingleRange();
            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
              var anchor = doc.createAnchor(other.row, other.column);
              anchor.$insertRight = true;
              anchor.detach();
              _self.others.push(anchor);
            });
            session.setUndoSelect(false);
          };
          PlaceHolder2.prototype.showOtherMarkers = function() {
            if (this.othersActive)
              return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
              anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            });
          };
          PlaceHolder2.prototype.hideOtherMarkers = function() {
            if (!this.othersActive)
              return;
            this.othersActive = false;
            for (var i = 0; i < this.others.length; i++) {
              this.session.removeMarker(this.others[i].markerId);
            }
          };
          PlaceHolder2.prototype.onUpdate = function(delta) {
            if (this.$updating)
              return this.updateAnchors(delta);
            var range = delta;
            if (range.start.row !== range.end.row)
              return;
            if (range.start.row !== this.pos.row)
              return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            this.updateAnchors(delta);
            if (inMainRange)
              this.length += lengthDiff;
            if (inMainRange && !this.session.$fromUndo) {
              if (delta.action === "insert") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.insertMergedLines(newPos, delta.lines);
                }
              } else if (delta.action === "remove") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
              }
            }
            this.$updating = false;
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i = this.others.length; i--; )
              this.others[i].onChange(delta);
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateMarkers = function() {
            if (this.$updating)
              return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
              session.removeMarker(pos.markerId);
              pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i = this.others.length; i--; )
              updateMarker(this.others[i], this.othersClass);
          };
          PlaceHolder2.prototype.onCursorChange = function(event) {
            if (this.$updating || !this.session)
              return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
              this.showOtherMarkers();
              this._emit("cursorEnter", event);
            } else {
              this.hideOtherMarkers();
              this._emit("cursorLeave", event);
            }
          };
          PlaceHolder2.prototype.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.off("change", this.$onUpdate);
            this.session.selection.off("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
          };
          PlaceHolder2.prototype.cancel = function() {
            if (this.$undoStackDepth === -1)
              return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
            for (var i = 0; i < undosRequired; i++) {
              undoManager.undo(this.session, true);
            }
            if (this.selectionBefore)
              this.session.selection.fromJSON(this.selectionBefore);
          };
          return PlaceHolder2;
        }()
      );
      oop.implement(PlaceHolder.prototype, EventEmitter);
      exports2.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        if (ctrl && useragent.isMac)
          button = ev.button;
        if (e.editor.inMultiSelectMode && button == 2) {
          e.editor.textInput.onContextMenu(e.domEvent);
          return;
        }
        if (!ctrl && !alt && !accel) {
          if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
          return;
        }
        if (button !== 0)
          return;
        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
        var mouseX = e.x, mouseY = e.y;
        var onMouseSelection = function(e2) {
          mouseX = e2.clientX;
          mouseY = e2.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
          else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
              return;
          } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection)
            return;
          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
          }
          editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
              selection.substractPoint(tmpSel.cursor);
            else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e.stop();
          editor.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
              return;
            screenCursor = newCursor;
            editor.selection.moveToPosition(cursor2);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
              rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
          };
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
          }
          if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
          else
            selection.moveToPosition(pos);
          screenCursor = { row: -1, column: -1 };
          var onMouseSelectionEnd = function(e2) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
              rectSel = [selection.toOrientedRange()];
            if (initialRange) {
              editor.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
              selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function() {
            onSelectionInterval();
          }, 20);
          return e.preventDefault();
        }
      }
      exports2.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require2, exports2, module2) {
      exports2.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function(editor) {
          editor.selectMoreLines(-1);
        },
        bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function(editor) {
          editor.selectMoreLines(1);
        },
        bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function(editor) {
          editor.selectMore(-1);
        },
        bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function(editor) {
          editor.selectMore(1);
        },
        bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function(editor) {
          editor.selectMore(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function(editor) {
          editor.selectMore(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split selection into lines",
        exec: function(editor) {
          if (editor.multiSelect.rangeCount > 1)
            editor.multiSelect.joinSelections();
          else
            editor.multiSelect.splitIntoLines();
        },
        bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
        readOnly: true
      }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) {
          editor.multiSelect.splitIntoLines();
        },
        readOnly: true
      }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function(editor) {
          editor.alignCursors();
        },
        bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
        scrollIntoView: "cursor"
      }, {
        name: "findAll",
        description: "Find all",
        exec: function(editor) {
          editor.findAll();
        },
        bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
        scrollIntoView: "cursor",
        readOnly: true
      }];
      exports2.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function(editor) {
          editor.exitMultiSelectMode();
        },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor) {
          return editor && editor.inMultiSelectMode;
        }
      }];
      var HashHandler = require2("../keyboard/hash_handler").HashHandler;
      exports2.keyboardHandler = new HashHandler(exports2.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require2, exports2, module2) {
      var RangeList = require2("./range_list").RangeList;
      var Range = require2("./range").Range;
      var Selection = require2("./selection").Selection;
      var onMouseDown = require2("./mouse/multi_select_handler").onMouseDown;
      var event = require2("./lib/event");
      var lang = require2("./lib/lang");
      var commands = require2("./commands/multi_select_commands");
      exports2.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = require2("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = require2("./edit_session").EditSession;
      (function() {
        this.getSelectionMarkers = function() {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
          if (!range)
            return;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor)
            range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length)
            this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length)
            this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function() {
          var removed = this.rangeList.merge();
          if (removed.length)
            this.$onRemoveRange(removed);
        };
        this.$onAddRange = function(range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", { range });
        };
        this.$onRemoveRange = function(removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", { ranges: removed });
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
          if (this.rangeList)
            return;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function() {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function() {
          var ranges = this.ranges.length ? this.ranges : [this.getRange()];
          var newRanges = [];
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
              newRanges.push(range.clone());
            } else {
              newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
              while (++row < endRow)
                newRanges.push(this.getLineRange(row, true));
              newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 && !this.isBackwards())
              newRanges = newRanges.reverse();
          }
          this.toSingleRange();
          for (var i = newRanges.length; i--; )
            this.addRange(newRanges[i]);
        };
        this.joinSelections = function() {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0)
            startColumn = 0;
          if (startRow < 0)
            startRow = 0;
          if (startRow == endRow)
            includeEmptyLines = true;
          var docEnd;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd))
                break;
              docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards)
            rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
              end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty())
                start++;
            }
            for (var i = end; i >= start; i--) {
              if (rectSel[i].isEmpty())
                rectSel.splice(i, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = require2("./editor").Editor;
      (function() {
        this.updateSelectionMarkers = function() {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
          if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
          if (!range.marker)
            return;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
              continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
              markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e) {
          this.addSelectionMarker(e.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e) {
          this.removeSelectionMarkers(e.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e) {
          if (this.inMultiSelectMode)
            return;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e) {
          if (this.session.multiSelect.inVirtualMode)
            return;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e) {
          var command = e.command;
          var editor = e.editor;
          if (!editor.multiSelect)
            return;
          if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
          } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
          } else {
            result = command.multiSelectAction(editor, e.args || {});
          }
          return result;
        };
        this.forEachSelection = function(cmd, args, options) {
          if (this.inVirtualSelectionMode)
            return;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i = ranges.length; i--; ) {
            if ($byLines) {
              while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== void 0)
              result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function() {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
              buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
              text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function(e, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
              return;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
              this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
              this.multiSelect.mergeOverlappingRanges();
          }
        };
        this.findAll = function(needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == void 0) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length)
            return 0;
          var selection = this.multiSelect;
          if (!additive)
            selection.toSingleRange(ranges[0]);
          for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
          if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
          return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip)
              var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove)
            this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
              var tmp = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp.start.row;
              range.start.column = tmp.start.column;
              range.end.row = tmp.end.row;
              range.end.column = tmp.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0)
            words.unshift(words.pop());
          else
            words.push(words.shift());
          for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
          sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
              return;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip)
            this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr);
              } while (/[=:]/.test(line) && ++lr < max);
              do {
                line = this.session.getLine(fr);
              } while (/[=:]/.test(line) && --fr > 0);
              if (fr < 0)
                fr = 0;
              if (lr >= max)
                lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function(r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
              var p = r.cursor;
              var line2 = session.getLine(p.row);
              var spaceOffset = line2.substr(p.column).search(/\S/g);
              if (spaceOffset == -1)
                spaceOffset = 0;
              if (p.column > maxCol)
                maxCol = p.column;
              if (spaceOffset < minSpace)
                minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function(r, i) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d = spaceOffsets[i] - minSpace;
              if (l > d)
                session.insert(p, lang.stringRepeat(" ", l - d));
              else
                session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function(lines, forceLeft) {
          var isLeftAligned = true, isRightAligned = true;
          var startW, textW, endW;
          return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
              return [line];
            if (startW == null) {
              startW = m[1].length;
              textW = m[2].length;
              endW = m[3].length;
              return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
              isRightAligned = false;
            if (startW != m[1].length)
              isLeftAligned = false;
            if (startW > m[1].length)
              startW = m[1].length;
            if (textW < m[2].length)
              textW = m[2].length;
            if (endW > m[3].length)
              endW = m[3].length;
            return m;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports2.onSessionChange = function(e) {
        var session = e.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
          else
            this.$onSingleSelect();
        }
      };
      function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
          return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports2.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
        if (!editor.textInput)
          return;
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e) {
          var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
          if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
              editor.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        }, editor);
        event.addListener(el, "keyup", reset, editor);
        event.addListener(el, "blur", reset, editor);
        function reset(e) {
          if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports2.MultiSelect = MultiSelect;
      require2("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
          set: function(val) {
            MultiSelect(this);
            if (val) {
              this.on("mousedown", onMouseDown);
            } else {
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        },
        enableBlockSelect: {
          set: function(val) {
            this.$blockSelectEnabled = val;
          },
          value: true
        }
      });
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range = require2("../../range").Range;
      var FoldMode = exports2.FoldMode = function() {
      };
      (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line))
            return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
            return "end";
          return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function(session, row, column) {
          var re = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re);
          if (startLevel == -1)
            return;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re);
            if (level == -1)
              continue;
            if (level <= startLevel) {
              var token = session.getTokenAt(row, 0);
              if (!token || token.type !== "string")
                break;
            }
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
          var start = { row, column: column + 1 };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end)
            return;
          var fw = session.foldWidgets[end.row];
          if (fw == null)
            fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
          var end = { row, column };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start)
            return;
          start.column++;
          end.column--;
          return Range.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var LineWidgets = require2("../line_widgets").LineWidgets;
      var dom = require2("../lib/dom");
      var Range = require2("../range").Range;
      var nls = require2("../config").nls;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = first + last >> 1;
          var c = comparator(needle, array[mid]);
          if (c > 0)
            first = mid + 1;
          else if (c < 0)
            last = mid - 1;
          else
            return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
          return;
        var i = binarySearch(annotations, { row, column: -1 }, Range.comparePoints);
        if (i < 0)
          i = -i - 1;
        if (i >= annotations.length)
          i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0)
          i = annotations.length - 1;
        var annotation = annotations[i];
        if (!annotation || !dir)
          return;
        if (annotation.row === row) {
          do {
            annotation = annotations[i += dir];
          } while (annotation && annotation.row === row);
          if (!annotation)
            return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports2.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        if (!session.widgetManager) {
          session.widgetManager = new LineWidgets(session);
          session.widgetManager.attach(editor);
        }
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w2) {
          return w2.type == "errorMarker";
        })[0];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return;
        } else {
          gutterAnno = {
            text: [nls("Looks good!")],
            className: "ace_ok"
          };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div"),
          type: "errorMarker"
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        el.innerHTML = gutterAnno.text.join("<br>");
        el.appendChild(dom.createElement("div"));
        var kb = function(_, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return { command: "null" };
          }
        };
        w.destroy = function() {
          if (editor.$mouseHandler.isMousePressed)
            return;
          editor.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w);
          editor.off("changeSelection", w.destroy);
          editor.off("changeSession", w.destroy);
          editor.off("mouseup", w.destroy);
          editor.off("change", w.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w.destroy);
        editor.on("changeSession", w.destroy);
        editor.on("mouseup", w.destroy);
        editor.on("change", w.destroy);
        editor.session.widgetManager.addLineWidget(w);
        w.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
      };
      dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config", "ace/loader_build"], function(require2, exports2, module2) {
      "use strict";
      require2("./loader_build")(exports2);
      var dom = require2("./lib/dom");
      var Range = require2("./range").Range;
      var Editor = require2("./editor").Editor;
      var EditSession = require2("./edit_session").EditSession;
      var UndoManager = require2("./undomanager").UndoManager;
      var Renderer = require2("./virtual_renderer").VirtualRenderer;
      require2("./worker/worker_client");
      require2("./keyboard/hash_handler");
      require2("./placeholder");
      require2("./multi_select");
      require2("./mode/folding/fold_mode");
      require2("./theme/textmate");
      require2("./ext/error_marker");
      exports2.config = require2("./config");
      exports2.edit = function(el, options) {
        if (typeof el == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el)
            throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor)
          return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
          value = el.textContent;
          el.innerHTML = "";
        }
        var doc = exports2.createEditSession(value);
        var editor = new Editor(new Renderer(el), doc, options);
        var env = {
          document: doc,
          editor,
          onResize: editor.resize.bind(editor, null)
        };
        if (oldNode)
          env.textarea = oldNode;
        editor.on("destroy", function() {
          env.editor.container.env = null;
        });
        editor.container.env = editor.env = env;
        return editor;
      };
      exports2.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
      };
      exports2.Range = Range;
      exports2.Editor = Editor;
      exports2.EditSession = EditSession;
      exports2.UndoManager = UndoManager;
      exports2.VirtualRenderer = Renderer;
      exports2.version = exports2.config.version;
    });
    (function() {
      ace.require(["ace/ace"], function(a) {
        if (a) {
          a.config.init(true);
          a.define = ace.define;
        }
        var global2 = /* @__PURE__ */ function() {
          return this;
        }();
        if (!global2 && typeof window != "undefined")
          global2 = window;
        if (!global2 && typeof self != "undefined")
          global2 = self;
        if (!global2.ace)
          global2.ace = a;
        for (var key in a)
          if (a.hasOwnProperty(key))
            global2.ace[key] = a[key];
        global2.ace["default"] = global2.ace;
        if (typeof module == "object" && typeof exports == "object" && module) {
          module.exports = global2.ace;
        }
      });
    })();
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/react-ace/lib/editorOptions.js
var require_editorOptions = __commonJS({
  "node_modules/react-ace/lib/editorOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAceInstance = exports.debounce = exports.editorEvents = exports.editorOptions = void 0;
    var editorOptions = [
      "minLines",
      "maxLines",
      "readOnly",
      "highlightActiveLine",
      "tabSize",
      "enableBasicAutocompletion",
      "enableLiveAutocompletion",
      "enableSnippets"
    ];
    exports.editorOptions = editorOptions;
    var editorEvents = [
      "onChange",
      "onFocus",
      "onInput",
      "onBlur",
      "onCopy",
      "onPaste",
      "onSelectionChange",
      "onCursorChange",
      "onScroll",
      "handleOptions",
      "updateRef"
    ];
    exports.editorEvents = editorEvents;
    var getAceInstance = function() {
      var ace2;
      if (typeof window === "undefined") {
        global.window = {};
        ace2 = require_ace();
        delete global.window;
      } else if (window.ace) {
        ace2 = window.ace;
        ace2.acequire = window.ace.require || window.ace.acequire;
      } else {
        ace2 = require_ace();
      }
      return ace2;
    };
    exports.getAceInstance = getAceInstance;
    var debounce = function(fn, delay) {
      var timer = null;
      return function() {
        var context = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(context, args);
        }, delay);
      };
    };
    exports.debounce = debounce;
  }
});

// node_modules/react-ace/lib/ace.js
var require_ace2 = __commonJS({
  "node_modules/react-ace/lib/ace.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ace_builds_1 = require_ace();
    var PropTypes = require_prop_types();
    var React = require_react();
    var isEqual = require_lodash();
    var editorOptions_1 = require_editorOptions();
    var ace2 = (0, editorOptions_1.getAceInstance)();
    var ReactAce = (
      /** @class */
      function(_super) {
        __extends(ReactAce2, _super);
        function ReactAce2(props) {
          var _this = _super.call(this, props) || this;
          editorOptions_1.editorEvents.forEach(function(method) {
            _this[method] = _this[method].bind(_this);
          });
          _this.debounce = editorOptions_1.debounce;
          return _this;
        }
        ReactAce2.prototype.isInShadow = function(node) {
          var parent = node && node.parentNode;
          while (parent) {
            if (parent.toString() === "[object ShadowRoot]") {
              return true;
            }
            parent = parent.parentNode;
          }
          return false;
        };
        ReactAce2.prototype.componentDidMount = function() {
          var _this = this;
          var _a = this.props, className = _a.className, onBeforeLoad = _a.onBeforeLoad, onValidate = _a.onValidate, mode = _a.mode, focus = _a.focus, theme = _a.theme, fontSize = _a.fontSize, value = _a.value, defaultValue = _a.defaultValue, showGutter = _a.showGutter, wrapEnabled = _a.wrapEnabled, showPrintMargin = _a.showPrintMargin, _b = _a.scrollMargin, scrollMargin = _b === void 0 ? [0, 0, 0, 0] : _b, keyboardHandler = _a.keyboardHandler, onLoad = _a.onLoad, commands = _a.commands, annotations = _a.annotations, markers = _a.markers, placeholder = _a.placeholder;
          this.editor = ace2.edit(this.refEditor);
          if (onBeforeLoad) {
            onBeforeLoad(ace2);
          }
          var editorProps = Object.keys(this.props.editorProps);
          for (var i = 0; i < editorProps.length; i++) {
            this.editor[editorProps[i]] = this.props.editorProps[editorProps[i]];
          }
          if (this.props.debounceChangePeriod) {
            this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod);
          }
          this.editor.renderer.setScrollMargin(scrollMargin[0], scrollMargin[1], scrollMargin[2], scrollMargin[3]);
          if (this.isInShadow(this.refEditor)) {
            this.editor.renderer.attachToShadowRoot();
          }
          this.editor.getSession().setMode(typeof mode === "string" ? "ace/mode/".concat(mode) : mode);
          if (theme && theme !== "")
            this.editor.setTheme("ace/theme/".concat(theme));
          this.editor.setFontSize(typeof fontSize === "number" ? "".concat(fontSize, "px") : fontSize);
          this.editor.getSession().setValue(!defaultValue ? value || "" : defaultValue);
          if (this.props.navigateToFileEnd) {
            this.editor.navigateFileEnd();
          }
          this.editor.renderer.setShowGutter(showGutter);
          this.editor.getSession().setUseWrapMode(wrapEnabled);
          this.editor.setShowPrintMargin(showPrintMargin);
          this.editor.on("focus", this.onFocus);
          this.editor.on("blur", this.onBlur);
          this.editor.on("copy", this.onCopy);
          this.editor.on("paste", this.onPaste);
          this.editor.on("change", this.onChange);
          this.editor.on("input", this.onInput);
          if (placeholder) {
            this.updatePlaceholder();
          }
          this.editor.getSession().selection.on("changeSelection", this.onSelectionChange);
          this.editor.getSession().selection.on("changeCursor", this.onCursorChange);
          if (onValidate) {
            this.editor.getSession().on("changeAnnotation", function() {
              var annotations2 = _this.editor.getSession().getAnnotations();
              _this.props.onValidate(annotations2);
            });
          }
          this.editor.session.on("changeScrollTop", this.onScroll);
          this.editor.getSession().setAnnotations(annotations || []);
          if (markers && markers.length > 0) {
            this.handleMarkers(markers);
          }
          var availableOptions = this.editor.$options;
          editorOptions_1.editorOptions.forEach(function(option) {
            if (availableOptions.hasOwnProperty(option)) {
              _this.editor.setOption(option, _this.props[option]);
            } else if (_this.props[option]) {
              console.warn("ReactAce: editor option ".concat(option, " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?"));
            }
          });
          this.handleOptions(this.props);
          if (Array.isArray(commands)) {
            commands.forEach(function(command) {
              if (typeof command.exec === "string") {
                _this.editor.commands.bindKey(command.bindKey, command.exec);
              } else {
                _this.editor.commands.addCommand(command);
              }
            });
          }
          if (keyboardHandler) {
            this.editor.setKeyboardHandler("ace/keyboard/" + keyboardHandler);
          }
          if (className) {
            this.refEditor.className += " " + className;
          }
          if (onLoad) {
            onLoad(this.editor);
          }
          this.editor.resize();
          if (focus) {
            this.editor.focus();
          }
        };
        ReactAce2.prototype.componentDidUpdate = function(prevProps) {
          var oldProps = prevProps;
          var nextProps = this.props;
          for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
            var option = editorOptions_1.editorOptions[i];
            if (nextProps[option] !== oldProps[option]) {
              this.editor.setOption(option, nextProps[option]);
            }
          }
          if (nextProps.className !== oldProps.className) {
            var appliedClasses = this.refEditor.className;
            var appliedClassesArray_1 = appliedClasses.trim().split(" ");
            var oldClassesArray = oldProps.className.trim().split(" ");
            oldClassesArray.forEach(function(oldClass) {
              var index = appliedClassesArray_1.indexOf(oldClass);
              appliedClassesArray_1.splice(index, 1);
            });
            this.refEditor.className = " " + nextProps.className + " " + appliedClassesArray_1.join(" ");
          }
          var valueChanged = this.editor && nextProps.value != null && this.editor.getValue() !== nextProps.value;
          if (valueChanged) {
            this.silent = true;
            var pos = this.editor.session.selection.toJSON();
            this.editor.setValue(nextProps.value, nextProps.cursorStart);
            this.editor.session.selection.fromJSON(pos);
            this.silent = false;
          }
          if (nextProps.placeholder !== oldProps.placeholder) {
            this.updatePlaceholder();
          }
          if (nextProps.mode !== oldProps.mode) {
            this.editor.getSession().setMode(typeof nextProps.mode === "string" ? "ace/mode/".concat(nextProps.mode) : nextProps.mode);
          }
          if (nextProps.theme !== oldProps.theme) {
            this.editor.setTheme("ace/theme/" + nextProps.theme);
          }
          if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {
            if (nextProps.keyboardHandler) {
              this.editor.setKeyboardHandler("ace/keyboard/" + nextProps.keyboardHandler);
            } else {
              this.editor.setKeyboardHandler(null);
            }
          }
          if (nextProps.fontSize !== oldProps.fontSize) {
            this.editor.setFontSize(typeof nextProps.fontSize === "number" ? "".concat(nextProps.fontSize, "px") : nextProps.fontSize);
          }
          if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {
            this.editor.getSession().setUseWrapMode(nextProps.wrapEnabled);
          }
          if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {
            this.editor.setShowPrintMargin(nextProps.showPrintMargin);
          }
          if (nextProps.showGutter !== oldProps.showGutter) {
            this.editor.renderer.setShowGutter(nextProps.showGutter);
          }
          if (!isEqual(nextProps.setOptions, oldProps.setOptions)) {
            this.handleOptions(nextProps);
          }
          if (valueChanged || !isEqual(nextProps.annotations, oldProps.annotations)) {
            this.editor.getSession().setAnnotations(nextProps.annotations || []);
          }
          if (!isEqual(nextProps.markers, oldProps.markers) && Array.isArray(nextProps.markers)) {
            this.handleMarkers(nextProps.markers);
          }
          if (!isEqual(nextProps.scrollMargin, oldProps.scrollMargin)) {
            this.handleScrollMargins(nextProps.scrollMargin);
          }
          if (prevProps.height !== this.props.height || prevProps.width !== this.props.width) {
            this.editor.resize();
          }
          if (this.props.focus && !prevProps.focus) {
            this.editor.focus();
          }
        };
        ReactAce2.prototype.handleScrollMargins = function(margins) {
          if (margins === void 0) {
            margins = [0, 0, 0, 0];
          }
          this.editor.renderer.setScrollMargin(margins[0], margins[1], margins[2], margins[3]);
        };
        ReactAce2.prototype.componentWillUnmount = function() {
          if (this.editor) {
            this.editor.destroy();
            this.editor = null;
          }
        };
        ReactAce2.prototype.onChange = function(event) {
          if (this.props.onChange && !this.silent) {
            var value = this.editor.getValue();
            this.props.onChange(value, event);
          }
        };
        ReactAce2.prototype.onSelectionChange = function(event) {
          if (this.props.onSelectionChange) {
            var value = this.editor.getSelection();
            this.props.onSelectionChange(value, event);
          }
        };
        ReactAce2.prototype.onCursorChange = function(event) {
          if (this.props.onCursorChange) {
            var value = this.editor.getSelection();
            this.props.onCursorChange(value, event);
          }
        };
        ReactAce2.prototype.onInput = function(event) {
          if (this.props.onInput) {
            this.props.onInput(event);
          }
          if (this.props.placeholder) {
            this.updatePlaceholder();
          }
        };
        ReactAce2.prototype.onFocus = function(event) {
          if (this.props.onFocus) {
            this.props.onFocus(event, this.editor);
          }
        };
        ReactAce2.prototype.onBlur = function(event) {
          if (this.props.onBlur) {
            this.props.onBlur(event, this.editor);
          }
        };
        ReactAce2.prototype.onCopy = function(_a) {
          var text = _a.text;
          if (this.props.onCopy) {
            this.props.onCopy(text);
          }
        };
        ReactAce2.prototype.onPaste = function(_a) {
          var text = _a.text;
          if (this.props.onPaste) {
            this.props.onPaste(text);
          }
        };
        ReactAce2.prototype.onScroll = function() {
          if (this.props.onScroll) {
            this.props.onScroll(this.editor);
          }
        };
        ReactAce2.prototype.handleOptions = function(props) {
          var setOptions = Object.keys(props.setOptions);
          for (var y = 0; y < setOptions.length; y++) {
            this.editor.setOption(setOptions[y], props.setOptions[setOptions[y]]);
          }
        };
        ReactAce2.prototype.handleMarkers = function(markers) {
          var _this = this;
          var currentMarkers = this.editor.getSession().getMarkers(true);
          for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i)) {
              this.editor.getSession().removeMarker(currentMarkers[i].id);
            }
          }
          currentMarkers = this.editor.getSession().getMarkers(false);
          for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i) && currentMarkers[i].clazz !== "ace_active-line" && currentMarkers[i].clazz !== "ace_selected-word") {
              this.editor.getSession().removeMarker(currentMarkers[i].id);
            }
          }
          markers.forEach(function(_a) {
            var startRow = _a.startRow, startCol = _a.startCol, endRow = _a.endRow, endCol = _a.endCol, className = _a.className, type = _a.type, _b = _a.inFront, inFront = _b === void 0 ? false : _b;
            var range = new ace_builds_1.Range(startRow, startCol, endRow, endCol);
            _this.editor.getSession().addMarker(range, className, type, inFront);
          });
        };
        ReactAce2.prototype.updatePlaceholder = function() {
          var editor = this.editor;
          var placeholder = this.props.placeholder;
          var showPlaceholder = !editor.session.getValue().length;
          var node = editor.renderer.placeholderNode;
          if (!showPlaceholder && node) {
            editor.renderer.scroller.removeChild(editor.renderer.placeholderNode);
            editor.renderer.placeholderNode = null;
          } else if (showPlaceholder && !node) {
            node = editor.renderer.placeholderNode = document.createElement("div");
            node.textContent = placeholder || "";
            node.className = "ace_comment ace_placeholder";
            node.style.padding = "0 9px";
            node.style.position = "absolute";
            node.style.zIndex = "3";
            editor.renderer.scroller.appendChild(node);
          } else if (showPlaceholder && node) {
            node.textContent = placeholder;
          }
        };
        ReactAce2.prototype.updateRef = function(item) {
          this.refEditor = item;
        };
        ReactAce2.prototype.render = function() {
          var _a = this.props, name = _a.name, width = _a.width, height = _a.height, style = _a.style;
          var divStyle = __assign({ width, height }, style);
          return React.createElement("div", { ref: this.updateRef, id: name, style: divStyle });
        };
        ReactAce2.propTypes = {
          mode: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
          focus: PropTypes.bool,
          theme: PropTypes.string,
          name: PropTypes.string,
          className: PropTypes.string,
          height: PropTypes.string,
          width: PropTypes.string,
          fontSize: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
          showGutter: PropTypes.bool,
          onChange: PropTypes.func,
          onCopy: PropTypes.func,
          onPaste: PropTypes.func,
          onFocus: PropTypes.func,
          onInput: PropTypes.func,
          onBlur: PropTypes.func,
          onScroll: PropTypes.func,
          value: PropTypes.string,
          defaultValue: PropTypes.string,
          onLoad: PropTypes.func,
          onSelectionChange: PropTypes.func,
          onCursorChange: PropTypes.func,
          onBeforeLoad: PropTypes.func,
          onValidate: PropTypes.func,
          minLines: PropTypes.number,
          maxLines: PropTypes.number,
          readOnly: PropTypes.bool,
          highlightActiveLine: PropTypes.bool,
          tabSize: PropTypes.number,
          showPrintMargin: PropTypes.bool,
          cursorStart: PropTypes.number,
          debounceChangePeriod: PropTypes.number,
          editorProps: PropTypes.object,
          setOptions: PropTypes.object,
          style: PropTypes.object,
          scrollMargin: PropTypes.array,
          annotations: PropTypes.array,
          markers: PropTypes.array,
          keyboardHandler: PropTypes.string,
          wrapEnabled: PropTypes.bool,
          enableSnippets: PropTypes.bool,
          enableBasicAutocompletion: PropTypes.oneOfType([
            PropTypes.bool,
            PropTypes.array
          ]),
          enableLiveAutocompletion: PropTypes.oneOfType([
            PropTypes.bool,
            PropTypes.array
          ]),
          navigateToFileEnd: PropTypes.bool,
          commands: PropTypes.array,
          placeholder: PropTypes.string
        };
        ReactAce2.defaultProps = {
          name: "ace-editor",
          focus: false,
          mode: "",
          theme: "",
          height: "500px",
          width: "500px",
          fontSize: 12,
          enableSnippets: false,
          showGutter: true,
          onChange: null,
          onPaste: null,
          onLoad: null,
          onScroll: null,
          minLines: null,
          maxLines: null,
          readOnly: false,
          highlightActiveLine: true,
          showPrintMargin: true,
          tabSize: 4,
          cursorStart: 1,
          editorProps: {},
          style: {},
          scrollMargin: [0, 0, 0, 0],
          setOptions: {},
          wrapEnabled: false,
          enableBasicAutocompletion: false,
          enableLiveAutocompletion: false,
          placeholder: null,
          navigateToFileEnd: true
        };
        return ReactAce2;
      }(React.Component)
    );
    exports.default = ReactAce;
  }
});

// node_modules/ace-builds/src-noconflict/ext-split.js
var require_ext_split = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-split.js"(exports, module) {
    ace.define("ace/split", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/editor", "ace/virtual_renderer", "ace/edit_session"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Editor = require2("./editor").Editor;
      var Renderer = require2("./virtual_renderer").VirtualRenderer;
      var EditSession = require2("./edit_session").EditSession;
      var Split = function(container, theme, splits) {
        this.BELOW = 1;
        this.BESIDE = 0;
        this.$container = container;
        this.$theme = theme;
        this.$splits = 0;
        this.$editorCSS = "";
        this.$editors = [];
        this.$orientation = this.BESIDE;
        this.setSplits(splits || 1);
        this.$cEditor = this.$editors[0];
        this.on("focus", (function(editor) {
          this.$cEditor = editor;
        }).bind(this));
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$createEditor = function() {
          var el = document.createElement("div");
          el.className = this.$editorCSS;
          el.style.cssText = "position: absolute; top:0px; bottom:0px";
          this.$container.appendChild(el);
          var editor = new Editor(new Renderer(el, this.$theme));
          editor.on("focus", (function() {
            this._emit("focus", editor);
          }).bind(this));
          this.$editors.push(editor);
          editor.setFontSize(this.$fontSize);
          return editor;
        };
        this.setSplits = function(splits) {
          var editor;
          if (splits < 1) {
            throw "The number of splits have to be > 0!";
          }
          if (splits == this.$splits) {
            return;
          } else if (splits > this.$splits) {
            while (this.$splits < this.$editors.length && this.$splits < splits) {
              editor = this.$editors[this.$splits];
              this.$container.appendChild(editor.container);
              editor.setFontSize(this.$fontSize);
              this.$splits++;
            }
            while (this.$splits < splits) {
              this.$createEditor();
              this.$splits++;
            }
          } else {
            while (this.$splits > splits) {
              editor = this.$editors[this.$splits - 1];
              this.$container.removeChild(editor.container);
              this.$splits--;
            }
          }
          this.resize();
        };
        this.getSplits = function() {
          return this.$splits;
        };
        this.getEditor = function(idx) {
          return this.$editors[idx];
        };
        this.getCurrentEditor = function() {
          return this.$cEditor;
        };
        this.focus = function() {
          this.$cEditor.focus();
        };
        this.blur = function() {
          this.$cEditor.blur();
        };
        this.setTheme = function(theme) {
          this.$editors.forEach(function(editor) {
            editor.setTheme(theme);
          });
        };
        this.setKeyboardHandler = function(keybinding) {
          this.$editors.forEach(function(editor) {
            editor.setKeyboardHandler(keybinding);
          });
        };
        this.forEach = function(callback, scope) {
          this.$editors.forEach(callback, scope);
        };
        this.$fontSize = "";
        this.setFontSize = function(size) {
          this.$fontSize = size;
          this.forEach(function(editor) {
            editor.setFontSize(size);
          });
        };
        this.$cloneSession = function(session) {
          var s = new EditSession(session.getDocument(), session.getMode());
          var undoManager = session.getUndoManager();
          s.setUndoManager(undoManager);
          s.setTabSize(session.getTabSize());
          s.setUseSoftTabs(session.getUseSoftTabs());
          s.setOverwrite(session.getOverwrite());
          s.setBreakpoints(session.getBreakpoints());
          s.setUseWrapMode(session.getUseWrapMode());
          s.setUseWorker(session.getUseWorker());
          s.setWrapLimitRange(session.$wrapLimitRange.min, session.$wrapLimitRange.max);
          s.$foldData = session.$cloneFoldData();
          return s;
        };
        this.setSession = function(session, idx) {
          var editor;
          if (idx == null) {
            editor = this.$cEditor;
          } else {
            editor = this.$editors[idx];
          }
          var isUsed = this.$editors.some(function(editor2) {
            return editor2.session === session;
          });
          if (isUsed) {
            session = this.$cloneSession(session);
          }
          editor.setSession(session);
          return session;
        };
        this.getOrientation = function() {
          return this.$orientation;
        };
        this.setOrientation = function(orientation) {
          if (this.$orientation == orientation) {
            return;
          }
          this.$orientation = orientation;
          this.resize();
        };
        this.resize = function() {
          var width = this.$container.clientWidth;
          var height = this.$container.clientHeight;
          var editor;
          if (this.$orientation == this.BESIDE) {
            var editorWidth = width / this.$splits;
            for (var i = 0; i < this.$splits; i++) {
              editor = this.$editors[i];
              editor.container.style.width = editorWidth + "px";
              editor.container.style.top = "0px";
              editor.container.style.left = i * editorWidth + "px";
              editor.container.style.height = height + "px";
              editor.resize();
            }
          } else {
            var editorHeight = height / this.$splits;
            for (var i = 0; i < this.$splits; i++) {
              editor = this.$editors[i];
              editor.container.style.width = width + "px";
              editor.container.style.top = i * editorHeight + "px";
              editor.container.style.left = "0px";
              editor.container.style.height = editorHeight + "px";
              editor.resize();
            }
          }
        };
      }).call(Split.prototype);
      exports2.Split = Split;
    });
    ace.define("ace/ext/split", ["require", "exports", "module", "ace/split"], function(require2, exports2, module2) {
      "use strict";
      module2.exports = require2("../split");
    });
    (function() {
      ace.require(["ace/ext/split"], function(m) {
        if (typeof module == "object" && typeof exports == "object" && module) {
          module.exports = m;
        }
      });
    })();
  }
});

// node_modules/lodash.get/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.get/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get;
  }
});

// node_modules/react-ace/lib/split.js
var require_split = __commonJS({
  "node_modules/react-ace/lib/split.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var editorOptions_1 = require_editorOptions();
    var ace2 = (0, editorOptions_1.getAceInstance)();
    var ace_builds_1 = require_ace();
    var ext_split_1 = require_ext_split();
    var PropTypes = require_prop_types();
    var React = require_react();
    var isEqual = require_lodash();
    var get = require_lodash2();
    var SplitComponent = (
      /** @class */
      function(_super) {
        __extends(SplitComponent2, _super);
        function SplitComponent2(props) {
          var _this = _super.call(this, props) || this;
          editorOptions_1.editorEvents.forEach(function(method) {
            _this[method] = _this[method].bind(_this);
          });
          _this.debounce = editorOptions_1.debounce;
          return _this;
        }
        SplitComponent2.prototype.isInShadow = function(node) {
          var parent = node && node.parentNode;
          while (parent) {
            if (parent.toString() === "[object ShadowRoot]") {
              return true;
            }
            parent = parent.parentNode;
          }
          return false;
        };
        SplitComponent2.prototype.componentDidMount = function() {
          var _this = this;
          var _a = this.props, className = _a.className, onBeforeLoad = _a.onBeforeLoad, mode = _a.mode, focus = _a.focus, theme = _a.theme, fontSize = _a.fontSize, value = _a.value, defaultValue = _a.defaultValue, cursorStart = _a.cursorStart, showGutter = _a.showGutter, wrapEnabled = _a.wrapEnabled, showPrintMargin = _a.showPrintMargin, _b = _a.scrollMargin, scrollMargin = _b === void 0 ? [0, 0, 0, 0] : _b, keyboardHandler = _a.keyboardHandler, onLoad = _a.onLoad, commands = _a.commands, annotations = _a.annotations, markers = _a.markers, splits = _a.splits;
          this.editor = ace2.edit(this.refEditor);
          if (this.isInShadow(this.refEditor)) {
            this.editor.renderer.attachToShadowRoot();
          }
          this.editor.setTheme("ace/theme/".concat(theme));
          if (onBeforeLoad) {
            onBeforeLoad(ace2);
          }
          var editorProps = Object.keys(this.props.editorProps);
          var split = new ext_split_1.Split(this.editor.container, "ace/theme/".concat(theme), splits);
          this.editor.env.split = split;
          this.splitEditor = split.getEditor(0);
          this.split = split;
          this.editor.setShowPrintMargin(false);
          this.editor.renderer.setShowGutter(false);
          var availableOptions = this.splitEditor.$options;
          if (this.props.debounceChangePeriod) {
            this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod);
          }
          split.forEach(function(editor, index) {
            for (var i = 0; i < editorProps.length; i++) {
              editor[editorProps[i]] = _this.props.editorProps[editorProps[i]];
            }
            var defaultValueForEditor = get(defaultValue, index);
            var valueForEditor = get(value, index, "");
            editor.session.setUndoManager(new ace2.UndoManager());
            editor.setTheme("ace/theme/".concat(theme));
            editor.renderer.setScrollMargin(scrollMargin[0], scrollMargin[1], scrollMargin[2], scrollMargin[3]);
            editor.getSession().setMode("ace/mode/".concat(mode));
            editor.setFontSize(fontSize);
            editor.renderer.setShowGutter(showGutter);
            editor.getSession().setUseWrapMode(wrapEnabled);
            editor.setShowPrintMargin(showPrintMargin);
            editor.on("focus", _this.onFocus);
            editor.on("blur", _this.onBlur);
            editor.on("input", _this.onInput);
            editor.on("copy", _this.onCopy);
            editor.on("paste", _this.onPaste);
            editor.on("change", _this.onChange);
            editor.getSession().selection.on("changeSelection", _this.onSelectionChange);
            editor.getSession().selection.on("changeCursor", _this.onCursorChange);
            editor.session.on("changeScrollTop", _this.onScroll);
            editor.setValue(defaultValueForEditor === void 0 ? valueForEditor : defaultValueForEditor, cursorStart);
            var newAnnotations = get(annotations, index, []);
            var newMarkers = get(markers, index, []);
            editor.getSession().setAnnotations(newAnnotations);
            if (newMarkers && newMarkers.length > 0) {
              _this.handleMarkers(newMarkers, editor);
            }
            for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
              var option = editorOptions_1.editorOptions[i];
              if (availableOptions.hasOwnProperty(option)) {
                editor.setOption(option, _this.props[option]);
              } else if (_this.props[option]) {
                console.warn("ReaceAce: editor option ".concat(option, " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?"));
              }
            }
            _this.handleOptions(_this.props, editor);
            if (Array.isArray(commands)) {
              commands.forEach(function(command) {
                if (typeof command.exec === "string") {
                  editor.commands.bindKey(command.bindKey, command.exec);
                } else {
                  editor.commands.addCommand(command);
                }
              });
            }
            if (keyboardHandler) {
              editor.setKeyboardHandler("ace/keyboard/" + keyboardHandler);
            }
          });
          if (className) {
            this.refEditor.className += " " + className;
          }
          if (focus) {
            this.splitEditor.focus();
          }
          var sp = this.editor.env.split;
          sp.setOrientation(this.props.orientation === "below" ? sp.BELOW : sp.BESIDE);
          sp.resize(true);
          if (onLoad) {
            onLoad(sp);
          }
        };
        SplitComponent2.prototype.componentDidUpdate = function(prevProps) {
          var _this = this;
          var oldProps = prevProps;
          var nextProps = this.props;
          var split = this.editor.env.split;
          if (nextProps.splits !== oldProps.splits) {
            split.setSplits(nextProps.splits);
          }
          if (nextProps.orientation !== oldProps.orientation) {
            split.setOrientation(nextProps.orientation === "below" ? split.BELOW : split.BESIDE);
          }
          split.forEach(function(editor, index) {
            if (nextProps.mode !== oldProps.mode) {
              editor.getSession().setMode("ace/mode/" + nextProps.mode);
            }
            if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {
              if (nextProps.keyboardHandler) {
                editor.setKeyboardHandler("ace/keyboard/" + nextProps.keyboardHandler);
              } else {
                editor.setKeyboardHandler(null);
              }
            }
            if (nextProps.fontSize !== oldProps.fontSize) {
              editor.setFontSize(nextProps.fontSize);
            }
            if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {
              editor.getSession().setUseWrapMode(nextProps.wrapEnabled);
            }
            if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {
              editor.setShowPrintMargin(nextProps.showPrintMargin);
            }
            if (nextProps.showGutter !== oldProps.showGutter) {
              editor.renderer.setShowGutter(nextProps.showGutter);
            }
            for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
              var option = editorOptions_1.editorOptions[i];
              if (nextProps[option] !== oldProps[option]) {
                editor.setOption(option, nextProps[option]);
              }
            }
            if (!isEqual(nextProps.setOptions, oldProps.setOptions)) {
              _this.handleOptions(nextProps, editor);
            }
            var nextValue = get(nextProps.value, index, "");
            if (editor.getValue() !== nextValue) {
              _this.silent = true;
              var pos = editor.session.selection.toJSON();
              editor.setValue(nextValue, nextProps.cursorStart);
              editor.session.selection.fromJSON(pos);
              _this.silent = false;
            }
            var newAnnotations = get(nextProps.annotations, index, []);
            var oldAnnotations = get(oldProps.annotations, index, []);
            if (!isEqual(newAnnotations, oldAnnotations)) {
              editor.getSession().setAnnotations(newAnnotations);
            }
            var newMarkers = get(nextProps.markers, index, []);
            var oldMarkers = get(oldProps.markers, index, []);
            if (!isEqual(newMarkers, oldMarkers) && Array.isArray(newMarkers)) {
              _this.handleMarkers(newMarkers, editor);
            }
          });
          if (nextProps.className !== oldProps.className) {
            var appliedClasses = this.refEditor.className;
            var appliedClassesArray_1 = appliedClasses.trim().split(" ");
            var oldClassesArray = oldProps.className.trim().split(" ");
            oldClassesArray.forEach(function(oldClass) {
              var index = appliedClassesArray_1.indexOf(oldClass);
              appliedClassesArray_1.splice(index, 1);
            });
            this.refEditor.className = " " + nextProps.className + " " + appliedClassesArray_1.join(" ");
          }
          if (nextProps.theme !== oldProps.theme) {
            split.setTheme("ace/theme/" + nextProps.theme);
          }
          if (nextProps.focus && !oldProps.focus) {
            this.splitEditor.focus();
          }
          if (nextProps.height !== this.props.height || nextProps.width !== this.props.width) {
            this.editor.resize();
          }
        };
        SplitComponent2.prototype.componentWillUnmount = function() {
          this.editor.destroy();
          this.editor = null;
        };
        SplitComponent2.prototype.onChange = function(event) {
          if (this.props.onChange && !this.silent) {
            var value_1 = [];
            this.editor.env.split.forEach(function(editor) {
              value_1.push(editor.getValue());
            });
            this.props.onChange(value_1, event);
          }
        };
        SplitComponent2.prototype.onSelectionChange = function(event) {
          if (this.props.onSelectionChange) {
            var value_2 = [];
            this.editor.env.split.forEach(function(editor) {
              value_2.push(editor.getSelection());
            });
            this.props.onSelectionChange(value_2, event);
          }
        };
        SplitComponent2.prototype.onCursorChange = function(event) {
          if (this.props.onCursorChange) {
            var value_3 = [];
            this.editor.env.split.forEach(function(editor) {
              value_3.push(editor.getSelection());
            });
            this.props.onCursorChange(value_3, event);
          }
        };
        SplitComponent2.prototype.onFocus = function(event) {
          if (this.props.onFocus) {
            this.props.onFocus(event);
          }
        };
        SplitComponent2.prototype.onInput = function(event) {
          if (this.props.onInput) {
            this.props.onInput(event);
          }
        };
        SplitComponent2.prototype.onBlur = function(event) {
          if (this.props.onBlur) {
            this.props.onBlur(event);
          }
        };
        SplitComponent2.prototype.onCopy = function(text) {
          if (this.props.onCopy) {
            this.props.onCopy(text);
          }
        };
        SplitComponent2.prototype.onPaste = function(text) {
          if (this.props.onPaste) {
            this.props.onPaste(text);
          }
        };
        SplitComponent2.prototype.onScroll = function() {
          if (this.props.onScroll) {
            this.props.onScroll(this.editor);
          }
        };
        SplitComponent2.prototype.handleOptions = function(props, editor) {
          var setOptions = Object.keys(props.setOptions);
          for (var y = 0; y < setOptions.length; y++) {
            editor.setOption(setOptions[y], props.setOptions[setOptions[y]]);
          }
        };
        SplitComponent2.prototype.handleMarkers = function(markers, editor) {
          var currentMarkers = editor.getSession().getMarkers(true);
          for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i)) {
              editor.getSession().removeMarker(currentMarkers[i].id);
            }
          }
          currentMarkers = editor.getSession().getMarkers(false);
          for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i)) {
              editor.getSession().removeMarker(currentMarkers[i].id);
            }
          }
          markers.forEach(function(_a) {
            var startRow = _a.startRow, startCol = _a.startCol, endRow = _a.endRow, endCol = _a.endCol, className = _a.className, type = _a.type, _b = _a.inFront, inFront = _b === void 0 ? false : _b;
            var range = new ace_builds_1.Range(startRow, startCol, endRow, endCol);
            editor.getSession().addMarker(range, className, type, inFront);
          });
        };
        SplitComponent2.prototype.updateRef = function(item) {
          this.refEditor = item;
        };
        SplitComponent2.prototype.render = function() {
          var _a = this.props, name = _a.name, width = _a.width, height = _a.height, style = _a.style;
          var divStyle = __assign({ width, height }, style);
          return React.createElement("div", { ref: this.updateRef, id: name, style: divStyle });
        };
        SplitComponent2.propTypes = {
          className: PropTypes.string,
          debounceChangePeriod: PropTypes.number,
          defaultValue: PropTypes.arrayOf(PropTypes.string),
          focus: PropTypes.bool,
          fontSize: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
          height: PropTypes.string,
          mode: PropTypes.string,
          name: PropTypes.string,
          onBlur: PropTypes.func,
          onChange: PropTypes.func,
          onCopy: PropTypes.func,
          onFocus: PropTypes.func,
          onInput: PropTypes.func,
          onLoad: PropTypes.func,
          onPaste: PropTypes.func,
          onScroll: PropTypes.func,
          orientation: PropTypes.string,
          showGutter: PropTypes.bool,
          splits: PropTypes.number,
          theme: PropTypes.string,
          value: PropTypes.arrayOf(PropTypes.string),
          width: PropTypes.string,
          onSelectionChange: PropTypes.func,
          onCursorChange: PropTypes.func,
          onBeforeLoad: PropTypes.func,
          minLines: PropTypes.number,
          maxLines: PropTypes.number,
          readOnly: PropTypes.bool,
          highlightActiveLine: PropTypes.bool,
          tabSize: PropTypes.number,
          showPrintMargin: PropTypes.bool,
          cursorStart: PropTypes.number,
          editorProps: PropTypes.object,
          setOptions: PropTypes.object,
          style: PropTypes.object,
          scrollMargin: PropTypes.array,
          annotations: PropTypes.array,
          markers: PropTypes.array,
          keyboardHandler: PropTypes.string,
          wrapEnabled: PropTypes.bool,
          enableBasicAutocompletion: PropTypes.oneOfType([
            PropTypes.bool,
            PropTypes.array
          ]),
          enableLiveAutocompletion: PropTypes.oneOfType([
            PropTypes.bool,
            PropTypes.array
          ]),
          commands: PropTypes.array
        };
        SplitComponent2.defaultProps = {
          name: "ace-editor",
          focus: false,
          orientation: "beside",
          splits: 2,
          mode: "",
          theme: "",
          height: "500px",
          width: "500px",
          value: [],
          fontSize: 12,
          showGutter: true,
          onChange: null,
          onPaste: null,
          onLoad: null,
          onScroll: null,
          minLines: null,
          maxLines: null,
          readOnly: false,
          highlightActiveLine: true,
          showPrintMargin: true,
          tabSize: 4,
          cursorStart: 1,
          editorProps: {},
          style: {},
          scrollMargin: [0, 0, 0, 0],
          setOptions: {},
          wrapEnabled: false,
          enableBasicAutocompletion: false,
          enableLiveAutocompletion: false
        };
        return SplitComponent2;
      }(React.Component)
    );
    exports.default = SplitComponent;
  }
});

// node_modules/diff-match-patch/index.js
var require_diff_match_patch = __commonJS({
  "node_modules/diff-match-patch/index.js"(exports, module) {
    var diff_match_patch = function() {
      this.Diff_Timeout = 1;
      this.Diff_EditCost = 4;
      this.Match_Threshold = 0.5;
      this.Match_Distance = 1e3;
      this.Patch_DeleteThreshold = 0.5;
      this.Patch_Margin = 4;
      this.Match_MaxBits = 32;
    };
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    diff_match_patch.Diff = function(op, text) {
      return [op, text];
    };
    diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
      if (typeof opt_deadline == "undefined") {
        if (this.Diff_Timeout <= 0) {
          opt_deadline = Number.MAX_VALUE;
        } else {
          opt_deadline = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3;
        }
      }
      var deadline = opt_deadline;
      if (text1 == null || text2 == null) {
        throw new Error("Null input. (diff_main)");
      }
      if (text1 == text2) {
        if (text1) {
          return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
        }
        return [];
      }
      if (typeof opt_checklines == "undefined") {
        opt_checklines = true;
      }
      var checklines = opt_checklines;
      var commonlength = this.diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = this.diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = this.diff_compute_(text1, text2, checklines, deadline);
      if (commonprefix) {
        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
      }
      if (commonsuffix) {
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
      }
      this.diff_cleanupMerge(diffs);
      return diffs;
    };
    diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
      var diffs;
      if (!text1) {
        return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
      }
      if (!text2) {
        return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i != -1) {
        diffs = [
          new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
          new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
          new diff_match_patch.Diff(
            DIFF_INSERT,
            longtext.substring(i + shorttext.length)
          )
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [
          new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)
        ];
      }
      var hm = this.diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        return diffs_a.concat(
          [new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
          diffs_b
        );
      }
      if (checklines && text1.length > 100 && text2.length > 100) {
        return this.diff_lineMode_(text1, text2, deadline);
      }
      return this.diff_bisect_(text1, text2, deadline);
    };
    diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
      var a = this.diff_linesToChars_(text1, text2);
      text1 = a.chars1;
      text2 = a.chars2;
      var linearray = a.lineArray;
      var diffs = this.diff_main(text1, text2, false, deadline);
      this.diff_charsToLines_(diffs, linearray);
      this.diff_cleanupSemantic(diffs);
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            break;
          case DIFF_EQUAL:
            if (count_delete >= 1 && count_insert >= 1) {
              diffs.splice(
                pointer - count_delete - count_insert,
                count_delete + count_insert
              );
              pointer = pointer - count_delete - count_insert;
              var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
              for (var j = subDiff.length - 1; j >= 0; j--) {
                diffs.splice(pointer, 0, subDiff[j]);
              }
              pointer = pointer + subDiff.length;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
        pointer++;
      }
      diffs.pop();
      return diffs;
    };
    diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        if ((/* @__PURE__ */ new Date()).getTime() > deadline) {
          break;
        }
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
      }
      return [
        new diff_match_patch.Diff(DIFF_DELETE, text1),
        new diff_match_patch.Diff(DIFF_INSERT, text2)
      ];
    };
    diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = this.diff_main(text1a, text2a, false, deadline);
      var diffsb = this.diff_main(text1b, text2b, false, deadline);
      return diffs.concat(diffsb);
    };
    diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
      var lineArray = [];
      var lineHash = {};
      lineArray[0] = "";
      function diff_linesToCharsMunge_(text) {
        var chars = "";
        var lineStart = 0;
        var lineEnd = -1;
        var lineArrayLength = lineArray.length;
        while (lineEnd < text.length - 1) {
          lineEnd = text.indexOf("\n", lineStart);
          if (lineEnd == -1) {
            lineEnd = text.length - 1;
          }
          var line = text.substring(lineStart, lineEnd + 1);
          if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
            chars += String.fromCharCode(lineHash[line]);
          } else {
            if (lineArrayLength == maxLines) {
              line = text.substring(lineStart);
              lineEnd = text.length;
            }
            chars += String.fromCharCode(lineArrayLength);
            lineHash[line] = lineArrayLength;
            lineArray[lineArrayLength++] = line;
          }
          lineStart = lineEnd + 1;
        }
        return chars;
      }
      var maxLines = 4e4;
      var chars1 = diff_linesToCharsMunge_(text1);
      maxLines = 65535;
      var chars2 = diff_linesToCharsMunge_(text2);
      return { chars1, chars2, lineArray };
    };
    diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
      for (var i = 0; i < diffs.length; i++) {
        var chars = diffs[i][1];
        var text = [];
        for (var j = 0; j < chars.length; j++) {
          text[j] = lineArray[chars.charCodeAt(j)];
        }
        diffs[i][1] = text.join("");
      }
    };
    diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    };
    diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
      if (this.Diff_Timeout <= 0) {
        return null;
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      var dmp = this;
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = dmp.diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = dmp.diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    };
    diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(
            length_insertions2,
            length_deletions2
          )) {
            diffs.splice(
              equalities[equalitiesLength - 1],
              0,
              new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
            );
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
      this.diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(
                DIFF_EQUAL,
                insertion.substring(0, overlap_length1)
              ));
              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(
                DIFF_EQUAL,
                deletion.substring(0, overlap_length2)
              ));
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    };
    diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = this.diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    };
    diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    diff_match_patch.whitespaceRegex_ = /\s/;
    diff_match_patch.linebreakRegex_ = /[\r\n]/;
    diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
    diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
    diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var pre_ins = false;
      var pre_del = false;
      var post_ins = false;
      var post_del = false;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
            equalities[equalitiesLength++] = pointer;
            pre_ins = post_ins;
            pre_del = post_del;
            lastEquality = diffs[pointer][1];
          } else {
            equalitiesLength = 0;
            lastEquality = null;
          }
          post_ins = post_del = false;
        } else {
          if (diffs[pointer][0] == DIFF_DELETE) {
            post_del = true;
          } else {
            post_ins = true;
          }
          if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
            diffs.splice(
              equalities[equalitiesLength - 1],
              0,
              new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
            );
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            lastEquality = null;
            if (pre_ins && pre_del) {
              post_ins = post_del = true;
              equalitiesLength = 0;
            } else {
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              post_ins = post_del = false;
            }
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = this.diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, new diff_match_patch.Diff(
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ));
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = this.diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              pointer -= count_delete + count_insert;
              diffs.splice(pointer, count_delete + count_insert);
              if (text_delete.length) {
                diffs.splice(
                  pointer,
                  0,
                  new diff_match_patch.Diff(DIFF_DELETE, text_delete)
                );
                pointer++;
              }
              if (text_insert.length) {
                diffs.splice(
                  pointer,
                  0,
                  new diff_match_patch.Diff(DIFF_INSERT, text_insert)
                );
                pointer++;
              }
              pointer++;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
      var chars1 = 0;
      var chars2 = 0;
      var last_chars1 = 0;
      var last_chars2 = 0;
      var x;
      for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE) {
          chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {
          break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
      }
      if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
        return last_chars2;
      }
      return last_chars2 + (loc - last_chars1);
    };
    diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
      var html = [];
      var pattern_amp = /&/g;
      var pattern_lt = /</g;
      var pattern_gt = />/g;
      var pattern_para = /\n/g;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
        switch (op) {
          case DIFF_INSERT:
            html[x] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
            break;
          case DIFF_DELETE:
            html[x] = '<del style="background:#ffe6e6;">' + text + "</del>";
            break;
          case DIFF_EQUAL:
            html[x] = "<span>" + text + "</span>";
            break;
        }
      }
      return html.join("");
    };
    diff_match_patch.prototype.diff_text1 = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          text[x] = diffs[x][1];
        }
      }
      return text.join("");
    };
    diff_match_patch.prototype.diff_text2 = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE) {
          text[x] = diffs[x][1];
        }
      }
      return text.join("");
    };
    diff_match_patch.prototype.diff_levenshtein = function(diffs) {
      var levenshtein = 0;
      var insertions = 0;
      var deletions = 0;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
          case DIFF_INSERT:
            insertions += data.length;
            break;
          case DIFF_DELETE:
            deletions += data.length;
            break;
          case DIFF_EQUAL:
            levenshtein += Math.max(insertions, deletions);
            insertions = 0;
            deletions = 0;
            break;
        }
      }
      levenshtein += Math.max(insertions, deletions);
      return levenshtein;
    };
    diff_match_patch.prototype.diff_toDelta = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
          case DIFF_INSERT:
            text[x] = "+" + encodeURI(diffs[x][1]);
            break;
          case DIFF_DELETE:
            text[x] = "-" + diffs[x][1].length;
            break;
          case DIFF_EQUAL:
            text[x] = "=" + diffs[x][1].length;
            break;
        }
      }
      return text.join("	").replace(/%20/g, " ");
    };
    diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
      var diffs = [];
      var diffsLength = 0;
      var pointer = 0;
      var tokens = delta.split(/\t/g);
      for (var x = 0; x < tokens.length; x++) {
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
          case "+":
            try {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
            } catch (ex) {
              throw new Error("Illegal escape in diff_fromDelta: " + param);
            }
            break;
          case "-":
          case "=":
            var n = parseInt(param, 10);
            if (isNaN(n) || n < 0) {
              throw new Error("Invalid number in diff_fromDelta: " + param);
            }
            var text = text1.substring(pointer, pointer += n);
            if (tokens[x].charAt(0) == "=") {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
            } else {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
            }
            break;
          default:
            if (tokens[x]) {
              throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
            }
        }
      }
      if (pointer != text1.length) {
        throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
      }
      return diffs;
    };
    diff_match_patch.prototype.match_main = function(text, pattern, loc) {
      if (text == null || pattern == null || loc == null) {
        throw new Error("Null input. (match_main)");
      }
      loc = Math.max(0, Math.min(loc, text.length));
      if (text == pattern) {
        return 0;
      } else if (!text.length) {
        return -1;
      } else if (text.substring(loc, loc + pattern.length) == pattern) {
        return loc;
      } else {
        return this.match_bitap_(text, pattern, loc);
      }
    };
    diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
      if (pattern.length > this.Match_MaxBits) {
        throw new Error("Pattern too long for this browser.");
      }
      var s = this.match_alphabet_(pattern);
      var dmp = this;
      function match_bitapScore_(e, x) {
        var accuracy = e / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
          return proximity ? 1 : accuracy;
        }
        return accuracy + proximity / dmp.Match_Distance;
      }
      var score_threshold = this.Match_Threshold;
      var best_loc = text.indexOf(pattern, loc);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        best_loc = text.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
          score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
      }
      var matchmask = 1 << pattern.length - 1;
      best_loc = -1;
      var bin_min, bin_mid;
      var bin_max = pattern.length + text.length;
      var last_rd;
      for (var d = 0; d < pattern.length; d++) {
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
          if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
            bin_min = bin_mid;
          } else {
            bin_max = bin_mid;
          }
          bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
          var charMatch = s[text.charAt(j - 1)];
          if (d === 0) {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
          } else {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
          }
          if (rd[j] & matchmask) {
            var score = match_bitapScore_(d, j - 1);
            if (score <= score_threshold) {
              score_threshold = score;
              best_loc = j - 1;
              if (best_loc > loc) {
                start = Math.max(1, 2 * loc - best_loc);
              } else {
                break;
              }
            }
          }
        }
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
          break;
        }
        last_rd = rd;
      }
      return best_loc;
    };
    diff_match_patch.prototype.match_alphabet_ = function(pattern) {
      var s = {};
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] = 0;
      }
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
      }
      return s;
    };
    diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
      if (text.length == 0) {
        return;
      }
      if (patch.start2 === null) {
        throw Error("patch not initialized");
      }
      var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
      var padding = 0;
      while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text.substring(
          patch.start2 - padding,
          patch.start2 + patch.length1 + padding
        );
      }
      padding += this.Patch_Margin;
      var prefix = text.substring(patch.start2 - padding, patch.start2);
      if (prefix) {
        patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
      }
      var suffix = text.substring(
        patch.start2 + patch.length1,
        patch.start2 + patch.length1 + padding
      );
      if (suffix) {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
      }
      patch.start1 -= prefix.length;
      patch.start2 -= prefix.length;
      patch.length1 += prefix.length + suffix.length;
      patch.length2 += prefix.length + suffix.length;
    };
    diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
      var text1, diffs;
      if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
        text1 = /** @type {string} */
        a;
        diffs = this.diff_main(
          text1,
          /** @type {string} */
          opt_b,
          true
        );
        if (diffs.length > 2) {
          this.diff_cleanupSemantic(diffs);
          this.diff_cleanupEfficiency(diffs);
        }
      } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
        a;
        text1 = this.diff_text1(diffs);
      } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
        text1 = /** @type {string} */
        a;
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
        opt_b;
      } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
        text1 = /** @type {string} */
        a;
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
        opt_c;
      } else {
        throw new Error("Unknown call format to patch_make.");
      }
      if (diffs.length === 0) {
        return [];
      }
      var patches = [];
      var patch = new diff_match_patch.patch_obj();
      var patchDiffLength = 0;
      var char_count1 = 0;
      var char_count2 = 0;
      var prepatch_text = text1;
      var postpatch_text = text1;
      for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];
        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
          patch.start1 = char_count1;
          patch.start2 = char_count2;
        }
        switch (diff_type) {
          case DIFF_INSERT:
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length2 += diff_text.length;
            postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
            break;
          case DIFF_DELETE:
            patch.length1 += diff_text.length;
            patch.diffs[patchDiffLength++] = diffs[x];
            postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
            break;
          case DIFF_EQUAL:
            if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
              patch.diffs[patchDiffLength++] = diffs[x];
              patch.length1 += diff_text.length;
              patch.length2 += diff_text.length;
            } else if (diff_text.length >= 2 * this.Patch_Margin) {
              if (patchDiffLength) {
                this.patch_addContext_(patch, prepatch_text);
                patches.push(patch);
                patch = new diff_match_patch.patch_obj();
                patchDiffLength = 0;
                prepatch_text = postpatch_text;
                char_count1 = char_count2;
              }
            }
            break;
        }
        if (diff_type !== DIFF_INSERT) {
          char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE) {
          char_count2 += diff_text.length;
        }
      }
      if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
      }
      return patches;
    };
    diff_match_patch.prototype.patch_deepCopy = function(patches) {
      var patchesCopy = [];
      for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
          patchCopy.diffs[y] = new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
      }
      return patchesCopy;
    };
    diff_match_patch.prototype.patch_apply = function(patches, text) {
      if (patches.length == 0) {
        return [text, []];
      }
      patches = this.patch_deepCopy(patches);
      var nullPadding = this.patch_addPadding(patches);
      text = nullPadding + text + nullPadding;
      this.patch_splitMax(patches);
      var delta = 0;
      var results = [];
      for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
          start_loc = this.match_main(
            text,
            text1.substring(0, this.Match_MaxBits),
            expected_loc
          );
          if (start_loc != -1) {
            end_loc = this.match_main(
              text,
              text1.substring(text1.length - this.Match_MaxBits),
              expected_loc + text1.length - this.Match_MaxBits
            );
            if (end_loc == -1 || start_loc >= end_loc) {
              start_loc = -1;
            }
          }
        } else {
          start_loc = this.match_main(text, text1, expected_loc);
        }
        if (start_loc == -1) {
          results[x] = false;
          delta -= patches[x].length2 - patches[x].length1;
        } else {
          results[x] = true;
          delta = start_loc - expected_loc;
          var text2;
          if (end_loc == -1) {
            text2 = text.substring(start_loc, start_loc + text1.length);
          } else {
            text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
          }
          if (text1 == text2) {
            text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);
          } else {
            var diffs = this.diff_main(text1, text2, false);
            if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
              results[x] = false;
            } else {
              this.diff_cleanupSemanticLossless(diffs);
              var index1 = 0;
              var index2;
              for (var y = 0; y < patches[x].diffs.length; y++) {
                var mod = patches[x].diffs[y];
                if (mod[0] !== DIFF_EQUAL) {
                  index2 = this.diff_xIndex(diffs, index1);
                }
                if (mod[0] === DIFF_INSERT) {
                  text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
                } else if (mod[0] === DIFF_DELETE) {
                  text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(
                    diffs,
                    index1 + mod[1].length
                  ));
                }
                if (mod[0] !== DIFF_DELETE) {
                  index1 += mod[1].length;
                }
              }
            }
          }
        }
      }
      text = text.substring(nullPadding.length, text.length - nullPadding.length);
      return [text, results];
    };
    diff_match_patch.prototype.patch_addPadding = function(patches) {
      var paddingLength = this.Patch_Margin;
      var nullPadding = "";
      for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
      }
      for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
      }
      var patch = patches[0];
      var diffs = patch.diffs;
      if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
        patch.start1 -= paddingLength;
        patch.start2 -= paddingLength;
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[0][1].length) {
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      patch = patches[patches.length - 1];
      diffs = patch.diffs;
      if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      return nullPadding;
    };
    diff_match_patch.prototype.patch_splitMax = function(patches) {
      var patch_size = this.Match_MaxBits;
      for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
          continue;
        }
        var bigpatch = patches[x];
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = "";
        while (bigpatch.diffs.length !== 0) {
          var patch = new diff_match_patch.patch_obj();
          var empty = true;
          patch.start1 = start1 - precontext.length;
          patch.start2 = start2 - precontext.length;
          if (precontext !== "") {
            patch.length1 = patch.length2 = precontext.length;
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
          }
          while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
            var diff_type = bigpatch.diffs[0][0];
            var diff_text = bigpatch.diffs[0][1];
            if (diff_type === DIFF_INSERT) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
              patch.diffs.push(bigpatch.diffs.shift());
              empty = false;
            } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              empty = false;
              patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
              bigpatch.diffs.shift();
            } else {
              diff_text = diff_text.substring(
                0,
                patch_size - patch.length1 - this.Patch_Margin
              );
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              if (diff_type === DIFF_EQUAL) {
                patch.length2 += diff_text.length;
                start2 += diff_text.length;
              } else {
                empty = false;
              }
              patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
              if (diff_text == bigpatch.diffs[0][1]) {
                bigpatch.diffs.shift();
              } else {
                bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
              }
            }
          }
          precontext = this.diff_text2(patch.diffs);
          precontext = precontext.substring(precontext.length - this.Patch_Margin);
          var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
          if (postcontext !== "") {
            patch.length1 += postcontext.length;
            patch.length2 += postcontext.length;
            if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
              patch.diffs[patch.diffs.length - 1][1] += postcontext;
            } else {
              patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
            }
          }
          if (!empty) {
            patches.splice(++x, 0, patch);
          }
        }
      }
    };
    diff_match_patch.prototype.patch_toText = function(patches) {
      var text = [];
      for (var x = 0; x < patches.length; x++) {
        text[x] = patches[x];
      }
      return text.join("");
    };
    diff_match_patch.prototype.patch_fromText = function(textline) {
      var patches = [];
      if (!textline) {
        return patches;
      }
      var text = textline.split("\n");
      var textPointer = 0;
      var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
      while (textPointer < text.length) {
        var m = text[textPointer].match(patchHeader);
        if (!m) {
          throw new Error("Invalid patch string: " + text[textPointer]);
        }
        var patch = new diff_match_patch.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === "") {
          patch.start1--;
          patch.length1 = 1;
        } else if (m[2] == "0") {
          patch.length1 = 0;
        } else {
          patch.start1--;
          patch.length1 = parseInt(m[2], 10);
        }
        patch.start2 = parseInt(m[3], 10);
        if (m[4] === "") {
          patch.start2--;
          patch.length2 = 1;
        } else if (m[4] == "0") {
          patch.length2 = 0;
        } else {
          patch.start2--;
          patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;
        while (textPointer < text.length) {
          var sign = text[textPointer].charAt(0);
          try {
            var line = decodeURI(text[textPointer].substring(1));
          } catch (ex) {
            throw new Error("Illegal escape in patch_fromText: " + line);
          }
          if (sign == "-") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
          } else if (sign == "+") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
          } else if (sign == " ") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
          } else if (sign == "@") {
            break;
          } else if (sign === "") {
          } else {
            throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
          }
          textPointer++;
        }
      }
      return patches;
    };
    diff_match_patch.patch_obj = function() {
      this.diffs = [];
      this.start1 = null;
      this.start2 = null;
      this.length1 = 0;
      this.length2 = 0;
    };
    diff_match_patch.patch_obj.prototype.toString = function() {
      var coords1, coords2;
      if (this.length1 === 0) {
        coords1 = this.start1 + ",0";
      } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
      } else {
        coords1 = this.start1 + 1 + "," + this.length1;
      }
      if (this.length2 === 0) {
        coords2 = this.start2 + ",0";
      } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
      } else {
        coords2 = this.start2 + 1 + "," + this.length2;
      }
      var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
      var op;
      for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
          case DIFF_INSERT:
            op = "+";
            break;
          case DIFF_DELETE:
            op = "-";
            break;
          case DIFF_EQUAL:
            op = " ";
            break;
        }
        text[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
      }
      return text.join("").replace(/%20/g, " ");
    };
    module.exports = diff_match_patch;
    module.exports["diff_match_patch"] = diff_match_patch;
    module.exports["DIFF_DELETE"] = DIFF_DELETE;
    module.exports["DIFF_INSERT"] = DIFF_INSERT;
    module.exports["DIFF_EQUAL"] = DIFF_EQUAL;
  }
});

// node_modules/react-ace/lib/diff.js
var require_diff = __commonJS({
  "node_modules/react-ace/lib/diff.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var PropTypes = require_prop_types();
    var React = require_react();
    var split_1 = require_split();
    var DiffMatchPatch = require_diff_match_patch();
    var DiffComponent = (
      /** @class */
      function(_super) {
        __extends(DiffComponent2, _super);
        function DiffComponent2(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
            value: _this.props.value
          };
          _this.onChange = _this.onChange.bind(_this);
          _this.diff = _this.diff.bind(_this);
          return _this;
        }
        DiffComponent2.prototype.componentDidUpdate = function() {
          var value = this.props.value;
          if (value !== this.state.value) {
            this.setState({ value });
          }
        };
        DiffComponent2.prototype.onChange = function(value) {
          this.setState({
            value
          });
          if (this.props.onChange) {
            this.props.onChange(value);
          }
        };
        DiffComponent2.prototype.diff = function() {
          var dmp = new DiffMatchPatch();
          var lhString = this.state.value[0];
          var rhString = this.state.value[1];
          if (lhString.length === 0 && rhString.length === 0) {
            return [];
          }
          var diff = dmp.diff_main(lhString, rhString);
          dmp.diff_cleanupSemantic(diff);
          var diffedLines = this.generateDiffedLines(diff);
          var codeEditorSettings = this.setCodeMarkers(diffedLines);
          return codeEditorSettings;
        };
        DiffComponent2.prototype.generateDiffedLines = function(diff) {
          var C = {
            DIFF_EQUAL: 0,
            DIFF_DELETE: -1,
            DIFF_INSERT: 1
          };
          var diffedLines = {
            left: [],
            right: []
          };
          var cursor = {
            left: 1,
            right: 1
          };
          diff.forEach(function(chunk) {
            var chunkType = chunk[0];
            var text = chunk[1];
            var lines = text.split("\n").length - 1;
            if (text.length === 0) {
              return;
            }
            var firstChar = text[0];
            var lastChar = text[text.length - 1];
            var linesToHighlight = 0;
            switch (chunkType) {
              case C.DIFF_EQUAL:
                cursor.left += lines;
                cursor.right += lines;
                break;
              case C.DIFF_DELETE:
                if (firstChar === "\n") {
                  cursor.left++;
                  lines--;
                }
                linesToHighlight = lines;
                if (linesToHighlight === 0) {
                  diffedLines.right.push({
                    startLine: cursor.right,
                    endLine: cursor.right
                  });
                }
                if (lastChar === "\n") {
                  linesToHighlight -= 1;
                }
                diffedLines.left.push({
                  startLine: cursor.left,
                  endLine: cursor.left + linesToHighlight
                });
                cursor.left += lines;
                break;
              case C.DIFF_INSERT:
                if (firstChar === "\n") {
                  cursor.right++;
                  lines--;
                }
                linesToHighlight = lines;
                if (linesToHighlight === 0) {
                  diffedLines.left.push({
                    startLine: cursor.left,
                    endLine: cursor.left
                  });
                }
                if (lastChar === "\n") {
                  linesToHighlight -= 1;
                }
                diffedLines.right.push({
                  startLine: cursor.right,
                  endLine: cursor.right + linesToHighlight
                });
                cursor.right += lines;
                break;
              default:
                throw new Error("Diff type was not defined.");
            }
          });
          return diffedLines;
        };
        DiffComponent2.prototype.setCodeMarkers = function(diffedLines) {
          if (diffedLines === void 0) {
            diffedLines = { left: [], right: [] };
          }
          var codeEditorSettings = [];
          var newMarkerSet = {
            left: [],
            right: []
          };
          for (var i = 0; i < diffedLines.left.length; i++) {
            var markerObj = {
              startRow: diffedLines.left[i].startLine - 1,
              endRow: diffedLines.left[i].endLine,
              type: "text",
              className: "codeMarker"
            };
            newMarkerSet.left.push(markerObj);
          }
          for (var i = 0; i < diffedLines.right.length; i++) {
            var markerObj = {
              startRow: diffedLines.right[i].startLine - 1,
              endRow: diffedLines.right[i].endLine,
              type: "text",
              className: "codeMarker"
            };
            newMarkerSet.right.push(markerObj);
          }
          codeEditorSettings[0] = newMarkerSet.left;
          codeEditorSettings[1] = newMarkerSet.right;
          return codeEditorSettings;
        };
        DiffComponent2.prototype.render = function() {
          var markers = this.diff();
          return React.createElement(split_1.default, { name: this.props.name, className: this.props.className, focus: this.props.focus, orientation: this.props.orientation, splits: this.props.splits, mode: this.props.mode, theme: this.props.theme, height: this.props.height, width: this.props.width, fontSize: this.props.fontSize, showGutter: this.props.showGutter, onChange: this.onChange, onPaste: this.props.onPaste, onLoad: this.props.onLoad, onScroll: this.props.onScroll, minLines: this.props.minLines, maxLines: this.props.maxLines, readOnly: this.props.readOnly, highlightActiveLine: this.props.highlightActiveLine, showPrintMargin: this.props.showPrintMargin, tabSize: this.props.tabSize, cursorStart: this.props.cursorStart, editorProps: this.props.editorProps, style: this.props.style, scrollMargin: this.props.scrollMargin, setOptions: this.props.setOptions, wrapEnabled: this.props.wrapEnabled, enableBasicAutocompletion: this.props.enableBasicAutocompletion, enableLiveAutocompletion: this.props.enableLiveAutocompletion, value: this.state.value, markers });
        };
        DiffComponent2.propTypes = {
          cursorStart: PropTypes.number,
          editorProps: PropTypes.object,
          enableBasicAutocompletion: PropTypes.bool,
          enableLiveAutocompletion: PropTypes.bool,
          focus: PropTypes.bool,
          fontSize: PropTypes.number,
          height: PropTypes.string,
          highlightActiveLine: PropTypes.bool,
          maxLines: PropTypes.number,
          minLines: PropTypes.number,
          mode: PropTypes.string,
          name: PropTypes.string,
          className: PropTypes.string,
          onLoad: PropTypes.func,
          onPaste: PropTypes.func,
          onScroll: PropTypes.func,
          onChange: PropTypes.func,
          orientation: PropTypes.string,
          readOnly: PropTypes.bool,
          scrollMargin: PropTypes.array,
          setOptions: PropTypes.object,
          showGutter: PropTypes.bool,
          showPrintMargin: PropTypes.bool,
          splits: PropTypes.number,
          style: PropTypes.object,
          tabSize: PropTypes.number,
          theme: PropTypes.string,
          value: PropTypes.array,
          width: PropTypes.string,
          wrapEnabled: PropTypes.bool
        };
        DiffComponent2.defaultProps = {
          cursorStart: 1,
          editorProps: {},
          enableBasicAutocompletion: false,
          enableLiveAutocompletion: false,
          focus: false,
          fontSize: 12,
          height: "500px",
          highlightActiveLine: true,
          maxLines: null,
          minLines: null,
          mode: "",
          name: "ace-editor",
          onLoad: null,
          onScroll: null,
          onPaste: null,
          onChange: null,
          orientation: "beside",
          readOnly: false,
          scrollMargin: [0, 0, 0, 0],
          setOptions: {},
          showGutter: true,
          showPrintMargin: true,
          splits: 2,
          style: {},
          tabSize: 4,
          theme: "github",
          value: ["", ""],
          width: "500px",
          wrapEnabled: true
        };
        return DiffComponent2;
      }(React.Component)
    );
    exports.default = DiffComponent;
  }
});

// node_modules/react-ace/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-ace/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.diff = exports.split = void 0;
    var ace_1 = require_ace2();
    var diff_1 = require_diff();
    exports.diff = diff_1.default;
    var split_1 = require_split();
    exports.split = split_1.default;
    exports.default = ace_1.default;
  }
});
export default require_lib();
/*! Bundled license information:

ace-builds/src-noconflict/ace.js:
  (*
  * based on code from:
  *
  * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
  * Available via the MIT or new BSD license.
  * see: http://github.com/jrburke/requirejs for details
  *)
  (*! @license
  ==========================================================================
  SproutCore -- JavaScript Application Framework
  copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.
  
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.
  
  For more information about SproutCore, visit http://www.sproutcore.com
  
  
  ==========================================================================
  @license *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=react-ace.js.map
